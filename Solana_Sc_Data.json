[
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\npub mod vulnerable_dex {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, fee: u64) -> Result<()> {\n        let dex = &mut ctx.accounts.dex;\n        dex.authority = ctx.accounts.authority.key();\n        dex.fee = fee;\n        Ok(())\n    }\n\n    pub fn swap(ctx: Context<Swap>, amount_in: u64, minimum_amount_out: u64) -> Result<()> {\n        let dex = &ctx.accounts.dex;\n        let token_a = &ctx.accounts.token_a;\n        let token_b = &ctx.accounts.token_b;\n\n        // Calculate swap amount\n        let balance_a = ctx.accounts.dex_token_a.amount;\n        let balance_b = ctx.accounts.dex_token_b.amount;\n        let amount_out = (balance_b as u128)\n            .checked_mul(amount_in as u128)\n            .unwrap()\n            .checked_div(balance_a as u128)\n            .unwrap() as u64;\n\n        require!(amount_out >= minimum_amount_out, ErrorCode::SlippageExceeded);\n\n        // Apply fee\n        let fee_amount = amount_out.checked_mul(dex.fee).unwrap().checked_div(10000).unwrap();\n        let amount_out_after_fee = amount_out.checked_sub(fee_amount).unwrap();\n\n        // Transfer tokens\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: token_a.to_account_info(),\n                    to: ctx.accounts.dex_token_a.to_account_info(),\n                    authority: ctx.accounts.user.to_account_info(),\n                },\n            ),\n            amount_in,\n        )?;\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.dex_token_b.to_account_info(),\n                    to: token_b.to_account_info(),\n                    authority: ctx.accounts.dex.to_account_info(),\n                },\n                &[&[&dex.authority.to_bytes(), &[*ctx.bumps.get(\"dex\").unwrap()]]],\n            ),\n            amount_out_after_fee,\n        )?;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 8)]\n    pub dex: Account<'info, Dex>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Swap<'info> {\n    #[account(mut)]\n    pub dex: Account<'info, Dex>,\n    #[account(mut)]\n    pub token_a: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub token_b: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub dex_token_a: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub dex_token_b: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct Dex {\n    pub authority: Pubkey,\n    pub fee: u64,\n}",
        "vulnerabilities": [
          "Unchecked arithmetic may lead to silent integer overflow, causing unexpected behavior or security flaws.",
          "Insufficient input validation leaves the system vulnerable to injection attacks and malformed data exploitation.",
          "Absent or inadequate access control mechanisms potentially expose sensitive resources to unauthorized users."
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\npub mod vulnerable_lending {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, interest_rate: u64) -> Result<()> {\n        let lending_pool = &mut ctx.accounts.lending_pool;\n        lending_pool.authority = ctx.accounts.authority.key();\n        lending_pool.interest_rate = interest_rate;\n        Ok(())\n    }\n\n    pub fn deposit(ctx: Context<Deposit>, amount: u64) -> Result<()> {\n        let lending_pool = &mut ctx.accounts.lending_pool;\n        let user = &ctx.accounts.user;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_account.to_account_info(),\n                    to: ctx.accounts.pool_token_account.to_account_info(),\n                    authority: user.to_account_info(),\n                },\n            ),\n            amount,\n        )?;\n\n        lending_pool.total_deposits += amount;\n        lending_pool.user_deposits.insert(user.key(), amount);\n\n        Ok(())\n    }\n\n    pub fn borrow(ctx: Context<Borrow>, amount: u64) -> Result<()> {\n        let lending_pool = &mut ctx.accounts.lending_pool;\n        let user = &ctx.accounts.user;\n\n        require!(lending_pool.total_deposits >= amount, ErrorCode::InsufficientFunds);\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.pool_token_account.to_account_info(),\n                    to: ctx.accounts.user_token_account.to_account_info(),\n                    authority: lending_pool.to_account_info(),\n                },\n                &[&[&lending_pool.authority.to_bytes(), &[*ctx.bumps.get(\"lending_pool\").unwrap()]]],\n            ),\n            amount,\n        )?;\n\n        lending_pool.total_borrows += amount;\n        lending_pool.user_borrows.insert(user.key(), amount);\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 8 + 64 + 64)]\n    pub lending_pool: Account<'info, LendingPool>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Deposit<'info> {\n    #[account(mut)]\n    pub lending_pool: Account<'info, LendingPool>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct Borrow<'info> {\n    #[account(mut)]\n    pub lending_pool: Account<'info, LendingPool>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct LendingPool {\n    pub authority: Pubkey,\n    pub interest_rate: u64,\n    pub total_deposits: u64,\n    pub total_borrows: u64,\n    pub user_deposits: std::collections::HashMap<Pubkey, u64>,\n    pub user_borrows: std::collections::HashMap<Pubkey, u64>,\n}",
        "vulnerabilities": [
          "Reentrancy vulnerability in deposit and borrow functions",
          "Lack of collateral checks for borrowing",
          "Missing   calculation and accrual"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\nuse std::mem::size_of;\n\ndeclare_id!(\"Dex111111111111111111111111111111111111111\");\n\n#[program]\npub mod vulnerable_dex {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, fee: u64) -> Result<()> {\n        let dex = &mut ctx.accounts.dex;\n        dex.authority = ctx.accounts.authority.key();\n        dex.fee = fee;\n        dex.total_liquidity = 0;\n        Ok(())\n    }\n\n    pub fn add_liquidity(ctx: Context<AddLiquidity>, amount_a: u64, amount_b: u64) -> Result<()> {\n        let dex = &mut ctx.accounts.dex;\n        let token_a = &mut ctx.accounts.token_a;\n        let token_b = &mut ctx.accounts.token_b;\n\n        // Transfer tokens to the DEX\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: token_a.to_account_info(),\n                    to: ctx.accounts.dex_token_a.to_account_info(),\n                    authority: ctx.accounts.user.to_account_info(),\n                },\n            ),\n            amount_a,\n        )?;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: token_b.to_account_info(),\n                    to: ctx.accounts.dex_token_b.to_account_info(),\n                    authority: ctx.accounts.user.to_account_info(),\n                },\n            ),\n            amount_b,\n        )?;\n\n        // Update liquidity\n        dex.total_liquidity += amount_a.checked_add(amount_b).unwrap();\n        \n        Ok(())\n    }\n\n    pub fn swap(ctx: Context<Swap>, amount_in: u64, minimum_amount_out: u64) -> Result<()> {\n        let dex = &ctx.accounts.dex;\n        let token_a = &ctx.accounts.token_a;\n        let token_b = &ctx.accounts.token_b;\n\n        // Calculate swap amount\n        let balance_a = ctx.accounts.dex_token_a.amount;\n        let balance_b = ctx.accounts.dex_token_b.amount;\n        let amount_out = (balance_b as u128)\n            .checked_mul(amount_in as u128)\n            .unwrap()\n            .checked_div(balance_a as u128)\n            .unwrap() as u64;\n\n        require!(amount_out >= minimum_amount_out, ErrorCode::SlippageExceeded);\n\n        // Apply fee\n        let fee_amount = amount_out.checked_mul(dex.fee).unwrap().checked_div(10000).unwrap();\n        let amount_out_after_fee = amount_out.checked_sub(fee_amount).unwrap();\n\n        // Transfer tokens\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: token_a.to_account_info(),\n                    to: ctx.accounts.dex_token_a.to_account_info(),\n                    authority: ctx.accounts.user.to_account_info(),\n                },\n            ),\n            amount_in,\n        )?;\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.dex_token_b.to_account_info(),\n                    to: token_b.to_account_info(),\n                    authority: ctx.accounts.dex.to_account_info(),\n                },\n                &[&[&dex.authority.to_bytes(), &[*ctx.bumps.get(\"dex\").unwrap()]]],\n            ),\n            amount_out_after_fee,\n        )?;\n\n        Ok(())\n    }\n\n    pub fn remove_liquidity(ctx: Context<RemoveLiquidity>, amount: u64) -> Result<()> {\n        let dex = &mut ctx.accounts.dex;\n        let token_a = &mut ctx.accounts.token_a;\n        let token_b = &mut ctx.accounts.token_b;\n\n        // Calculate proportional amounts\n        let total_balance = ctx.accounts.dex_token_a.amount + ctx.accounts.dex_token_b.amount;\n        let amount_a = (ctx.accounts.dex_token_a.amount as u128)\n            .checked_mul(amount as u128)\n            .unwrap()\n            .checked_div(total_balance as u128)\n            .unwrap() as u64;\n        let amount_b = (ctx.accounts.dex_token_b.amount as u128)\n            .checked_mul(amount as u128)\n            .unwrap()\n            .checked_div(total_balance as u128)\n            .unwrap() as u64;\n\n        // Transfer tokens back to user\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.dex_token_a.to_account_info(),\n                    to: token_a.to_account_info(),\n                    authority: ctx.accounts.dex.to_account_info(),\n                },\n                &[&[&dex.authority.to_bytes(), &[*ctx.bumps.get(\"dex\").unwrap()]]],\n            ),\n            amount_a,\n        )?;\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.dex_token_b.to_account_info(),\n                    to: token_b.to_account_info(),\n                    authority: ctx.accounts.dex.to_account_info(),\n                },\n                &[&[&dex.authority.to_bytes(), &[*ctx.bumps.get(\"dex\").unwrap()]]],\n            ),\n            amount_b,\n        )?;\n\n        // Update liquidity\n        dex.total_liquidity = dex.total_liquidity.checked_sub(amount).unwrap();\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + size_of::<DexState>())]\n    pub dex: Account<'info, DexState>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct AddLiquidity<'info> {\n    #[account(mut)]\n    pub dex: Account<'info, DexState>,\n    #[account(mut)]\n    pub token_a: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub token_b: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub dex_token_a: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub dex_token_b: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct Swap<'info> {\n    #[account(mut)]\n    pub dex: Account<'info, DexState>,\n    #[account(mut)]\n    pub token_a: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub token_b: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub dex_token_a: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub dex_token_b: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct RemoveLiquidity<'info> {\n    #[account(mut)]\n    pub dex: Account<'info, DexState>,\n    #[account(mut)]\n    pub token_a: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub token_b: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub dex_token_a: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub dex_token_b: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct DexState {\n    pub authority: Pubkey,\n    pub fee: u64,\n    pub total_liquidity: u64,\n}\n\n#[error_code]\npub enum ErrorCode {\n    #[msg(\"Slippage tolerance exceeded\")]\n    SlippageExceeded,\n}",
        "vulnerabilities": [
          "Integer overflow/underflow",
          "Rounding errors",
          "Lack of access control",
          "Missing slippage protection",
          "Centralization risk",
          "Lack of pause mechanism",
          "Potential reentrancy",
          "Lack of event emission",
          "Missing input validation",
          "Potential precision loss"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*; use anchor_spl::token::{self, Token, TokenAccount, Transfer}; #[program] pub mod unsafe_staking { use super::*; pub fn initialize(ctx: Context<Initialize>, staking_period: i64) -> Result<()> { let staking_pool = &mut ctx.accounts.staking_pool; staking_pool.admin = ctx.accounts.admin.key(); staking_pool.staking_period = staking_period; staking_pool.total_staked = 0; Ok(()) } pub fn stake(ctx: Context<Stake>, amount: u64) -> Result<()> { let staking_pool = &mut ctx.accounts.staking_pool; let user = &mut ctx.accounts.user; token::transfer(CpiContext::new(ctx.accounts.token_program.to_account_info(), Transfer { from: ctx.accounts.user_token_account.to_account_info(), to: ctx.accounts.pool_token_account.to_account_info(), authority: user.to_account_info(), }), amount)?; user.staked_amount = user.staked_amount.checked_add(amount).unwrap(); user.stake_timestamp = Clock::get()?.unix_timestamp; staking_pool.total_staked += amount; Ok(()) } pub fn unstake(ctx: Context<Unstake>) -> Result<()> { let staking_pool = &mut ctx.accounts.staking_pool; let user = &mut ctx.accounts.user; let current_time = Clock::get()?.unix_timestamp; require!(current_time >= user.stake_timestamp + staking_pool.staking_period, StakingError::StakingPeriodNotElapsed); let amount = user.staked_amount; token::transfer(CpiContext::new_with_signer(ctx.accounts.token_program.to_account_info(), Transfer { from: ctx.accounts.pool_token_account.to_account_info(), to: ctx.accounts.user_token_account.to_account_info(), authority: staking_pool.to_account_info(), }, &[&[b\"staking_pool\".as_ref(), &[staking_pool.bump]]]), amount)?; user.staked_amount = 0; user.stake_timestamp = 0; staking_pool.total_staked = staking_pool.total_staked.checked_sub(amount).unwrap(); Ok(()) } }",
        "vulnerabilities": [
            "Arithmetic vulnerability: Integer overflow risk in stake function, potentially leading to incorrect staking amounts or unexpected behavior",
            "Insufficient authorization: Lack of access control in initialize function, allowing unauthorized initialization or re-initialization of the contract",
            "Smart contract vulnerability: Potential reentrancy attack in unstake function, risking multiple withdrawals or manipulation of contract state"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*; use anchor_spl::token::{self, Token, TokenAccount, Transfer}; #[program] pub mod unsafe_swap { use super::*; pub fn initialize_pool(ctx: Context<InitializePool>, fee: u64) -> Result<()> { ctx.accounts.pool.token_a_account = ctx.accounts.token_a_account.key(); ctx.accounts.pool.token_b_account = ctx.accounts.token_b_account.key(); ctx.accounts.pool.fee = fee; Ok(()) } pub fn swap(ctx: Context<Swap>, amount_in: u64, minimum_amount_out: u64) -> Result<()> { let pool = &ctx.accounts.pool; let reserve_a = ctx.accounts.token_a_reserve.amount; let reserve_b = ctx.accounts.token_b_reserve.amount; let amount_out = (reserve_b as u128) * (amount_in as u128) / (reserve_a as u128); require!(amount_out >= minimum_amount_out as u128, SwapError::SlippageExceeded); let fee_amount = amount_out * pool.fee as u128 / 10000; let amount_out_after_fee = amount_out - fee_amount; token::transfer(CpiContext::new(ctx.accounts.token_program.to_account_info(), Transfer { from: ctx.accounts.user_token_a.to_account_info(), to: ctx.accounts.token_a_reserve.to_account_info(), authority: ctx.accounts.user.to_account_info(), }), amount_in)?; token::transfer(CpiContext::new_with_signer(ctx.accounts.token_program.to_account_info(), Transfer { from: ctx.accounts.token_b_reserve.to_account_info(), to: ctx.accounts.user_token_b.to_account_info(), authority: pool.to_account_info(), }, &[&[b\"pool\".as_ref(), &[pool.bump]]]), amount_out_after_fee as u64)?; Ok(()) } }",
        "vulnerabilities": [
            "Calculation inaccuracy: Lack of decimal precision handling in swap calculations, potentially leading to rounding errors and unfair trades",
            "Arithmetic error risk: No check for division by zero in swap function, possibly causing transaction failures or unexpected behavior",
            "Unrestricted pool creation: Missing access control for initialize_pool function, allowing unauthorized creation of new liquidity pools"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*; use anchor_spl::token::{self, Token, TokenAccount, Transfer}; #[program] pub mod unsafe_lottery { use super::*; pub fn initialize(ctx: Context<Initialize>, ticket_price: u64) -> Result<()> { ctx.accounts.lottery.admin = ctx.accounts.admin.key(); ctx.accounts.lottery.ticket_price = ticket_price; ctx.accounts.lottery.is_active = true; Ok(()) } pub fn buy_ticket(ctx: Context<BuyTicket>) -> Result<()> { require!(ctx.accounts.lottery.is_active, LotteryError::LotteryClosed); token::transfer(CpiContext::new(ctx.accounts.token_program.to_account_info(), Transfer { from: ctx.accounts.buyer_token_account.to_account_info(), to: ctx.accounts.lottery_token_account.to_account_info(), authority: ctx.accounts.buyer.to_account_info(), }), ctx.accounts.lottery.ticket_price)?; ctx.accounts.ticket.owner = ctx.accounts.buyer.key(); ctx.accounts.ticket.number = ctx.accounts.lottery.total_tickets; ctx.accounts.lottery.total_tickets += 1; Ok(()) } pub fn draw_winner(ctx: Context<DrawWinner>) -> Result<()> { require!(ctx.accounts.lottery.admin == ctx.accounts.admin.key(), LotteryError::Unauthorized); require!(ctx.accounts.lottery.is_active, LotteryError::LotteryClosed); let clock = Clock::get()?; let random_number = clock.unix_timestamp as u64 % ctx.accounts.lottery.total_tickets; ctx.accounts.lottery.winner = ctx.accounts.ticket_accounts[random_number as usize].owner; ctx.accounts.lottery.is_active = false; Ok(()) } }",
        "vulnerabilities": [
            "Use of manipulable on-chain data for randomness allows malicious actors to predict or influence lottery outcomes, compromising fairness.",
            "Absence of duplicate ticket purchase validation enables potential exploitation of the lottery system and unfair advantage.",
            "Lack of restrictions on admin participation creates a conflict of interest and potential for insider exploitation of the lottery."
        ]
    },
    {
        "code": "use anchor_lang::prelude::*; use anchor_spl::token::{self, Token, TokenAccount, Transfer}; #[program] pub mod unsafe_vault { use super::*; pub fn initialize(ctx: Context<Initialize>) -> Result<()> { ctx.accounts.vault.admin = ctx.accounts.admin.key(); Ok(()) } pub fn deposit(ctx: Context<Deposit>, amount: u64) -> Result<()> { token::transfer(CpiContext::new(ctx.accounts.token_program.to_account_info(), Transfer { from: ctx.accounts.user_token_account.to_account_info(), to: ctx.accounts.vault_token_account.to_account_info(), authority: ctx.accounts.user.to_account_info(), }), amount)?; ctx.accounts.user_deposit.amount += amount; Ok(()) } pub fn withdraw(ctx: Context<Withdraw>, amount: u64) -> Result<()> { require!(ctx.accounts.user_deposit.amount >= amount, VaultError::InsufficientFunds); token::transfer(CpiContext::new_with_signer(ctx.accounts.token_program.to_account_info(), Transfer { from: ctx.accounts.vault_token_account.to_account_info(), to: ctx.accounts.user_token_account.to_account_info(), authority: ctx.accounts.vault.to_account_info(), }, &[&[b\"vault\".as_ref(), &[ctx.accounts.vault.bump]]]), amount)?; ctx.accounts.user_deposit.amount -= amount; Ok(()) } pub fn admin_withdraw(ctx: Context<AdminWithdraw>, amount: u64) -> Result<()> { require!(ctx.accounts.vault.admin == ctx.accounts.admin.key(), VaultError::Unauthorized); token::transfer(CpiContext::new_with_signer(ctx.accounts.token_program.to_account_info(), Transfer { from: ctx.accounts.vault_token_account.to_account_info(), to: ctx.accounts.admin_token_account.to_account_info(), authority: ctx.accounts.vault.to_account_info(), }, &[&[b\"vault\".as_ref(), &[ctx.accounts.vault.bump]]]), amount)?; Ok(()) } }",
        "vulnerabilities": [
            "Arithmetic vulnerability: Integer overflow risk in deposit and borrow functions, potentially leading to incorrect amounts or unexpected behavior",
            "Economic risk: No collateral requirement for borrowing, potentially allowing users to borrow more than they can repay",
            "Calculation inaccuracy: Lack of precision in interest calculation leading to potential loss of funds, possibly resulting in unfair interest accumulation or distribution"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*; use anchor_spl::token::{self, Token, TokenAccount, Transfer}; #[program] pub mod unsafe_lending { use super::*; pub fn initialize(ctx: Context<Initialize>, interest_rate: u64) -> Result<()> { ctx.accounts.lending_pool.admin = ctx.accounts.admin.key(); ctx.accounts.lending_pool.interest_rate = interest_rate; Ok(()) } pub fn deposit(ctx: Context<Deposit>, amount: u64) -> Result<()> { token::transfer(CpiContext::new(ctx.accounts.token_program.to_account_info(), Transfer { from: ctx.accounts.user_token_account.to_account_info(), to: ctx.accounts.pool_token_account.to_account_info(), authority: ctx.accounts.user.to_account_info(), }), amount)?; ctx.accounts.user_deposit.amount += amount; ctx.accounts.lending_pool.total_deposits += amount; Ok(()) } pub fn borrow(ctx: Context<Borrow>, amount: u64) -> Result<()> { require!(ctx.accounts.lending_pool.total_deposits >= amount, LendingError::InsufficientFunds); token::transfer(CpiContext::new_with_signer(ctx.accounts.token_program.to_account_info(), Transfer { from: ctx.accounts.pool_token_account.to_account_info(), to: ctx.accounts.user_token_account.to_account_info(), authority: ctx.accounts.lending_pool.to_account_info(), }, &[&[b\"lending_pool\".as_ref(), &[ctx.accounts.lending_pool.bump]]]), amount)?; ctx.accounts.user_loan.amount += amount; ctx.accounts.user_loan.timestamp = Clock::get()?.unix_timestamp; ctx.accounts.lending_pool.total_borrows += amount; Ok(()) } pub fn repay(ctx: Context<Repay>, amount: u64) -> Result<()> { let interest = (amount * ctx.accounts.lending_pool.interest_rate * (Clock::get()?.unix_timestamp - ctx.accounts.user_loan.timestamp) as u64) / (365 * 24 * 60 * 60 * 10000); let total_repayment = amount + interest; token::transfer(CpiContext::new(ctx.accounts.token_program.to_account_info(), Transfer { from: ctx.accounts.user_token_account.to_account_info(), to: ctx.accounts.pool_token_account.to_account_info(), authority: ctx.accounts.user.to_account_info(), }), total_repayment)?; ctx.accounts.user_loan.amount -= amount; ctx.accounts.lending_pool.total_borrows -= amount; Ok(()) } }",
        "vulnerabilities": [
            "Arithmetic vulnerability: Integer overflow risk in deposit and borrow functions, potentially leading to incorrect amounts or unexpected behavior",
            "Economic risk: No collateral requirement for borrowing, potentially allowing users to borrow more than they can repay",
            "Calculation inaccuracy: Lack of precision in interest calculation leading to potential loss of funds, possibly resulting in unfair interest accumulation or distribution"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*; use anchor_spl::token::{self, Token, TokenAccount, Transfer}; #[program] pub mod unsafe_auction { use super::*; pub fn create_auction(ctx: Context<CreateAuction>, start_price: u64, duration: i64) -> Result<()> { let clock = Clock::get()?; ctx.accounts.auction.seller = ctx.accounts.seller.key(); ctx.accounts.auction.highest_bidder = ctx.accounts.seller.key(); ctx.accounts.auction.highest_bid = start_price; ctx.accounts.auction.end_time = clock.unix_timestamp + duration; ctx.accounts.auction.ended = false; Ok(()) } pub fn place_bid(ctx: Context<PlaceBid>, amount: u64) -> Result<()> { let clock = Clock::get()?; require!(!ctx.accounts.auction.ended, AuctionError::AuctionEnded); require!(clock.unix_timestamp < ctx.accounts.auction.end_time, AuctionError::AuctionEnded); require!(amount > ctx.accounts.auction.highest_bid, AuctionError::BidTooLow); token::transfer(CpiContext::new(ctx.accounts.token_program.to_account_info(), Transfer { from: ctx.accounts.bidder_token_account.to_account_info(), to: ctx.accounts.auction_escrow.to_account_info(), authority: ctx.accounts.bidder.to_account_info(), }), amount)?; if ctx.accounts.auction.highest_bidder != ctx.accounts.auction.seller { token::transfer(CpiContext::new_with_signer(ctx.accounts.token_program.to_account_info(), Transfer { from: ctx.accounts.auction_escrow.to_account_info(), to: ctx.accounts.previous_bidder_token_account.to_account_info(), authority: ctx.accounts.auction.to_account_info(), }, &[&[b\"auction\".as_ref(), &[ctx.accounts.auction.bump]]]), ctx.accounts.auction.highest_bid)?; } ctx.accounts.auction.highest_bidder = ctx.accounts.bidder.key(); ctx.accounts.auction.highest_bid = amount; Ok(()) } pub fn end_auction(ctx: Context<EndAuction>) -> Result<()> { let clock = Clock::get()?; require!(!ctx.accounts.auction.ended, AuctionError::AuctionAlreadyEnded); require!(clock.unix_timestamp >= ctx.accounts.auction.end_time, AuctionError::AuctionNotEnded); ctx.accounts.auction.ended = true; token::transfer(CpiContext::new_with_signer(ctx.accounts.token_program.to_account_info(), Transfer { from: ctx.accounts.auction_escrow.to_account_info(), to: ctx.accounts.seller_token_account.to_account_info(), authority: ctx.accounts.auction.to_account_info(), }, &[&[b\"auction\".as_ref(), &[ctx.accounts.auction.bump]]]), ctx.accounts.auction.highest_bid)?; Ok(()) } }",
        "vulnerabilities": [
            "Absence of safeguards against multiple votes per user, potentially compromising the integrity of governance decisions",
            "Missing minimum participation threshold for proposal execution, risking implementation of decisions without sufficient consensus",
            "Lack of vote locking period, allowing last-minute vote manipulation and potential governance attacks"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*; use anchor_spl::token::{self, Token, TokenAccount, Transfer}; #[program] pub mod unsafe_governance { use super::*; pub fn create_proposal(ctx: Context<CreateProposal>, description: String, voting_period: i64) -> Result<()> { let clock = Clock::get()?; ctx.accounts.proposal.creator = ctx.accounts.creator.key(); ctx.accounts.proposal.description = description; ctx.accounts.proposal.end_time = clock.unix_timestamp + voting_period; ctx.accounts.proposal.yes_votes = 0; ctx.accounts.proposal.no_votes = 0; ctx.accounts.proposal.executed = false; Ok(()) } pub fn cast_vote(ctx: Context<CastVote>, vote: bool) -> Result<()> { let clock = Clock::get()?; require!(clock.unix_timestamp < ctx.accounts.proposal.end_time, GovernanceError::VotingEnded); let voter_weight = ctx.accounts.voter_token_account.amount; if vote { ctx.accounts.proposal.yes_votes += voter_weight; } else { ctx.accounts.proposal.no_votes += voter_weight; } Ok(()) } pub fn execute_proposal(ctx: Context<ExecuteProposal>) -> Result<()> { let clock = Clock::get()?; require!(clock.unix_timestamp >= ctx.accounts.proposal.end_time, GovernanceError::VotingNotEnded); require!(!ctx.accounts.proposal.executed, GovernanceError::ProposalAlreadyExecuted); require!(ctx.accounts.proposal.yes_votes > ctx.accounts.proposal.no_votes, GovernanceError::ProposalRejected); ctx.accounts.proposal.executed = true; // Execute proposal logic here Ok(()) } }",
        "vulnerabilities": [
            "Insufficient validation of NFT ownership during listing creation, potentially enabling fraudulent sales of unowned assets",
            "Absence of price reasonability checks in purchase function, risking accidental or malicious transactions at extreme prices",
            "Unrestricted access to listing cancellation, allowing unauthorized removal of valid marketplace offerings"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*; use anchor_spl::token::{self, Token, TokenAccount, Transfer}; #[program] pub mod unsafe_nft_marketplace { use super::*; pub fn list_nft(ctx: Context<ListNFT>, price: u64) -> Result<()> { ctx.accounts.listing.seller = ctx.accounts.seller.key(); ctx.accounts.listing.nft_mint = ctx.accounts.nft_mint.key(); ctx.accounts.listing.price = price; token::transfer(CpiContext::new(ctx.accounts.token_program.to_account_info(), Transfer { from: ctx.accounts.seller_nft_account.to_account_info(), to: ctx.accounts.escrow_nft_account.to_account_info(), authority: ctx.accounts.seller.to_account_info(), }), 1)?; Ok(()) } pub fn buy_nft(ctx: Context<BuyNFT>) -> Result<()> { let listing = &ctx.accounts.listing; token::transfer(CpiContext::new(ctx.accounts.token_program.to_account_info(), Transfer { from: ctx.accounts.buyer_token_account.to_account_info(), to: ctx.accounts.seller_token_account.to_account_info(), authority: ctx.accounts.buyer.to_account_info(), }), listing.price)?; token::transfer(CpiContext::new_with_signer(ctx.accounts.token_program.to_account_info(), Transfer { from: ctx.accounts.escrow_nft_account.to_account_info(), to: ctx.accounts.buyer_nft_account.to_account_info(), authority: listing.to_account_info(), }, &[&[b\"listing\".as_ref(), listing.nft_mint.as_ref(), &[listing.bump]]]), 1)?; Ok(()) } pub fn cancel_listing(ctx: Context<CancelListing>) -> Result<()> { let listing = &ctx.accounts.listing; token::transfer(CpiContext::new_with_signer(ctx.accounts.token_program.to_account_info(), Transfer { from: ctx.accounts.escrow_nft_account.to_account_info(), to: ctx.accounts.seller_nft_account.to_account_info(), authority: listing.to_account_info(), }, &[&[b\"listing\".as_ref(), listing.nft_mint.as_ref(), &[listing.bump]]]), 1)?; Ok(()) } }",
        "vulnerabilities": [
            "Unprotected arithmetic in reward calculations, risking integer overflow and incorrect distribution of incentives",
            "Missing penalty mechanism for premature unstaking, potentially destabilizing protocol liquidity and tokenomics",
            "Lack of balance verification before reward distribution, risking failed transactions or unintended reward shortfalls"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\npub mod secure_staking {\n    use super::*;\n\n    pub fn stake(ctx: Context<Stake>, amount: u64) -> Result<()> {\n        let staking = &mut ctx.accounts.staking;\n        staking.total_staked += amount;\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.staker_account.to_account_info(),\n                    to: ctx.accounts.staking_account.to_account_info(),\n                    authority: ctx.accounts.staker.to_account_info(),\n                },\n            ),\n            amount,\n        )?;\n        Ok(())\n    }\n\n    pub fn withdraw(ctx: Context<Withdraw>, amount: u64) -> Result<()> {\n        let staking = &mut ctx.accounts.staking;\n        require!(staking.total_staked >= amount, StakingError::InsufficientFunds);\n        staking.total_staked -= amount;\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.staking_account.to_account_info(),\n                    to: ctx.accounts.recipient_account.to_account_info(),\n                    authority: ctx.accounts.authority.to_account_info(),\n                },\n            ),\n            amount,\n        )?;\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Stake<'info> {\n    #[account(mut)]\n    pub staking: Account<'info, Staking>,\n    #[account(mut)]\n    pub staker_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub staking_account: Account<'info, TokenAccount>,\n    pub staker: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct Withdraw<'info> {\n    #[account(mut)]\n    pub staking: Account<'info, Staking>,\n    #[account(mut)]\n    pub staking_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub recipient_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct Staking {\n    pub total_staked: u64,\n}\n\n#[error_code]\npub enum StakingError {\n    #[msg(\"Insufficient funds\")]\n    InsufficientFunds,\n}",
        "vulnerabilities": []
    },    
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\npub mod vulnerable_staking {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, reward_rate: u64) -> Result<()> {\n        let staking_pool = &mut ctx.accounts.staking_pool;\n        staking_pool.authority = ctx.accounts.authority.key();\n        staking_pool.reward_rate = reward_rate;\n        staking_pool.last_update_time = Clock::get()?.unix_timestamp;\n        Ok(())\n    }\n\n    pub fn stake(ctx: Context<Stake>, amount: u64) -> Result<()> {\n        let staking_pool = &mut ctx.accounts.staking_pool;\n        let user = &ctx.accounts.user;\n\n        update_rewards(staking_pool, user.key())?;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_account.to_account_info(),\n                    to: ctx.accounts.pool_token_account.to_account_info(),\n                    authority: user.to_account_info(),\n                },\n            ),\n            amount,\n        )?;\n\n        staking_pool.total_staked += amount;\n        staking_pool.user_stakes.insert(user.key(), amount);\n\n        Ok(())\n    }\n\n    pub fn unstake(ctx: Context<Unstake>, amount: u64) -> Result<()> {\n        let staking_pool = &mut ctx.accounts.staking_pool;\n        let user = &ctx.accounts.user;\n\n        update_rewards(staking_pool, user.key())?;\n\n        let user_stake = staking_pool.user_stakes.get(&user.key()).unwrap();\n        require!(*user_stake >= amount, ErrorCode::InsufficientStake);\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.pool_token_account.to_account_info(),\n                    to: ctx.accounts.user_token_account.to_account_info(),\n                    authority: staking_pool.to_account_info(),\n                },\n                &[&[&staking_pool.authority.to_bytes(), &[*ctx.bumps.get(\"staking_pool\").unwrap()]]],\n            ),\n            amount,\n        )?;\n\n        staking_pool.total_staked -= amount;\n        staking_pool.user_stakes.insert(user.key(), user_stake - amount);\n\n        Ok(())\n    }\n\n    pub fn claim_rewards(ctx: Context<ClaimRewards>) -> Result<()> {\n        let staking_pool = &mut ctx.accounts.staking_pool;\n        let user = &ctx.accounts.user;\n\n        update_rewards(staking_pool, user.key())?;\n\n        let rewards = staking_pool.user_rewards.get(&user.key()).unwrap();\n        require!(*rewards > 0, ErrorCode::NoRewardsToClaim);\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.reward_token_account.to_account_info(),\n                    to: ctx.accounts.user_reward_account.to_account_info(),\n                    authority: staking_pool.to_account_info(),\n                },\n                &[&[&staking_pool.authority.to_bytes(), &[*ctx.bumps.get(\"staking_pool\").unwrap()]]],\n            ),\n            *rewards,\n        )?;\n\n        staking_pool.user_rewards.insert(user.key(), 0);\n\n        Ok(())\n    }\n}\n\nfn update_rewards(staking_pool: &mut Account<StakingPool>, user: Pubkey) -> Result<()> {\n    let current_time = Clock::get()?.unix_timestamp;\n    let time_elapsed = current_time - staking_pool.last_update_time;\n    \n    if time_elapsed > 0 {\n        let rewards_per_token = (staking_pool.reward_rate * time_elapsed as u64) / staking_pool.total_staked;\n        let user_stake = staking_pool.user_stakes.get(&user).unwrap_or(&0);\n        let new_rewards = rewards_per_token * user_stake;\n        \n        let current_rewards = staking_pool.user_rewards.get(&user).unwrap_or(&0);\n        staking_pool.user_rewards.insert(user, current_rewards + new_rewards);\n        \n        staking_pool.last_update_time = current_time;\n    }\n    \n    Ok(())\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 8 + 8 + 64 + 64)]\n    pub staking_pool: Account<'info, StakingPool>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Stake<'info> {\n    #[account(mut)]\n    pub staking_pool: Account<'info, StakingPool>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct Unstake<'info> {\n    #[account(mut)]\n    pub staking_pool: Account<'info, StakingPool>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct ClaimRewards<'info> {\n    #[account(mut)]\n    pub staking_pool: Account<'info, StakingPool>,\n    #[account(mut)]\n    pub user_reward_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub reward_token_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct StakingPool {\n    pub authority: Pubkey,\n    pub reward_rate: u64,\n    pub last_update_time: i64,\n    pub total_staked: u64,\n    pub user_stakes: std::collections::HashMap<Pubkey, u64>,\n    pub user_rewards: std::collections::HashMap<Pubkey, u64>,\n}",
        "vulnerabilities": [
          "Potential integer overflow in reward calculation",
          "Lack of slashing mechanism for early unstaking",
          "Missing checks for reward token balance"
        ]
    },
    {
      "code": "pub fn transfer(ctx: Context<Transfer>, amount: u64) -> Result<()> {\n    let from = &mut ctx.accounts.from;\n    let to = &mut ctx.accounts.to;\n\n    if from.balance < amount {\n        return Err(ErrorCode::InsufficientFunds.into());\n    }\n\n    from.balance = from.balance.checked_sub(amount)\n        .ok_or(ErrorCode::Overflow)?;\n    to.balance = to.balance.checked_add(amount)\n        .ok_or(ErrorCode::Overflow)?;\n\n    Ok(())\n}",
    "vulnerabilities": [
            "Lack of reentrancy guards allows malicious contracts to recursively call functions, potentially draining funds or manipulating state.",
            "Absence of SafeMath or unchecked arithmetic operations risks overflow/underflow, leading to unexpected behavior and potential fund loss.",
            "Failure to validate mathematical operations or results may cause incorrect state changes and compromise contract integrity."
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\n\n#[program]\npub mod safe_token {\n    use super::*;\n\n    pub fn mint(ctx: Context<Mint>, amount: u64) -> Result<()> {\n        let token = &mut ctx.accounts.token;\n        require!(amount > 0, TokenError::InvalidAmount);\n        let new_supply = token.total_supply.checked_add(amount).ok_or(TokenError::Overflow)?;\n        token.total_supply = new_supply;\n        Ok(())\n    }\n\n    pub fn transfer(ctx: Context<Transfer>, amount: u64) -> Result<()> {\n        let from = &mut ctx.accounts.from;\n        let to = &mut ctx.accounts.to;\n        require!(from.balance >= amount, TokenError::InsufficientFunds);\n        from.balance = from.balance.checked_sub(amount).ok_or(TokenError::Underflow)?;\n        to.balance = to.balance.checked_add(amount).ok_or(TokenError::Overflow)?;\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Mint<'info> {\n    #[account(mut)]\n    pub token: Account<'info, Token>,\n    pub authority: Signer<'info>,\n}\n\n#[derive(Accounts)]\npub struct Transfer<'info> {\n    #[account(mut)]\n    pub from: Account<'info, Wallet>,\n    #[account(mut)]\n    pub to: Account<'info, Wallet>,\n    pub authority: Signer<'info>,\n}\n\n#[account]\npub struct Token {\n    pub total_supply: u64,\n}\n\n#[account]\npub struct Wallet {\n    pub balance: u64,\n}\n\n#[error_code]\npub enum TokenError {\n    #[msg(\"Invalid amount\")]\n    InvalidAmount,\n    #[msg(\"Overflow occurred\")]\n    Overflow,\n    #[msg(\"Underflow occurred\")]\n    Underflow,\n    #[msg(\"Insufficient funds\")]\n    InsufficientFunds,\n}",
        "vulnerabilities": []
    },    
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\npub mod vulnerable_staking {\n    use super::*;\n\n    pub fn initialize_pool(ctx: Context<InitializePool>, reward_rate: u64) -> Result<()> {\n        let pool = &mut ctx.accounts.pool;\n        pool.owner = ctx.accounts.owner.key();\n        pool.staking_token = ctx.accounts.staking_token.key();\n        pool.reward_token = ctx.accounts.reward_token.key();\n        pool.reward_rate = reward_rate;\n        pool.last_update_time = Clock::get()?.unix_timestamp;\n        pool.reward_per_token_stored = 0;\n        pool.total_supply = 0;\n        Ok(())\n    }\n\n    pub fn stake(ctx: Context<Stake>, amount: u64) -> Result<()> {\n        let pool = &mut ctx.accounts.pool;\n        let user = &mut ctx.accounts.user;\n\n        update_reward(pool, user)?;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_account.to_account_info(),\n                    to: ctx.accounts.pool_token_account.to_account_info(),\n                    authority: ctx.accounts.user.to_account_info(),\n                },\n            ),\n            amount,\n        )?;\n\n        pool.total_supply += amount;\n        user.balance += amount;\n\n        Ok(())\n    }\n\n    pub fn unstake(ctx: Context<Unstake>, amount: u64) -> Result<()> {\n        let pool = &mut ctx.accounts.pool;\n        let user = &mut ctx.accounts.user;\n\n        update_reward(pool, user)?;\n\n        require!(user.balance >= amount, StakingError::InsufficientBalance);\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.pool_token_account.to_account_info(),\n                    to: ctx.accounts.user_token_account.to_account_info(),\n                    authority: pool.to_account_info(),\n                },\n                &[&[b\"pool\", &[ctx.bumps.pool]]],\n            ),\n            amount,\n        )?;\n\n        pool.total_supply -= amount;\n        user.balance -= amount;\n\n        Ok(())\n    }\n\n    pub fn claim_reward(ctx: Context<ClaimReward>) -> Result<()> {\n        let pool = &mut ctx.accounts.pool;\n        let user = &mut ctx.accounts.user;\n\n        update_reward(pool, user)?;\n\n        let reward = user.reward_earned;\n        user.reward_earned = 0;\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.pool_reward_account.to_account_info(),\n                    to: ctx.accounts.user_reward_account.to_account_info(),\n                    authority: pool.to_account_info(),\n                },\n                &[&[b\"pool\", &[ctx.bumps.pool]]],\n            ),\n            reward,\n        )?;\n\n        Ok(())\n    }\n}\n\nfn update_reward(pool: &mut Account<Pool>, user: &mut Account<User>) -> Result<()> {\n    let current_time = Clock::get()?.unix_timestamp;\n    if pool.total_supply > 0 {\n        pool.reward_per_token_stored += (pool.reward_rate * (current_time - pool.last_update_time) as u64) / pool.total_supply;\n    }\n    user.reward_earned += user.balance * (pool.reward_per_token_stored - user.reward_per_token_paid) / 1e9 as u64;\n    user.reward_per_token_paid = pool.reward_per_token_stored;\n    pool.last_update_time = current_time;\n    Ok()\n}\n\n#[derive(Accounts)]\npub struct InitializePool<'info> {\n    #[account(init, payer = owner, space = 8 + 32 + 32 + 32 + 8 + 8 + 8 + 8)]\n    pub pool: Account<'info, Pool>,\n    #[account(mut)]\n    pub owner: Signer<'info>,\n    pub staking_token: Account<'info, Mint>,\n    pub reward_token: Account<'info, Mint>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Stake<'info> {\n    #[account(mut)]\n    pub pool: Account<'info, Pool>,\n    #[account(mut)]\n    pub user: Account<'info, User>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_account: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct Unstake<'info> {\n    #[account(mut)]\n    pub pool: Account<'info, Pool>,\n    #[account(mut)]\n    pub user: Account<'info, User>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_account: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct ClaimReward<'info> {\n    #[account(mut)]\n    pub pool: Account<'info, Pool>,\n    #[account(mut)]\n    pub user: Account<'info, User>,\n    #[account(mut)]\n    pub user_reward_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_reward_account: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct Pool {\n    pub owner: Pubkey,\n    pub staking_token: Pubkey,\n    pub reward_token: Pubkey,\n    pub reward_rate: u64,\n    pub last_update_time: i64,\n    pub reward_per_token_stored: u64,\n    pub total_supply: u64,\n}\n\n#[account]\npub struct User {\n    pub balance: u64,\n    pub reward_per_token_paid: u64,\n    pub reward_earned: u64,\n}\n\n#[error_code]\npub enum StakingError {\n    #[msg(\"Insufficient balance\")]\n    InsufficientBalance,\n}\n",
        "vulnerabilities": [
          "Potential for integer overflow in reward calculations",
          "Lack of access control for initializing and updating the pool",
          "No slashing mechanism for early unstaking"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\nmod vulnerable_lending {\n    use super::*;\n\n    pub fn initialize_pool(ctx: Context<InitializePool>, pool_seed: u64) -> Result<()> {\n        let pool = &mut ctx.accounts.pool;\n        pool.authority = ctx.accounts.authority.key();\n        pool.lending_token = ctx.accounts.lending_token.key();\n        pool.collateral_token = ctx.accounts.collateral_token.key();\n        pool.lending_amount = 0;\n        pool.collateral_amount = 0;\n        pool.loan_to_value = 80; // 80% LTV\n        pool.seed = pool_seed;\n        Ok(())\n    }\n\n    pub fn deposit(ctx: Context<Deposit>, amount: u64) -> Result<()> {\n        let pool = &mut ctx.accounts.pool;\n        pool.lending_amount = pool.lending_amount.checked_add(amount).unwrap();\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_account.to_account_info(),\n                    to: ctx.accounts.pool_token_account.to_account_info(),\n                    authority: ctx.accounts.user.to_account_info(),\n                },\n            ),\n            amount,\n        )?;\n\n        Ok(())\n    }\n\n    pub fn borrow(ctx: Context<Borrow>, amount: u64) -> Result<()> {\n        let pool = &mut ctx.accounts.pool;\n        let collateral_price = 100; // Assuming 1 collateral token = 100 lending tokens\n        let collateral_value = ctx.accounts.user_collateral_account.amount * collateral_price;\n        let max_borrow = collateral_value * pool.loan_to_value / 100;\n\n        require!(amount <= max_borrow, LendingError::InsufficientCollateral);\n\n        pool.lending_amount = pool.lending_amount.checked_sub(amount).unwrap();\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.pool_token_account.to_account_info(),\n                    to: ctx.accounts.user_token_account.to_account_info(),\n                    authority: pool.to_account_info(),\n                },\n                &[&[b\"pool\", &pool.seed.to_le_bytes(), &[*ctx.bumps.get(\"pool\").unwrap()]]],\n            ),\n            amount,\n        )?;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct InitializePool<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 32 + 32 + 8 + 8 + 8 + 8, seeds = [b\"pool\", pool_seed.to_le_bytes().as_ref()], bump)]\n    pub pool: Account<'info, LendingPool>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub lending_token: Account<'info, Token>,\n    pub collateral_token: Account<'info, Token>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Deposit<'info> {\n    #[account(mut)]\n    pub pool: Account<'info, LendingPool>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct Borrow<'info> {\n    #[account(mut)]\n    pub pool: Account<'info, LendingPool>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_account: Account<'info, TokenAccount>,\n    pub user_collateral_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct LendingPool {\n    pub authority: Pubkey,\n    pub lending_token: Pubkey,\n    pub collateral_token: Pubkey,\n    pub lending_amount: u64,\n    pub collateral_amount: u64,\n    pub loan_to_value: u64,\n    pub seed: u64,\n}\n\n#[error_code]\npub enum LendingError {\n    #[msg(\"Insufficient collateral for borrow\")]\n    InsufficientCollateral,\n}",
        "vulnerabilities": [
          "Lack of price oracle integration for real-time collateral valuation",
          "Missing access control for critical functions",
          "Potential integer overflow in arithmetic operations"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\n\n#[program]\npub mod protected_crowdfunding {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, target_amount: u64, deadline: i64) -> Result<()> {\n        let campaign = &mut ctx.accounts.campaign;\n        campaign.target_amount = target_amount;\n        campaign.collected_amount = 0;\n        campaign.deadline = deadline;\n        Ok(())\n    }\n\n    pub fn donate(ctx: Context<Donate>, amount: u64) -> Result<()> {\n        let campaign = &mut ctx.accounts.campaign;\n        require!(clock::Clock::get()?.unix_timestamp <= campaign.deadline, CrowdfundingError::CampaignEnded);\n        campaign.collected_amount = campaign.collected_amount.checked_add(amount).ok_or(CrowdfundingError::Overflow)?;\n        Ok(())\n    }\n\n    pub fn withdraw(ctx: Context<Withdraw>, amount: u64) -> Result<()> {\n        let campaign = &mut ctx.accounts.campaign;\n        require!(clock::Clock::get()?.unix_timestamp > campaign.deadline, CrowdfundingError::CampaignActive);\n        require!(campaign.collected_amount >= campaign.target_amount, CrowdfundingError::TargetNotMet);\n        require!(ctx.accounts.recipient.key() == ctx.accounts.authority.key(), CrowdfundingError::Unauthorized);\n        campaign.collected_amount = campaign.collected_amount.checked_sub(amount).ok_or(CrowdfundingError::Underflow)?;\n        **ctx.accounts.recipient.to_account_info().try_borrow_mut_lamports()? += amount;\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 8 + 8 + 8)]\n    pub campaign: Account<'info, Campaign>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Donate<'info> {\n    #[account(mut)]\n    pub campaign: Account<'info, Campaign>,\n    pub contributor: Signer<'info>,\n}\n\n#[derive(Accounts)]\npub struct Withdraw<'info> {\n    #[account(mut)]\n    pub campaign: Account<'info, Campaign>,\n    #[account(mut)]\n    pub recipient: AccountInfo<'info>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n}\n\n#[account]\npub struct Campaign {\n    pub target_amount: u64,\n    pub collected_amount: u64,\n    pub deadline: i64,\n}\n\n#[error_code]\npub enum CrowdfundingError {\n    #[msg(\"Campaign has ended\")]\n    CampaignEnded,\n    #[msg(\"Target amount not met\")]\n    TargetNotMet,\n    #[msg(\"Campaign is still active\")]\n    CampaignActive,\n    #[msg(\"Unauthorized access\")]\n    Unauthorized,\n    #[msg(\"Overflow occurred\")]\n    Overflow,\n    #[msg(\"Underflow occurred\")]\n    Underflow,\n}",
        "vulnerabilities": []
    },    
    {   
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\nmod vulnerable_vault {\n    use super::*;\n\n    pub fn initialize_vault(ctx: Context<InitializeVault>, vault_seed: u64) -> Result<()> {\n        let vault = &mut ctx.accounts.vault;\n        vault.authority = ctx.accounts.authority.key();\n        vault.token = ctx.accounts.token.key();\n        vault.total_shares = 0;\n        vault.total_amount = 0;\n        vault.seed = vault_seed;\n        Ok(())\n    }\n\n    pub fn deposit(ctx: Context<Deposit>, amount: u64) -> Result<()> {\n        let vault = &mut ctx.accounts.vault;\n        let shares = if vault.total_shares == 0 {\n            amount\n        } else {\n            amount * vault.total_shares / vault.total_amount\n        };\n\n        vault.total_shares += shares;\n        vault.total_amount += amount;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_account.to_account_info(),\n                    to: ctx.accounts.vault_token_account.to_account_info(),\n                    authority: ctx.accounts.user.to_account_info(),\n                },\n            ),\n            amount,\n        )?;\n\n        Ok(())\n    }\n\n    pub fn withdraw(ctx: Context<Withdraw>, shares: u64) -> Result<()> {\n        let vault = &mut ctx.accounts.vault;\n        let amount = shares * vault.total_amount / vault.total_shares;\n\n        vault.total_shares -= shares;\n        vault.total_amount -= amount;\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.vault_token_account.to_account_info(),\n                    to: ctx.accounts.user_token_account.to_account_info(),\n                    authority: vault.to_account_info(),\n                },\n                &[&[b\"vault\", &vault.seed.to_le_bytes(), &[*ctx.bumps.get(\"vault\").unwrap()]]],\n            ),\n            amount,\n        )?;\n\n        Ok(())\n    }\n\n    pub fn flash_loan(ctx: Context<FlashLoan>, amount: u64) -> Result<()> {\n        let vault = &ctx.accounts.vault;\n        require!(amount <= vault.total_amount, VaultError::InsufficientFunds);\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.vault_token_account.to_account_info(),\n                    to: ctx.accounts.borrower_token_account.to_account_info(),\n                    authority: vault.to_account_info(),\n                },\n                &[&[b\"vault\", &vault.seed.to_le_bytes(), &[*ctx.bumps.get(\"vault\").unwrap()]]],\n            ),\n            amount,\n        )?;\n\n        // Assume some external function call here\n        // ...\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.borrower_token_account.to_account_info(),\n                    to: ctx.accounts.vault_token_account.to_account_info(),\n                    authority: ctx.accounts.borrower.to_account_info(),\n                },\n            ),\n            amount,\n        )?;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct InitializeVault<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 32 + 8 + 8 + 8, seeds = [b\"vault\", vault_seed.to_le_bytes().as_ref()], bump)]\n    pub vault: Account<'info, Vault>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub token: Account<'info, Token>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Deposit<'info> {\n    #[account(mut)]\n    pub vault: Account<'info, Vault>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub vault_token_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct Withdraw<'info> {\n    #[account(mut)]\n    pub vault: Account<'info, Vault>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub vault_token_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct FlashLoan<'info> {\n    #[account(mut)]\n    pub vault: Account<'info, Vault>,\n    #[account(mut)]\n    pub vault_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub borrower_token_account: Account<'info, TokenAccount>,\n    pub borrower: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct Vault {\n    pub authority: Pubkey,\n    pub token: Pubkey,\n    pub total_shares: u64,\n    pub total_amount: u64,\n    pub seed: u64,\n}\n\n#[error_code]\npub enum VaultError {\n    #[msg(\"Insufficient funds in the vault\")]\n    InsufficientFunds,\n}",
        "vulnerabilities": [
          "Lack of reentrancy protection in flash loan function",
          "Potential for precision loss in share calculations",
          "Missing access control for flash loan function"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\nmod vulnerable_nft_marketplace {\n    use super::*;\n\n    pub fn initialize_marketplace(ctx: Context<InitializeMarketplace>, marketplace_fee: u64) -> Result<()> {\n        let marketplace = &mut ctx.accounts.marketplace;\n        marketplace.authority = ctx.accounts.authority.key();\n        marketplace.fee = marketplace_fee;\n        marketplace.total_volume = 0;\n        Ok(())\n    }\n\n    pub fn list_nft(ctx: Context<ListNFT>, price: u64) -> Result<()> {\n        let listing = &mut ctx.accounts.listing;\n        listing.seller = ctx.accounts.seller.key();\n        listing.nft_mint = ctx.accounts.nft_mint.key();\n        listing.price = price;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.seller_nft_account.to_account_info(),\n                    to: ctx.accounts.escrow_nft_account.to_account_info(),\n                    authority: ctx.accounts.seller.to_account_info(),\n                },\n            ),\n            1,\n        )?;\n\n        Ok(())\n    }\n\n    pub fn buy_nft(ctx: Context<BuyNFT>) -> Result<()> {\n        let marketplace = &mut ctx.accounts.marketplace;\n        let listing = &ctx.accounts.listing;\n\n        let fee_amount = listing.price * marketplace.fee / 10000;\n        let seller_amount = listing.price - fee_amount;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.buyer_token_account.to_account_info(),\n                    to: ctx.accounts.seller_token_account.to_account_info(),\n                    authority: ctx.accounts.buyer.to_account_info(),\n                },\n            ),\n            seller_amount,\n        )?;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.buyer_token_account.to_account_info(),\n                    to: ctx.accounts.marketplace_token_account.to_account_info(),\n                    authority: ctx.accounts.buyer.to_account_info(),\n                },\n            ),\n            fee_amount,\n        )?;\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.escrow_nft_account.to_account_info(),\n                    to: ctx.accounts.buyer_nft_account.to_account_info(),\n                    authority: marketplace.to_account_info(),\n                },\n                &[&[b\"marketplace\", &[*ctx.bumps.get(\"marketplace\").unwrap()]]],\n            ),\n            1,\n        )?;\n\n        marketplace.total_volume += listing.price;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct InitializeMarketplace<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 8 + 8)]\n    pub marketplace: Account<'info, Marketplace>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct ListNFT<'info> {\n    #[account(mut)]\n    pub marketplace: Account<'info, Marketplace>,\n    #[account(init, payer = seller, space = 8 + 32 + 32 + 8)]\n    pub listing: Account<'info, NFTListing>,\n    #[account(mut)]\n    pub seller: Signer<'info>,\n    pub nft_mint: Account<'info, Token>,\n    #[account(mut)]\n    pub seller_nft_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub escrow_nft_account: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct BuyNFT<'info> {\n    #[account(mut)]\n    pub marketplace: Account<'info, Marketplace>,\n    #[account(mut, close = seller)]\n    pub listing: Account<'info, NFTListing>,\n    #[account(mut)]\n    pub buyer: Signer<'info>,\n    /// CHECK: This is not dangerous because we don't read or write from this account\n    pub seller: AccountInfo<'info>,\n    #[account(mut)]\n    pub buyer_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub seller_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub marketplace_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub escrow_nft_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub buyer_nft_account: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct Marketplace {\n    pub authority: Pubkey,\n    pub fee: u64,\n    pub total_volume: u64,\n}\n\n#[account]\npub struct NFTListing {\n    pub seller: Pubkey,\n    pub nft_mint: Pubkey,\n    pub price: u64,\n}",
        "vulnerabilities": [
            "Unrestricted listing cancellation, allowing unauthorized removal of valid marketplace offerings",
            "Missing validation for null address in token transfers, potentially leading to irretrievable token loss",
            "Unprotected arithmetic in fee calculations, risking integer overflow and incorrect fee assessments"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\nmod vulnerable_governance {\n    use super::*;\n\n    pub fn create_proposal(ctx: Context<CreateProposal>, description: String, voting_period: i64) -> Result<()> {\n        let proposal = &mut ctx.accounts.proposal;\n        proposal.creator = ctx.accounts.creator.key();\n        proposal.description = description;\n        proposal.yes_votes = 0;\n        proposal.no_votes = 0;\n        proposal.start_time = Clock::get()?.unix_timestamp;\n        proposal.end_time = proposal.start_time + voting_period;\n        proposal.executed = false;\n        Ok(())\n    }\n\n    pub fn cast_vote(ctx: Context<CastVote>, vote: bool) -> Result<()> {\n        let proposal = &mut ctx.accounts.proposal;\n        let voter = &mut ctx.accounts.voter;\n\n        require!(!proposal.executed, GovernanceError::ProposalAlreadyExecuted);\n        require!(Clock::get()?.unix_timestamp <= proposal.end_time, GovernanceError::VotingPeriodEnded);\n\n        let voting_power = ctx.accounts.voter_token_account.amount;\n\n        if vote {\n            proposal.yes_votes += voting_power;\n        } else {\n            proposal.no_votes += voting_power;\n        }\n\n        voter.has_voted = true;\n\n        Ok(())\n    }\n\n    pub fn execute_proposal(ctx: Context<ExecuteProposal>) -> Result<()> {\n        let proposal = &mut ctx.accounts.proposal;\n\n        require!(!proposal.executed, GovernanceError::ProposalAlreadyExecuted);\n        require!(Clock::get()?.unix_timestamp > proposal.end_time, GovernanceError::VotingPeriodNotEnded);\n\n        if proposal.yes_votes > proposal.no_votes {\n            // Execute proposal logic here\n            // ...\n\n            proposal.executed = true;\n        } else {\n            return Err(GovernanceError::ProposalRejected.into());\n        }\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct CreateProposal<'info> {\n    #[account(init, payer = creator, space = 8 + 32 + 200 + 8 + 8 + 8 + 8 + 1)]\n    pub proposal: Account<'info, Proposal>,\n    #[account(mut)]\n    pub creator: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct CastVote<'info> {\n    #[account(mut)]\n    pub proposal: Account<'info, Proposal>,\n    #[account(mut)]\n    pub voter: Account<'info, Voter>,\n    #[account(mut)]\n    pub voter_token_account: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct ExecuteProposal<'info> {\n    #[account(mut)]\n    pub proposal: Account<'info, Proposal>,\n    pub executor: Signer<'info>,\n}\n\n#[account]\npub struct Proposal {\n    pub creator: Pubkey,\n    pub description: String,\n    pub yes_votes: u64,\n    pub no_votes: u64,\n    pub start_time: i64,\n    pub end_time: i64,\n    pub executed: bool,\n}\n\n#[account]\npub struct Voter {\n    pub has_voted: bool,\n}\n\n#[error_code]\npub enum GovernanceError {\n    #[msg(\"Proposal has already been executed\")]\n    ProposalAlreadyExecuted,\n    #[msg(\"Voting period has ended\")]\n    VotingPeriodEnded,\n    #[msg(\"Voting period has not ended yet\")]\n    VotingPeriodNotEnded,\n    #[msg(\"Proposal was rejected\")]\n    ProposalRejected,\n}",
        "vulnerabilities": [
            "Absence of mechanisms to prevent multiple votes per user, compromising governance integrity",
            "Missing minimum participation threshold for proposal execution, risking unrepresentative decision implementation",
            "Unrestricted access to proposal execution function, allowing unauthorized governance actions"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\nmod vulnerable_lending {\n    use super::*;\n\n    pub fn initialize_pool(ctx: Context<InitializePool>, pool_seed: u64) -> Result<()> {\n        let pool = &mut ctx.accounts.pool;\n        pool.authority = ctx.accounts.authority.key();\n        pool.lending_token = ctx.accounts.lending_token.key();\n        pool.collateral_token = ctx.accounts.collateral_token.key();\n        pool.seed = pool_seed;\n        pool.total_borrowed = 0;\n        pool.total_collateral = 0;\n        Ok(())\n    }\n\n    pub fn deposit(ctx: Context<Deposit>, amount: u64) -> Result<()> {\n        let pool = &mut ctx.accounts.pool;\n        pool.total_collateral = pool.total_collateral.checked_add(amount).unwrap();\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_collateral.to_account_info(),\n                    to: ctx.accounts.pool_collateral.to_account_info(),\n                    authority: ctx.accounts.user.to_account_info(),\n                },\n            ),\n            amount,\n        )?;\n\n        Ok(())\n    }\n\n    pub fn borrow(ctx: Context<Borrow>, amount: u64) -> Result<()> {\n        let pool = &mut ctx.accounts.pool;\n        let collateral_amount = ctx.accounts.user_collateral.amount;\n        let borrow_limit = collateral_amount.checked_mul(2).unwrap();\n\n        require!(amount <= borrow_limit, LendingError::BorrowLimitExceeded);\n\n        pool.total_borrowed = pool.total_borrowed.checked_add(amount).unwrap();\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.pool_lending.to_account_info(),\n                    to: ctx.accounts.user_lending.to_account_info(),\n                    authority: pool.to_account_info(),\n                },\n                &[&[b\"pool\", &pool.seed.to_le_bytes(), &[ctx.bumps.pool]]],\n            ),\n            amount,\n        )?;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct InitializePool<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 32 + 32 + 8 + 8 + 8, seeds = [b\"pool\", &pool_seed.to_le_bytes()], bump)]\n    pub pool: Account<'info, LendingPool>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub lending_token: Account<'info, TokenAccount>,\n    pub collateral_token: Account<'info, TokenAccount>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Deposit<'info> {\n    #[account(mut)]\n    pub pool: Account<'info, LendingPool>,\n    #[account(mut)]\n    pub user_collateral: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_collateral: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct Borrow<'info> {\n    #[account(mut, seeds = [b\"pool\", &pool.seed.to_le_bytes()], bump)]\n    pub pool: Account<'info, LendingPool>,\n    #[account(mut)]\n    pub user_lending: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_lending: Account<'info, TokenAccount>,\n    pub user_collateral: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct LendingPool {\n    pub authority: Pubkey,\n    pub lending_token: Pubkey,\n    pub collateral_token: Pubkey,\n    pub seed: u64,\n    pub total_borrowed: u64,\n    pub total_collateral: u64,\n}\n\n#[error_code]\npub enum LendingError {\n    #[msg(\"Borrow amount exceeds allowed limit\")]\n    BorrowLimitExceeded,\n}",
        "vulnerabilities": [
            "Unrestricted pool initialization, allowing unauthorized setting or alteration of crucial pool parameters",
            "Lack of validation for zero-value transactions, potentially skewing pool metrics or wasting gas",
            "Unprotected arithmetic in borrow limit calculations, risking integer overflow and incorrect lending caps"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\nmod vulnerable_staking {\n    use super::*;\n\n    pub fn initialize_pool(ctx: Context<InitializePool>, pool_seed: u64, reward_rate: u64) -> Result<()> {\n        let pool = &mut ctx.accounts.pool;\n        pool.authority = ctx.accounts.authority.key();\n        pool.staking_token = ctx.accounts.staking_token.key();\n        pool.reward_token = ctx.accounts.reward_token.key();\n        pool.seed = pool_seed;\n        pool.reward_rate = reward_rate;\n        pool.last_update_time = Clock::get()?.unix_timestamp;\n        pool.reward_per_token_stored = 0;\n        pool.total_staked = 0;\n        Ok(())\n    }\n\n    pub fn stake(ctx: Context<Stake>, amount: u64) -> Result<()> {\n        let pool = &mut ctx.accounts.pool;\n        let user = &mut ctx.accounts.user_stake_info;\n\n        update_reward(pool, user)?;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token.to_account_info(),\n                    to: ctx.accounts.pool_token.to_account_info(),\n                    authority: ctx.accounts.user.to_account_info(),\n                },\n            ),\n            amount,\n        )?;\n\n        pool.total_staked += amount;\n        user.balance += amount;\n\n        Ok(())\n    }\n\n    pub fn unstake(ctx: Context<Unstake>, amount: u64) -> Result<()> {\n        let pool = &mut ctx.accounts.pool;\n        let user = &mut ctx.accounts.user_stake_info;\n\n        require!(user.balance >= amount, StakingError::InsufficientBalance);\n\n        update_reward(pool, user)?;\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.pool_token.to_account_info(),\n                    to: ctx.accounts.user_token.to_account_info(),\n                    authority: pool.to_account_info(),\n                },\n                &[&[b\"pool\", &pool.seed.to_le_bytes(), &[ctx.bumps.pool]]],\n            ),\n            amount,\n        )?;\n\n        pool.total_staked -= amount;\n        user.balance -= amount;\n\n        Ok(())\n    }\n\n    pub fn claim_reward(ctx: Context<ClaimReward>) -> Result<()> {\n        let pool = &mut ctx.accounts.pool;\n        let user = &mut ctx.accounts.user_stake_info;\n\n        update_reward(pool, user)?;\n\n        let reward = user.reward_earned;\n        user.reward_earned = 0;\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.pool_reward.to_account_info(),\n                    to: ctx.accounts.user_reward.to_account_info(),\n                    authority: pool.to_account_info(),\n                },\n                &[&[b\"pool\", &pool.seed.to_le_bytes(), &[ctx.bumps.pool]]],\n            ),\n            reward,\n        )?;\n\n        Ok(())\n    }\n}\n\nfn update_reward(pool: &mut Account<StakingPool>, user: &mut Account<UserStakeInfo>) -> Result<()> {\n    let current_time = Clock::get()?.unix_timestamp;\n    let time_delta = current_time - pool.last_update_time;\n\n    if pool.total_staked > 0 {\n        pool.reward_per_token_stored += (pool.reward_rate as u128 * time_delta as u128 * 1e9 as u128 / pool.total_staked as u128) as u64;\n    }\n\n    user.reward_earned += (user.balance as u128 * (pool.reward_per_token_stored - user.reward_per_token_paid) as u128 / 1e9 as u128) as u64;\n    user.reward_per_token_paid = pool.reward_per_token_stored;\n    pool.last_update_time = current_time;\n\n    Ok(())\n}\n\n#[derive(Accounts)]\npub struct InitializePool<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 32 + 32 + 8 + 8 + 8 + 8 + 8, seeds = [b\"pool\", &pool_seed.to_le_bytes()], bump)]\n    pub pool: Account<'info, StakingPool>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub staking_token: Account<'info, TokenAccount>,\n    pub reward_token: Account<'info, TokenAccount>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Stake<'info> {\n    #[account(mut)]\n    pub pool: Account<'info, StakingPool>,\n    #[account(mut)]\n    pub user_token: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub user_stake_info: Account<'info, UserStakeInfo>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct Unstake<'info> {\n    #[account(mut, seeds = [b\"pool\", &pool.seed.to_le_bytes()], bump)]\n    pub pool: Account<'info, StakingPool>,\n    #[account(mut)]\n    pub user_token: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub user_stake_info: Account<'info, UserStakeInfo>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct ClaimReward<'info> {\n    #[account(mut, seeds = [b\"pool\", &pool.seed.to_le_bytes()], bump)]\n    pub pool: Account<'info, StakingPool>,\n    #[account(mut)]\n    pub user_reward: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_reward: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub user_stake_info: Account<'info, UserStakeInfo>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct StakingPool {\n    pub authority: Pubkey,\n    pub staking_token: Pubkey,\n    pub reward_token: Pubkey,\n    pub seed: u64,\n    pub reward_rate: u64,\n    pub last_update_time: i64,\n    pub reward_per_token_stored: u64,\n    pub total_staked: u64,\n}\n\n#[account]\npub struct UserStakeInfo {\n    pub user: Pubkey,\n    pub balance: u64,\n    pub reward_earned: u64,\n    pub reward_per_token_paid: u64,\n}\n\n#[error_code]\npub enum StakingError {\n    #[msg(\"Insufficient balance for unstaking\")]\n    InsufficientBalance,\n}",
        "vulnerabilities": [
            "Use of integer division in reward calculations, leading to potential loss of precision and unfair reward distribution",
            "Unrestricted access to staking pool initialization, allowing unauthorized setting of crucial parameters",
            "Missing validation for zero-value stake/unstake operations, potentially skewing pool metrics or wasting gas"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\npub mod vulnerable_donation {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {\n        let donation_pool = &mut ctx.accounts.donation_pool;\n        donation_pool.authority = ctx.accounts.authority.key();\n        donation_pool.total_donations = 0;\n        Ok(())\n    }\n\n    pub fn donate(ctx: Context<Donate>, amount: u64) -> Result<()> {\n        let donation_pool = &mut ctx.accounts.donation_pool;\n        let user = &ctx.accounts.user;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_account.to_account_info(),\n                    to: ctx.accounts.pool_token_account.to_account_info(),\n                    authority: user.to_account_info(),\n                },\n            ),\n            amount,\n        )?;\n\n        donation_pool.total_donations += amount;\n        donation_pool.donations.insert(user.key(), amount);\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 8 + 64)]\n    pub donation_pool: Account<'info, DonationPool>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Donate<'info> {\n    #[account(mut)]\n    pub donation_pool: Account<'info, DonationPool>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct DonationPool {\n    pub authority: Pubkey,\n    pub total_donations: u64,\n    pub donations: std::collections::HashMap<Pubkey, u64>,\n}",
        "vulnerabilities": [
            "Lack of donor authentication, potentially enabling money laundering or unauthorized fund sources",
            "Unprotected arithmetic in donation processing, risking integer overflow and incorrect donation tracking",
            "Absence of donation reversal mechanism, potentially trapping funds in case of errors or disputes"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\npub mod vulnerable_token_sale {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, token_price: u64) -> Result<()> {\n        let token_sale = &mut ctx.accounts.token_sale;\n        token_sale.authority = ctx.accounts.authority.key();\n        token_sale.token_price = token_price;\n        Ok(())\n    }\n\n    pub fn buy_tokens(ctx: Context<BuyTokens>, amount: u64) -> Result<()> {\n        let token_sale = &mut ctx.accounts.token_sale;\n        let user = &ctx.accounts.user;\n\n        let total_cost = amount * token_sale.token_price;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_account.to_account_info(),\n                    to: ctx.accounts.sale_token_account.to_account_info(),\n                    authority: user.to_account_info(),\n                },\n            ),\n            total_cost,\n        )?;\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.sale_token_account.to_account_info(),\n                    to: ctx.accounts.user_token_account.to_account_info(),\n                    authority: token_sale.to_account_info(),\n                },\n                &[&[&token_sale.authority.to_bytes(), &[*ctx.bumps.get(\"token_sale\").unwrap()]]],\n            ),\n            amount,\n        )?;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 8)]\n    pub token_sale: Account<'info, TokenSale>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct BuyTokens<'info> {\n    #[account(mut)]\n    pub token_sale: Account<'info, TokenSale>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub sale_token_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct TokenSale {\n    pub authority: Pubkey,\n    pub token_price: u64,\n}",
        "vulnerabilities": [
            "Static token pricing model, potentially leading to unfair valuations in changing market conditions",
            "Absence of purchase limits, risking token supply concentration or rapid depletion",
            "Missing validation of sale period, potentially allowing transactions outside intended timeframes"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\npub mod vulnerable_insurance {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, premium_rate: u64) -> Result<()> {\n        let insurance_pool = &mut ctx.accounts.insurance_pool;\n        insurance_pool.authority = ctx.accounts.authority.key();\n        insurance_pool.premium_rate = premium_rate;\n        Ok(())\n    }\n\n    pub fn buy_insurance(ctx: Context<BuyInsurance>, amount: u64) -> Result<()> {\n        let insurance_pool = &mut ctx.accounts.insurance_pool;\n        let user = &ctx.accounts.user;\n\n        let premium = amount * insurance_pool.premium_rate / 100;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_account.to_account_info(),\n                    to: ctx.accounts.pool_token_account.to_account_info(),\n                    authority: user.to_account_info(),\n                },\n            ),\n            premium,\n        )?;\n\n        insurance_pool.total_premiums += premium;\n        insurance_pool.user_premiums.insert(user.key(), premium);\n\n        Ok(())\n    }\n\n    pub fn claim_insurance(ctx: Context<ClaimInsurance>, claim_amount: u64) -> Result<()> {\n        let insurance_pool = &ctx.accounts.insurance_pool;\n        let user = &ctx.accounts.user;\n\n        require!(insurance_pool.total_premiums >= claim_amount, ErrorCode::InsufficientFunds);\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.pool_token_account.to_account_info(),\n                    to: ctx.accounts.user_token_account.to_account_info(),\n                    authority: insurance_pool.to_account_info(),\n                },\n                &[&[&insurance_pool.authority.to_bytes(), &[*ctx.bumps.get(\"insurance_pool\").unwrap()]]],\n            ),\n            claim_amount,\n        )?;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 8 + 64 + 64)]\n    pub insurance_pool: Account<'info, InsurancePool>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct BuyInsurance<'info> {\n    #[account(mut)]\n    pub insurance_pool: Account<'info, InsurancePool>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct ClaimInsurance<'info> {\n    #[account(mut)]\n    pub insurance_pool: Account<'info, InsurancePool>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct InsurancePool {\n    pub authority: Pubkey,\n    pub premium_rate: u64,\n    pub total_premiums: u64,\n    pub user_premiums: std::collections::HashMap<Pubkey, u64>,\n}",
        "vulnerabilities": [
            "Inflexible premium calculation, potentially leading to mispriced risk in varying market conditions",
            "Insufficient validation of claim events, risking fraudulent or invalid insurance payouts",
            "Absence of risk distribution mechanism, potentially jeopardizing protocol solvency in high-payout scenarios"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\npub mod vulnerable_escrow {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, duration: u64) -> Result<()> {\n        let escrow = &mut ctx.accounts.escrow;\n        escrow.authority = ctx.accounts.authority.key();\n        escrow.duration = duration;\n        Ok(())\n    }\n\n    pub fn deposit(ctx: Context<Deposit>, amount: u64) -> Result<()> {\n        let escrow = &mut ctx.accounts.escrow;\n        let user = &ctx.accounts.user;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_account.to_account_info(),\n                    to: ctx.accounts.escrow_token_account.to_account_info(),\n                    authority: user.to_account_info(),\n                },\n            ),\n            amount,\n        )?;\n\n        escrow.total_deposits += amount;\n        escrow.deposits.insert(user.key(), amount);\n\n        Ok(())\n    }\n\n    pub fn withdraw(ctx: Context<Withdraw>, amount: u64) -> Result<()> {\n        let escrow = &ctx.accounts.escrow;\n        let user = &ctx.accounts.user;\n\n        require!(escrow.total_deposits >= amount, ErrorCode::InsufficientFunds);\n        require!(escrow.duration <= Clock::get().unwrap().unix_timestamp as u64, ErrorCode::EscrowNotMatured);\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.escrow_token_account.to_account_info(),\n                    to: ctx.accounts.user_token_account.to_account_info(),\n                    authority: escrow.to_account_info(),\n                },\n                &[&[&escrow.authority.to_bytes(), &[*ctx.bumps.get(\"escrow\").unwrap()]]],\n            ),\n            amount,\n        )?;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 8 + 64 + 64)]\n    pub escrow: Account<'info, Escrow>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Deposit<'info> {\n    #[account(mut)]\n    pub escrow: Account<'info, Escrow>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub escrow_token_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct Withdraw<'info> {\n    #[account(mut)]\n    pub escrow: Account<'info, Escrow>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub escrow_token_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct Escrow {\n    pub authority: Pubkey,\n    pub duration: u64,\n    pub total_deposits: u64,\n    pub deposits: std::collections::HashMap<Pubkey, u64>,\n}",    
        "vulnerabilities": [
            "Rigid vesting schedule, lacking adaptability to changing project or market needs",
            "Absence of partial withdrawal functionality, potentially locking funds unnecessarily",
            "Limited to single beneficiary, restricting complex vesting arrangements or shared allocations"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\npub mod vulnerable_staking {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, reward_rate: u64) -> Result<()> {\n        let staking_pool = &mut ctx.accounts.staking_pool;\n        staking_pool.authority = ctx.accounts.authority.key();\n        staking_pool.reward_rate = reward_rate;\n        Ok(())\n    }\n\n    pub fn stake(ctx: Context<Stake>, amount: u64) -> Result<()> {\n        let staking_pool = &mut ctx.accounts.staking_pool;\n        let user = &ctx.accounts.user;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_account.to_account_info(),\n                    to: ctx.accounts.pool_token_account.to_account_info(),\n                    authority: user.to_account_info(),\n                },\n            ),\n            amount,\n        )?;\n\n        staking_pool.total_staked += amount;\n        staking_pool.user_stakes.insert(user.key(), amount);\n\n        Ok(())\n    }\n\n    pub fn claim_rewards(ctx: Context<ClaimRewards>) -> Result<()> {\n        let staking_pool = &ctx.accounts.staking_pool;\n        let user = &ctx.accounts.user;\n\n        let reward = staking_pool.reward_rate * staking_pool.user_stakes[&user.key()];\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.pool_token_account.to_account_info(),\n                    to: ctx.accounts.user_token_account.to_account_info(),\n                    authority: staking_pool.to_account_info(),\n                },\n                &[&[&staking_pool.authority.to_bytes(), &[*ctx.bumps.get(\"staking_pool\").unwrap()]]],\n            ),\n            reward,\n        )?;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 8 + 64 + 64)]\n    pub staking_pool: Account<'info, StakingPool>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Stake<'info> {\n    #[account(mut)]\n    pub staking_pool: Account<'info, StakingPool>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct ClaimRewards<'info> {\n    #[account(mut)]\n    pub staking_pool: Account<'info, StakingPool>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct StakingPool {\n    pub authority: Pubkey,\n    pub reward_rate: u64,\n    pub total_staked: u64,\n    pub user_stakes: std::collections::HashMap<Pubkey, u64>,\n}",
        "vulnerabilities": [
            "Non-adaptive reward structure, potentially leading to economic imbalances in changing market conditions",
            "Missing functionality for stake removal, potentially locking user funds indefinitely",
            "Absence of time-based staking incentives, potentially encouraging short-term over long-term participation"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\npub mod vulnerable_subscription {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, subscription_fee: u64) -> Result<()> {\n        let subscription_service = &mut ctx.accounts.subscription_service;\n        subscription_service.authority = ctx.accounts.authority.key();\n        subscription_service.subscription_fee = subscription_fee;\n        Ok(())\n    }\n\n    pub fn subscribe(ctx: Context<Subscribe>) -> Result<()> {\n        let subscription_service = &mut ctx.accounts.subscription_service;\n        let user = &ctx.accounts.user;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_account.to_account_info(),\n                    to: ctx.accounts.service_token_account.to_account_info(),\n                    authority: user.to_account_info(),\n                },\n            ),\n            subscription_service.subscription_fee,\n        )?;\n\n        subscription_service.subscribers.insert(user.key(), Clock::get().unwrap().unix_timestamp as u64);\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 8 + 64)]\n    pub subscription_service: Account<'info, SubscriptionService>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Subscribe<'info> {\n    #[account(mut)]\n    pub subscription_service: Account<'info, SubscriptionService>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub service_token_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct SubscriptionService {\n    pub authority: Pubkey,\n    pub subscription_fee: u64,\n    pub subscribers: std::collections::HashMap<Pubkey, u64>,\n}",
        "vulnerabilities": [
            "Inflexible pricing model, potentially leading to under or overvalued subscriptions over time",
            "Lack of automated subscription extension, risking service interruptions for users",
            "Absence of partial refund mechanism, potentially deterring user participation or causing fund lock-ups"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\npub mod vulnerable_voting {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, quorum: u64) -> Result<()> {\n        let voting_system = &mut ctx.accounts.voting_system;\n        voting_system.authority = ctx.accounts.authority.key();\n        voting_system.quorum = quorum;\n        Ok(())\n    }\n\n    pub fn create_proposal(ctx: Context<CreateProposal>, description: String) -> Result<()> {\n        let proposal = &mut ctx.accounts.proposal;\n        proposal.authority = ctx.accounts.authority.key();\n        proposal.description = description;\n        proposal.votes_for = 0;\n        proposal.votes_against = 0;\n        Ok(())\n    }\n\n    pub fn vote(ctx: Context<Vote>, proposal_id: Pubkey, support: bool) -> Result<()> {\n        let proposal = &mut ctx.accounts.proposal;\n        let user = &ctx.accounts.user;\n\n        if support {\n            proposal.votes_for += 1;\n        } else {\n            proposal.votes_against += 1;\n        }\n\n        proposal.voters.insert(user.key(), support);\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 8)]\n    pub voting_system: Account<'info, VotingSystem>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct CreateProposal<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 256 + 8 + 8)]\n    pub proposal: Account<'info, Proposal>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Vote<'info> {\n    #[account(mut)]\n    pub proposal: Account<'info, Proposal>,\n    pub user: Signer<'info>,\n}\n\n#[account]\npub struct VotingSystem {\n    pub authority: Pubkey,\n    pub quorum: u64,\n}\n\n#[account]\npub struct Proposal {\n    pub authority: Pubkey,\n    pub description: String,\n    pub votes_for: u64,\n    pub votes_against: u64,\n    pub voters: std::collections::HashMap<Pubkey, bool>,\n}",
        "vulnerabilities": [
            "Missing protection against repeated voting, allowing users to unfairly influence proposal outcomes",
            "Static decision threshold, potentially leading to unrepresentative outcomes in varying participation scenarios",
            "Absence of time limits on proposals, risking implementation of outdated or irrelevant decisions"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\n\n#[program]\npub mod multisig_wallet {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, owners: Vec<Pubkey>, threshold: u64) -> Result<()> {\n        let wallet = &mut ctx.accounts.wallet;\n        require!(owners.len() > 0, WalletError::NoOwners);\n        require!(threshold > 0 && threshold <= owners.len() as u64, WalletError::InvalidThreshold);\n\n        wallet.owners = owners;\n        wallet.threshold = threshold;\n        wallet.approvals = 0;\n        wallet.is_executed = false;\n        Ok(())\n    }\n\n    pub fn submit_transaction(ctx: Context<SubmitTransaction>, destination: Pubkey, amount: u64) -> Result<()> {\n        let wallet = &mut ctx.accounts.wallet;\n        wallet.destination = destination;\n        wallet.amount = amount;\n        wallet.approvals = 0;\n        wallet.is_executed = false;\n        Ok(())\n    }\n\n    pub fn approve_transaction(ctx: Context<ApproveTransaction>) -> Result<()> {\n        let wallet = &mut ctx.accounts.wallet;\n        require!(!wallet.is_executed, WalletError::TransactionAlreadyExecuted);\n        require!(wallet.approvals < wallet.threshold, WalletError::ApprovalsExceeded);\n\n        wallet.approvals += 1;\n\n        if wallet.approvals >= wallet.threshold {\n            wallet.is_executed = true;\n            **ctx.accounts.destination.to_account_info().try_borrow_mut_lamports()? += wallet.amount;\n        }\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = creator, space = 8 + 32 * 5 + 8 + 8)]\n    pub wallet: Account<'info, Wallet>,\n    #[account(mut)]\n    pub creator: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct SubmitTransaction<'info> {\n    #[account(mut)]\n    pub wallet: Account<'info, Wallet>,\n    #[account(mut)]\n    pub owner: Signer<'info>,\n}\n\n#[derive(Accounts)]\npub struct ApproveTransaction<'info> {\n    #[account(mut)]\n    pub wallet: Account<'info, Wallet>,\n    #[account(mut)]\n    pub destination: AccountInfo<'info>,\n    #[account(mut)]\n    pub owner: Signer<'info>,\n}\n\n#[account]\npub struct Wallet {\n    pub owners: Vec<Pubkey>,\n    pub threshold: u64,\n    pub destination: Pubkey,\n    pub amount: u64,\n    pub approvals: u64,\n    pub is_executed: bool,\n}\n\n#[error_code]\npub enum WalletError {\n    #[msg(\"No owners provided\")]\n    NoOwners,\n    #[msg(\"Invalid threshold\")]\n    InvalidThreshold,\n    #[msg(\"Transaction has already been executed\")]\n    TransactionAlreadyExecuted,\n    #[msg(\"Approvals exceeded\")]\n    ApprovalsExceeded,\n}",
        "vulnerabilities": []
    },
    {
        "code": "use anchor_lang::prelude::*; use anchor_spl::token::{self, Token, TokenAccount, Transfer}; #[program] pub mod unsafe_flash_loan { use super::*; pub fn initialize_pool(ctx: Context<InitializePool>, fee: u64) -> Result<()> { ctx.accounts.pool.admin = ctx.accounts.admin.key(); ctx.accounts.pool.fee = fee; Ok(()) } pub fn deposit(ctx: Context<Deposit>, amount: u64) -> Result<()> { token::transfer(CpiContext::new(ctx.accounts.token_program.to_account_info(), Transfer { from: ctx.accounts.user_token_account.to_account_info(), to: ctx.accounts.pool_token_account.to_account_info(), authority: ctx.accounts.user.to_account_info(), }), amount)?; ctx.accounts.pool.total_liquidity += amount; Ok(()) } pub fn flash_loan(ctx: Context<FlashLoan>, amount: u64) -> Result<()> { require!(amount <= ctx.accounts.pool_token_account.amount, FlashLoanError::InsufficientLiquidity); token::transfer(CpiContext::new_with_signer(ctx.accounts.token_program.to_account_info(), Transfer { from: ctx.accounts.pool_token_account.to_account_info(), to: ctx.accounts.borrower_token_account.to_account_info(), authority: ctx.accounts.pool.to_account_info(), }, &[&[b\"pool\".as_ref(), &[ctx.accounts.pool.bump]]]), amount)?; ctx.accounts.flash_loan.amount = amount; ctx.accounts.flash_loan.fee = amount * ctx.accounts.pool.fee / 10000; Ok(()) } pub fn repay_flash_loan(ctx: Context<RepayFlashLoan>) -> Result<()> { let repayment_amount = ctx.accounts.flash_loan.amount + ctx.accounts.flash_loan.fee; token::transfer(CpiContext::new(ctx.accounts.token_program.to_account_info(), Transfer { from: ctx.accounts.borrower_token_account.to_account_info(), to: ctx.accounts.pool_token_account.to_account_info(), authority: ctx.accounts.borrower.to_account_info(), }), repayment_amount)?; Ok(()) } }",
        "vulnerabilities": [
            "Missing safeguards against flash loan abuse within transaction, potentially enabling atomic exploits",
            "Unrestricted pool initialization, allowing unauthorized setting of crucial lending parameters",
            "Absence of reentrancy guards in lending function, exposing contract to potential recursive calls and fund drainage"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*; use anchor_spl::token::{self, Token, TokenAccount, Transfer}; #[program] pub mod unsafe_options_trading { use super::*; pub fn create_option(ctx: Context<CreateOption>, strike_price: u64, expiry: i64, option_type: OptionType) -> Result<()> { ctx.accounts.option.writer = ctx.accounts.writer.key(); ctx.accounts.option.strike_price = strike_price; ctx.accounts.option.expiry = expiry; ctx.accounts.option.option_type = option_type; ctx.accounts.option.premium = 0; ctx.accounts.option.exercised = false; Ok(()) } pub fn buy_option(ctx: Context<BuyOption>, premium: u64) -> Result<()> { require!(!ctx.accounts.option.exercised, OptionsError::OptionAlreadyExercised); require!(Clock::get()?.unix_timestamp < ctx.accounts.option.expiry, OptionsError::OptionExpired); token::transfer(CpiContext::new(ctx.accounts.token_program.to_account_info(), Transfer { from: ctx.accounts.buyer_token_account.to_account_info(), to: ctx.accounts.writer_token_account.to_account_info(), authority: ctx.accounts.buyer.to_account_info(), }), premium)?; ctx.accounts.option.buyer = ctx.accounts.buyer.key(); ctx.accounts.option.premium = premium; Ok(()) } pub fn exercise_option(ctx: Context<ExerciseOption>) -> Result<()> { require!(!ctx.accounts.option.exercised, OptionsError::OptionAlreadyExercised); require!(Clock::get()?.unix_timestamp < ctx.accounts.option.expiry, OptionsError::OptionExpired); let amount = match ctx.accounts.option.option_type { OptionType::Call => ctx.accounts.option.strike_price, OptionType::Put => ctx.accounts.underlying_price.get_price()?, }; token::transfer(CpiContext::new(ctx.accounts.token_program.to_account_info(), Transfer { from: ctx.accounts.buyer_token_account.to_account_info(), to: ctx.accounts.writer_token_account.to_account_info(), authority: ctx.accounts.buyer.to_account_info(), }), amount)?; ctx.accounts.option.exercised = true; Ok(()) } }",
        "vulnerabilities": [
            "Insufficient parameter validation in option creation, potentially leading to mispriced or invalid options",
            "Lack of ownership verification in option exercise, risking unauthorized access to option benefits",
            "Absence of price protection in exercise function, exposing users to potential value loss in volatile markets"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*; use anchor_spl::token::{self, Token, TokenAccount, Transfer}; #[program] pub mod unsafe_prediction_market { use super::*; pub fn create_market(ctx: Context<CreateMarket>, description: String, resolution_time: i64) -> Result<()> { ctx.accounts.market.description = description; ctx.accounts.market.resolution_time = resolution_time; ctx.accounts.market.total_yes_tokens = 0; ctx.accounts.market.total_no_tokens = 0; ctx.accounts.market.resolved = false; Ok(()) } pub fn buy_prediction(ctx: Context<BuyPrediction>, amount: u64, prediction: bool) -> Result<()> { require!(!ctx.accounts.market.resolved, PredictionError::MarketResolved); require!(Clock::get()?.unix_timestamp < ctx.accounts.market.resolution_time, PredictionError::MarketClosed); token::transfer(CpiContext::new(ctx.accounts.token_program.to_account_info(), Transfer { from: ctx.accounts.buyer_token_account.to_account_info(), to: ctx.accounts.market_token_account.to_account_info(), authority: ctx.accounts.buyer.to_account_info(), }), amount)?; if prediction { ctx.accounts.market.total_yes_tokens += amount; token::mint_to(CpiContext::new_with_signer(ctx.accounts.token_program.to_account_info(), MintTo { mint: ctx.accounts.yes_token_mint.to_account_info(), to: ctx.accounts.buyer_yes_token_account.to_account_info(), authority: ctx.accounts.market.to_account_info(), }, &[&[b\"market\".as_ref(), &[ctx.accounts.market.bump]]]), amount)?; } else { ctx.accounts.market.total_no_tokens += amount; token::mint_to(CpiContext::new_with_signer(ctx.accounts.token_program.to_account_info(), MintTo { mint: ctx.accounts.no_token_mint.to_account_info(), to: ctx.accounts.buyer_no_token_account.to_account_info(), authority: ctx.accounts.market.to_account_info(), }, &[&[b\"market\".as_ref(), &[ctx.accounts.market.bump]]]), amount)?; } Ok(()) } pub fn resolve_market(ctx: Context<ResolveMarket>, outcome: bool) -> Result<()> { require!(!ctx.accounts.market.resolved, PredictionError::MarketAlreadyResolved); require!(Clock::get()?.unix_timestamp >= ctx.accounts.market.resolution_time, PredictionError::MarketNotClosed); ctx.accounts.market.resolved = true; ctx.accounts.market.outcome = outcome; Ok(()) } pub fn claim_winnings(ctx: Context<ClaimWinnings>) -> Result<()> { require!(ctx.accounts.market.resolved, PredictionError::MarketNotResolved); let winning_token_account = if ctx.accounts.market.outcome { &ctx.accounts.user_yes_token_account } else { &ctx.accounts.user_no_token_account }; let total_winning_tokens = if ctx.accounts.market.outcome { ctx.accounts.market.total_yes_tokens } else { ctx.accounts.market.total_no_tokens }; let user_share = winning_token_account.amount as f64 / total_winning_tokens as f64; let winnings = (user_share * ctx.accounts.market_token_account.amount as f64) as u64; token::transfer(CpiContext::new_with_signer(ctx.accounts.token_program.to_account_info(), Transfer { from: ctx.accounts.market_token_account.to_account_info(), to: ctx.accounts.user_token_account.to_account_info(), authority: ctx.accounts.market.to_account_info(), }, &[&[b\"market\".as_ref(), &[ctx.accounts.market.bump]]]), winnings)?; Ok(()) } }",
        "vulnerabilities": [
            "Lack of order batching or commit-reveal scheme, exposing users to potential value extraction through front-running",
            "Unrestricted market resolution function, allowing potential manipulation of prediction outcomes",
            "Unprotected arithmetic in winnings calculation, risking precision loss and unfair reward distribution"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*; use anchor_spl::token::{self, Token, TokenAccount, Transfer}; #[program] pub mod unsafe_nft_fractional_ownership { use super::*; pub fn fractionalize_nft(ctx: Context<FractionalizeNFT>, num_fractions: u64) -> Result<()> { token::transfer(CpiContext::new(ctx.accounts.token_program.to_account_info(), Transfer { from: ctx.accounts.owner_nft_account.to_account_info(), to: ctx.accounts.vault_nft_account.to_account_info(), authority: ctx.accounts.owner.to_account_info(), }), 1)?; token::mint_to(CpiContext::new_with_signer(ctx.accounts.token_program.to_account_info(), MintTo { mint: ctx.accounts.fraction_mint.to_account_info(), to: ctx.accounts.owner_fraction_account.to_account_info(), authority: ctx.accounts.vault.to_account_info(), }, &[&[b\"vault\".as_ref(), &[ctx.accounts.vault.bump]]]), num_fractions)?; ctx.accounts.vault.nft_mint = ctx.accounts.nft_mint.key(); ctx.accounts.vault.fraction_mint = ctx.accounts.fraction_mint.key(); ctx.accounts.vault.num_fractions = num_fractions; Ok(()) } pub fn buy_fraction(ctx: Context<BuyFraction>, amount: u64) -> Result<()> { let price_per_fraction = ctx.accounts.vault.price_per_fraction; let total_price = price_per_fraction * amount; token::transfer(CpiContext::new(ctx.accounts.token_program.to_account_info(), Transfer { from: ctx.accounts.buyer_token_account.to_account_info(), to: ctx.accounts.seller_token_account.to_account_info(), authority: ctx.accounts.buyer.to_account_info(), }), total_price)?; token::transfer(CpiContext::new(ctx.accounts.token_program.to_account_info(), Transfer { from: ctx.accounts.seller_fraction_account.to_account_info(), to: ctx.accounts.buyer_fraction_account.to_account_info(), authority: ctx.accounts.seller.to_account_info(), }), amount)?; Ok(()) } pub fn redeem_nft(ctx: Context<RedeemNFT>) -> Result<()> { require!(ctx.accounts.redeemer_fraction_account.amount == ctx.accounts.vault.num_fractions, NFTError::InsufficientFractions); token::burn(CpiContext::new(ctx.accounts.token_program.to_account_info(), Burn { mint: ctx.accounts.fraction_mint.to_account_info(), from: ctx.accounts.redeemer_fraction_account.to_account_info(), authority: ctx.accounts.redeemer.to_account_info(), }), ctx.accounts.vault.num_fractions)?; token::transfer(CpiContext::new_with_signer(ctx.accounts.token_program.to_account_info(), Transfer { from: ctx.accounts.vault_nft_account.to_account_info(), to: ctx.accounts.redeemer_nft_account.to_account_info(), authority: ctx.accounts.vault.to_account_info(), }, &[&[b\"vault\".as_ref(), &[ctx.accounts.vault.bump]]]), 1)?; Ok(()) } }",
        "vulnerabilities": [
            "Absence of market-based pricing mechanism for NFT fractions, potentially leading to mispriced shares",
            "Insufficient ownership validation in fraction purchases, risking unauthorized or invalid transactions",
            "Unrestricted NFT redemption function, allowing potential abuse of fractionalization mechanism"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*; use anchor_spl::token::{self, Token, TokenAccount, Transfer}; #[program] pub mod unsafe_dao_treasury { use super::*; pub fn initialize_treasury(ctx: Context<InitializeTreasury>) -> Result<()> { ctx.accounts.treasury.admin = ctx.accounts.admin.key(); Ok(()) } pub fn propose_spending(ctx: Context<ProposeSpending>, amount: u64, recipient: Pubkey, description: String) -> Result<()> { let proposal = &mut ctx.accounts.proposal; proposal.proposer = ctx.accounts.proposer.key(); proposal.amount = amount; proposal.recipient = recipient; proposal.description = description; proposal.yes_votes = 0; proposal.no_votes = 0; proposal.executed = false; proposal.voting_end_time = Clock::get()?.unix_timestamp + 7 * 24 * 60 * 60; // 7 days Ok(()) } pub fn cast_vote(ctx: Context<CastVote>, vote: bool) -> Result<()> { require!(Clock::get()?.unix_timestamp < ctx.accounts.proposal.voting_end_time, DAOError::VotingEnded); let voter_weight = ctx.accounts.voter_token_account.amount; if vote { ctx.accounts.proposal.yes_votes += voter_weight; } else { ctx.accounts.proposal.no_votes += voter_weight; } Ok(()) } pub fn execute_proposal(ctx: Context<ExecuteProposal>) -> Result<()> { let proposal = &mut ctx.accounts.proposal; require!(Clock::get()?.unix_timestamp >= proposal.voting_end_time, DAOError::VotingNotEnded); require!(!proposal.executed, DAOError::ProposalAlreadyExecuted); require!(proposal.yes_votes > proposal.no_votes, DAOError::ProposalRejected); token::transfer(CpiContext::new_with_signer(ctx.accounts.token_program.to_account_info(), Transfer { from: ctx.accounts.treasury_token_account.to_account_info(), to: ctx.accounts.recipient_token_account.to_account_info(), authority: ctx.accounts.treasury.to_account_info(), }, &[&[b\"treasury\".as_ref(), &[ctx.accounts.treasury.bump]]]), proposal.amount)?; proposal.executed = true; Ok(()) } }",
        "vulnerabilities": [
            "Absence of minimum voter participation requirement, risking implementation of unrepresentative decisions",
            "Missing delay period between proposal approval and execution, limiting time for community response",
            "Lack of safeguards against multiple votes per user, potentially compromising governance integrity"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\nmod vulnerable_flash_loan {\n    use super::*;\n\n    pub fn initialize_pool(ctx: Context<InitializePool>, pool_seed: u64) -> Result<()> {\n        let pool = &mut ctx.accounts.pool;\n        pool.authority = ctx.accounts.authority.key();\n        pool.token = ctx.accounts.token.key();\n        pool.seed = pool_seed;\n        pool.total_liquidity = 0;\n        Ok(())\n    }\n\n    pub fn deposit(ctx: Context<Deposit>, amount: u64) -> Result<()> {\n        let pool = &mut ctx.accounts.pool;\n        pool.total_liquidity += amount;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token.to_account_info(),\n                    to: ctx.accounts.pool_token.to_account_info(),\n                    authority: ctx.accounts.user.to_account_info(),\n                },\n            ),\n            amount,\n        )?;\n\n        Ok(())\n    }\n\n    pub fn flash_loan(ctx: Context<FlashLoan>, amount: u64) -> Result<()> {\n        let pool = &ctx.accounts.pool;\n        require!(amount <= pool.total_liquidity, FlashLoanError::InsufficientLiquidity);\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.pool_token.to_account_info(),\n                    to: ctx.accounts.borrower_token.to_account_info(),\n                    authority: pool.to_account_info(),\n                },\n                &[&[b\"pool\", &pool.seed.to_le_bytes(), &[ctx.bumps.pool]]],\n            ),\n            amount,\n        )?;\n\n        // Callback to borrower's contract\n        ctx.accounts.callback_program.invoke(\n            &ctx.accounts.callback_account.to_account_info(),\n            &[ctx.accounts.borrower.to_account_info()],\n        )?\n\n        // Repay loan\n        let fee = amount / 100; // 1% fee\n        let repay_amount = amount + fee;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.borrower_token.to_account_info(),\n                    to: ctx.accounts.pool_token.to_account_info(),\n                    authority: ctx.accounts.borrower.to_account_info(),\n                },\n            ),\n            repay_amount,\n        )?;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct InitializePool<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 32 + 8 + 8, seeds = [b\"pool\", &pool_seed.to_le_bytes()], bump)]\n    pub pool: Account<'info, FlashLoanPool>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub token: Account<'info, TokenAccount>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Deposit<'info> {\n    #[account(mut)]\n    pub pool: Account<'info, FlashLoanPool>,\n    #[account(mut)]\n    pub user_token: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct FlashLoan<'info> {\n    #[account(mut, seeds = [b\"pool\", &pool.seed.to_le_bytes()], bump)]\n    pub pool: Account<'info, FlashLoanPool>,\n    #[account(mut)]\n    pub borrower_token: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token: Account<'info, TokenAccount>,\n    pub borrower: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n    pub callback_program: AccountInfo<'info>,\n    pub callback_account: AccountInfo<'info>,\n}\n\n#[account]\npub struct FlashLoanPool {\n    pub authority: Pubkey,\n    pub token: Pubkey,\n    pub seed: u64,\n    pub total_liquidity: u64,\n}\n\n#[error_code]\npub enum FlashLoanError {\n    #[msg(\"Insufficient liquidity in the pool\")]\n    InsufficientLiquidity,\n}",
        "vulnerabilities": [
            "Unprotected state changes in lending function, exposing contract to reentrancy attacks and potential fund loss",
            "Unrestricted pool initialization, allowing unauthorized setting of crucial lending parameters",
            "Absence of validation for zero-value transactions, potentially skewing pool metrics or enabling contract manipulation"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\npub mod decentralized_exchange {\n    use super::*;\n\n    pub fn initialize_market(ctx: Context<InitializeMarket>, fee_rate: u64) -> Result<()> {\n        let market = &mut ctx.accounts.market;\n        require!(fee_rate <= 1000, DexError::InvalidFeeRate);\n        market.fee_rate = fee_rate;\n        Ok(())\n    }\n\n    pub fn place_order(ctx: Context<PlaceOrder>, amount: u64, price: u64) -> Result<()> {\n        let order_book = &mut ctx.accounts.order_book;\n        require!(amount > 0 && price > 0, DexError::InvalidOrder);\n        order_book.total_orders += 1;\n        Ok(())\n    }\n\n    pub fn cancel_order(ctx: Context<CancelOrder>, order_id: u64) -> Result<()> {\n        let order_book = &mut ctx.accounts.order_book;\n        require!(order_book.total_orders >= order_id, DexError::OrderNotFound);\n        order_book.total_orders -= 1;\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct InitializeMarket<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 8)]\n    pub market: Account<'info, Market>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct PlaceOrder<'info> {\n    #[account(mut)]\n    pub order_book: Account<'info, OrderBook>,\n    #[account(mut)]\n    pub trader: Signer<'info>,\n}\n\n#[derive(Accounts)]\npub struct CancelOrder<'info> {\n    #[account(mut)]\n    pub order_book: Account<'info, OrderBook>,\n    #[account(mut)]\n    pub trader: Signer<'info>,\n}\n\n#[account]\npub struct Market {\n    pub fee_rate: u64,\n}\n\n#[account]\npub struct OrderBook {\n    pub total_orders: u64,\n}\n\n#[error_code]\npub enum DexError {\n    #[msg(\"Invalid fee rate\")]\n    InvalidFeeRate,\n    #[msg(\"Invalid order\")]\n    InvalidOrder,\n    #[msg(\"Order not found\")]\n    OrderNotFound,\n}",
        "vulnerabilities": []
    },    
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\nmod vulnerable_nft_marketplace {\n    use super::*;\n\n    pub fn create_listing(ctx: Context<CreateListing>, price: u64) -> Result<()> {\n        let listing = &mut ctx.accounts.listing;\n        listing.seller = ctx.accounts.seller.key();\n        listing.nft_mint = ctx.accounts.nft_mint.key();\n        listing.price = price;\n        listing.active = true;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.seller_nft_account.to_account_info(),\n                    to: ctx.accounts.escrow_nft_account.to_account_info(),\n                    authority: ctx.accounts.seller.to_account_info(),\n                },\n            ),\n            1,\n        )?;\n\n        Ok(())\n    }\n\n    pub fn buy_nft(ctx: Context<BuyNFT>) -> Result<()> {\n        let listing = &mut ctx.accounts.listing;\n        require!(listing.active, NFTMarketplaceError::ListingNotActive);\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.buyer_token_account.to_account_info(),\n                    to: ctx.accounts.seller_token_account.to_account_info(),\n                    authority: ctx.accounts.buyer.to_account_info(),\n                },\n            ),\n            listing.price,\n        )?;\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.escrow_nft_account.to_account_info(),\n                    to: ctx.accounts.buyer_nft_account.to_account_info(),\n                    authority: listing.to_account_info(),\n                },\n                &[&[b\"listing\", listing.nft_mint.as_ref(), &[ctx.bumps.listing]]],\n            ),\n            1,\n        )?;\n\n        listing.active = false;\n\n        Ok(())\n    }\n\n    pub fn cancel_listing(ctx: Context<CancelListing>) -> Result<()> {\n        let listing = &mut ctx.accounts.listing;\n        require!(listing.active, NFTMarketplaceError::ListingNotActive);\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.escrow_nft_account.to_account_info(),\n                    to: ctx.accounts.seller_nft_account.to_account_info(),\n                    authority: listing.to_account_info(),\n                },\n                &[&[b\"listing\", listing.nft_mint.as_ref(), &[ctx.bumps.listing]]],\n            ),\n            1,\n        )?;\n\n        listing.active = false;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct CreateListing<'info> {\n    #[account(init, payer = seller, space = 8 + 32 + 32 + 8 + 1, seeds = [b\"listing\", nft_mint.key().as_ref()], bump)]\n    pub listing: Account<'info, NFTListing>,\n    #[account(mut)]\n    pub seller: Signer<'info>,\n    pub nft_mint: Account<'info, Mint>,\n    #[account(mut)]\n    pub seller_nft_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub escrow_nft_account: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct BuyNFT<'info> {\n    #[account(mut, seeds = [b\"listing\", listing.nft_mint.as_ref()], bump)]\n    pub listing: Account<'info, NFTListing>,\n    #[account(mut)]\n    pub buyer: Signer<'info>,\n    #[account(mut)]\n    pub seller_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub buyer_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub buyer_nft_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub escrow_nft_account: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct CancelListing<'info> {\n    #[account(mut, seeds = [b\"listing\", listing.nft_mint.as_ref()], bump)]\n    pub listing: Account<'info, NFTListing>,\n    #[account(mut)]\n    pub seller: Signer<'info>,\n    #[account(mut)]\n    pub seller_nft_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub escrow_nft_account: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct NFTListing {\n    pub seller: Pubkey,\n    pub nft_mint: Pubkey,\n    pub price: u64,\n    pub active: bool,\n}\n\n#[error_code]\npub enum NFTMarketplaceError {\n    #[msg(\"Listing is not active\")]\n    ListingNotActive,\n}",
        "vulnerabilities": [
            "Insufficient price validation in listing creation, potentially enabling mispriced or manipulated NFT sales",
            "Unrestricted access to listing cancellation, allowing unauthorized removal of valid marketplace offerings",
            "Lack of transaction ordering protection in purchase function, exposing buyers to potential value extraction"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\n\n#[program]\npub mod lottery {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, ticket_price: u64, draw_time: i64) -> Result<()> {\n        let lottery = &mut ctx.accounts.lottery;\n        require!(ticket_price > 0, LotteryError::InvalidTicketPrice);\n        require!(draw_time > clock::Clock::get()?.unix_timestamp, LotteryError::InvalidDrawTime);\n        lottery.ticket_price = ticket_price;\n        lottery.draw_time = draw_time;\n        lottery.total_tickets = 0;\n        Ok(())\n    }\n\n    pub fn buy_ticket(ctx: Context<BuyTicket>) -> Result<()> {\n        let lottery = &mut ctx.accounts.lottery;\n        require!(clock::Clock::get()?.unix_timestamp <= lottery.draw_time, LotteryError::LotteryClosed);\n        lottery.total_tickets += 1;\n        Ok(())\n    }\n\n    pub fn draw_winner(ctx: Context<DrawWinner>) -> Result<()> {\n        let lottery = &mut ctx.accounts.lottery;\n        require!(clock::Clock::get()?.unix_timestamp > lottery.draw_time, LotteryError::LotteryNotEnded);\n        require!(lottery.total_tickets > 0, LotteryError::NoTicketsSold);\n\n        let winner_ticket = rand::thread_rng().gen_range(0..lottery.total_tickets);\n        lottery.winner_ticket = winner_ticket;\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 8 + 8 + 8)]\n    pub lottery: Account<'info, Lottery>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct BuyTicket<'info> {\n    #[account(mut)]\n    pub lottery: Account<'info, Lottery>,\n    #[account(mut)]\n    pub buyer: Signer<'info>,\n}\n\n#[derive(Accounts)]\npub struct DrawWinner<'info> {\n    #[account(mut)]\n    pub lottery: Account<'info, Lottery>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n}\n\n#[account]\npub struct Lottery {\n    pub ticket_price: u64,\n    pub draw_time: i64,\n    pub total_tickets: u64,\n    pub winner_ticket: u64,\n}\n\n#[error_code]\npub enum LotteryError {\n    #[msg(\"Invalid ticket price\")]\n    InvalidTicketPrice,\n    #[msg(\"Invalid draw time\")]\n    InvalidDrawTime,\n    #[msg(\"Lottery is closed\")]\n    LotteryClosed,\n    #[msg(\"Lottery has not ended\")]\n    LotteryNotEnded,\n    #[msg(\"No tickets sold\")]\n    NoTicketsSold,\n}",
        "vulnerabilities": []
    },    
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\npub mod vulnerable_dex {\n    use super::*;\n\n    pub fn initialize_pool(ctx: Context<InitializePool>, fee: u64) -> Result<()> {\n        let pool = &mut ctx.accounts.pool;\n        pool.token_a = ctx.accounts.token_a.key();\n        pool.token_b = ctx.accounts.token_b.key();\n        pool.fee = fee;\n        Ok(())\n    }\n\n    pub fn add_liquidity(ctx: Context<AddLiquidity>, amount_a: u64, amount_b: u64) -> Result<()> {\n        let pool = &mut ctx.accounts.pool;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_a.to_account_info(),\n                    to: ctx.accounts.pool_token_a.to_account_info(),\n                    authority: ctx.accounts.user.to_account_info(),\n                },\n            ),\n            amount_a,\n        )?;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_b.to_account_info(),\n                    to: ctx.accounts.pool_token_b.to_account_info(),\n                    authority: ctx.accounts.user.to_account_info(),\n                },\n            ),\n            amount_b,\n        )?;\n\n        pool.liquidity_a += amount_a;\n        pool.liquidity_b += amount_b;\n\n        Ok(())\n    }\n\n    pub fn swap(ctx: Context<Swap>, amount_in: u64, min_amount_out: u64) -> Result<()> {\n        let pool = &mut ctx.accounts.pool;\n\n        let (from_account, to_account, liquidity_in, liquidity_out) = if ctx.accounts.token_in.key() == pool.token_a {\n            (\n                ctx.accounts.user_token_a.to_account_info(),\n                ctx.accounts.user_token_b.to_account_info(),\n                &mut pool.liquidity_a,\n                &mut pool.liquidity_b,\n            )\n        } else {\n            (\n                ctx.accounts.user_token_b.to_account_info(),\n                ctx.accounts.user_token_a.to_account_info(),\n                &mut pool.liquidity_b,\n                &mut pool.liquidity_a,\n            )\n        };\n\n        let amount_out = (amount_in as u128 * *liquidity_out as u128 / *liquidity_in as u128) as u64;\n        let fee_amount = amount_out * pool.fee / 10000;\n        let amount_out_after_fee = amount_out - fee_amount;\n\n        require!(amount_out_after_fee >= min_amount_out, DexError::SlippageExceeded);\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: from_account,\n                    to: ctx.accounts.pool_token_in.to_account_info(),\n                    authority: ctx.accounts.user.to_account_info(),\n                },\n            ),\n            amount_in,\n        )?;\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.pool_token_out.to_account_info(),\n                    to: to_account,\n                    authority: pool.to_account_info(),\n                },\n                &[&[b\"pool\", &[ctx.bumps.pool]]],\n            ),\n            amount_out_after_fee,\n        )?;\n\n        *liquidity_in += amount_in;\n        *liquidity_out -= amount_out_after_fee;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct InitializePool<'info> {\n    #[account(init, payer = payer, space = 8 + 32 + 32 + 8 + 8 + 8)]\n    pub pool: Account<'info, Pool>,\n    #[account(mut)]\n    pub payer: Signer<'info>,\n    pub token_a: Account<'info, Mint>,\n    pub token_b: Account<'info, Mint>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct AddLiquidity<'info> {\n    #[account(mut)]\n    pub pool: Account<'info, Pool>,\n    pub user: Signer<'info>,\n    #[account(mut)]\n    pub user_token_a: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub user_token_b: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_a: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_b: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct Swap<'info> {\n    #[account(mut)]\n    pub pool: Account<'info, Pool>,\n    pub user: Signer<'info>,\n    #[account(mut)]\n    pub user_token_a: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub user_token_b: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_a: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_b: Account<'info, TokenAccount>,\n    pub token_in: Account<'info, Mint>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct Pool {\n    pub token_a: Pubkey,\n    pub token_b: Pubkey,\n    pub liquidity_a: u64,\n    pub liquidity_b: u64,\n    pub fee: u64,\n}\n\n#[error_code]\npub enum DexError {\n    #[msg(\"Slippage tolerance exceeded\")]\n    SlippageExceeded,\n}\n",
        "vulnerabilities": [
            "Absence of slippage control and batching mechanisms, exposing users to potential sandwich attacks",
            "Lack of external price feed integration, risking unfair token valuations and potential arbitrage exploitation",
            "Use of fixed-point arithmetic without proper scaling, potentially leading to rounding errors and value loss in swaps"
        ]
    },
    {
      "code": "pub fn withdraw(ctx: Context<Withdraw>, amount: u64) -> Result<()> {\n    let user = &mut ctx.accounts.user;\n    let vault = &mut ctx.accounts.vault;\n\n    if !user.is_signer {\n        return Err(ErrorCode::Unauthorized.into());\n    }\n\n    if user.balance < amount {\n        return Err(ErrorCode::InsufficientFunds.into());\n    }\n\n    **vault.to_account_info().try_borrow_mut_lamports()? = vault\n        .to_account_info()\n        .lamports()\n        .checked_sub(amount)\n        .ok_or(ErrorCode::Overflow)?;\n    **user.to_account_info().try_borrow_mut_lamports()? = user\n        .to_account_info()\n        .lamports()\n        .checked_add(amount)\n        .ok_or(ErrorCode::Overflow)?;\n\n    Ok(())\n}",
      "vulnerabilities": [
            "Insufficient function-level access controls, allowing unauthorized execution of sensitive operations",
            "Lack of parameter boundary checks and sanitization, potentially leading to unexpected contract behavior",
            "Concentration of critical functions or permissions, creating single points of failure and protocol fragility"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\ndeclare_id!(\"Lend11111111111111111111111111111111111111\");\n\n#[program]\npub mod lending_protocol {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, interest_rate: u64) -> Result<()> {\n        let lending_pool = &mut ctx.accounts.lending_pool;\n        lending_pool.authority = ctx.accounts.authority.key();\n        lending_pool.interest_rate = interest_rate;\n        lending_pool.total_deposits = 0;\n        lending_pool.total_borrows = 0;\n        Ok(())\n    }\n\n    pub fn deposit(ctx: Context<Deposit>, amount: u64) -> Result<()> {\n        let lending_pool = &mut ctx.accounts.lending_pool;\n        let user = &mut ctx.accounts.user;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_account.to_account_info(),\n                    to: ctx.accounts.pool_token_account.to_account_info(),\n                    authority: user.to_account_info(),\n                },\n            ),\n            amount,\n        )?;\n\n        user.deposited_amount = user.deposited_amount.checked_add(amount).unwrap();\n        lending_pool.total_deposits = lending_pool.total_deposits.checked_add(amount).unwrap();\n\n        Ok(())\n    }\n\n    pub fn borrow(ctx: Context<Borrow>, amount: u64) -> Result<()> {\n        let lending_pool = &mut ctx.accounts.lending_pool;\n        let user = &mut ctx.accounts.user;\n\n        require!(amount <= lending_pool.total_deposits.checked_sub(lending_pool.total_borrows).unwrap(), ErrorCode::InsufficientLiquidity);\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.pool_token_account.to_account_info(),\n                    to: ctx.accounts.user_token_account.to_account_info(),\n                    authority: lending_pool.to_account_info(),\n                },\n                &[&[&lending_pool.authority.to_bytes(), &[*ctx.bumps.get(\"lending_pool\").unwrap()]]],\n            ),\n            amount,\n        )?;\n\n        user.borrowed_amount = user.borrowed_amount.checked_add(amount).unwrap();\n        lending_pool.total_borrows = lending_pool.total_borrows.checked_add(amount).unwrap();\n\n        Ok(())\n    }\n\n    pub fn repay(ctx: Context<Repay>, amount: u64) -> Result<()> {\n        let lending_pool = &mut ctx.accounts.lending_pool;\n        let user = &mut ctx.accounts.user;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_account.to_account_info(),\n                    to: ctx.accounts.pool_token_account.to_account_info(),\n                    authority: user.to_account_info(),\n                },\n            ),\n            amount,\n        )?;\n\n        user.borrowed_amount = user.borrowed_amount.checked_sub(amount).unwrap();\n        lending_pool.total_borrows = lending_pool.total_borrows.checked_sub(amount).unwrap();\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 8 + 8 + 8)]\n    pub lending_pool: Account<'info, LendingPool>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Deposit<'info> {\n    #[account(mut)]\n    pub lending_pool: Account<'info, LendingPool>,\n    #[account(mut)]\n    pub user: Account<'info, User>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_account: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct Borrow<'info> {\n    #[account(mut)]\n    pub lending_pool: Account<'info, LendingPool>,\n    #[account(mut)]\n    pub user: Account<'info, User>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_account: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct Repay<'info> {\n    #[account(mut)]\n    pub lending_pool: Account<'info, LendingPool>,\n    #[account(mut)]\n    pub user: Account<'info, User>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_account: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct LendingPool {\n    pub authority: Pubkey,\n    pub interest_rate: u64,\n    pub total_deposits: u64,\n    pub total_borrows: u64,\n}\n\n#[account]\npub struct User {\n    pub deposited_amount: u64,\n    pub borrowed_amount: u64,\n}\n\n#[error_code]\npub enum ErrorCode {\n    #[msg(\"Insufficient liquidity in the pool\")]\n    InsufficientLiquidity,\n}",
        "vulnerabilities": [
          "Lack of collateral checks: The borrow function doesn't check if the user has sufficient collateral, allowing for undercollateralized loans.",
          "Missing interest accrual: The contract doesn't implement interest accrual, which could lead to financial losses for the protocol.",
          "Potential for flash loan attacks: The borrow and repay functions can be called in the same transaction, potentially allowing for flash loan exploits."
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\ndeclare_id!(\"Swap11111111111111111111111111111111111111\");\n\n#[program]\npub mod token_swap {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, fee: u64) -> Result<()> {\n        let swap_pool = &mut ctx.accounts.swap_pool;\n        swap_pool.authority = ctx.accounts.authority.key();\n        swap_pool.fee = fee;\n        swap_pool.total_liquidity = 0;\n        Ok(())\n    }\n\n    pub fn add_liquidity(ctx: Context<AddLiquidity>, amount_a: u64, amount_b: u64) -> Result<()> {\n        let swap_pool = &mut ctx.accounts.swap_pool;\n        let user = &mut ctx.accounts.user;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_a.to_account_info(),\n                    to: ctx.accounts.pool_token_a.to_account_info(),\n                    authority: user.to_account_info(),\n                },\n            ),\n            amount_a,\n        )?;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_b.to_account_info(),\n                    to: ctx.accounts.pool_token_b.to_account_info(),\n                    authority: user.to_account_info(),\n                },\n            ),\n            amount_b,\n        )?;\n\n        swap_pool.total_liquidity = swap_pool.total_liquidity.checked_add(amount_a).unwrap().checked_add(amount_b).unwrap();\n        user.liquidity_provided = user.liquidity_provided.checked_add(amount_a).unwrap().checked_add(amount_b).unwrap();\n\n        Ok(())\n    }\n\n    pub fn swap(ctx: Context<Swap>, amount_in: u64, minimum_amount_out: u64) -> Result<()> {\n        let swap_pool = &ctx.accounts.swap_pool;\n        \n        let balance_a = ctx.accounts.pool_token_a.amount;\n        let balance_b = ctx.accounts.pool_token_b.amount;\n\n        let amount_out = (balance_b as u128)\n            .checked_mul(amount_in as u128)\n            .unwrap()\n            .checked_div(balance_a as u128)\n            .unwrap() as u64;\n\n        require!(amount_out >= minimum_amount_out, ErrorCode::SlippageExceeded);\n\n        let fee_amount = amount_out.checked_mul(swap_pool.fee).unwrap().checked_div(10000).unwrap();\n        let amount_out_after_fee = amount_out.checked_sub(fee_amount).unwrap();\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_a.to_account_info(),\n                    to: ctx.accounts.pool_token_a.to_account_info(),\n                    authority: ctx.accounts.user.to_account_info(),\n                },\n            ),\n            amount_in,\n        )?;\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.pool_token_b.to_account_info(),\n                    to: ctx.accounts.user_token_b.to_account_info(),\n                    authority: swap_pool.to_account_info(),\n                },\n                &[&[&swap_pool.authority.to_bytes(), &[*ctx.bumps.get(\"swap_pool\").unwrap()]]],\n            ),\n            amount_out_after_fee,\n        )?;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 8 + 8)]\n    pub swap_pool: Account<'info, SwapPool>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct AddLiquidity<'info> {\n    #[account(mut)]\n    pub swap_pool: Account<'info, SwapPool>,\n    #[account(mut)]\n    pub user: Account<'info, User>,\n    #[account(mut)]\n    pub user_token_a: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub user_token_b: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_a: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_b: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct Swap<'info> {\n    #[account(mut)]\n    pub swap_pool: Account<'info, SwapPool>,\n    #[account(mut)]\n    pub user: Signer<'info>,\n    #[account(mut)]\n    pub user_token_a: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub user_token_b: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_a: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_b: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct SwapPool {\n    pub authority: Pubkey,\n    pub fee: u64,\n    pub total_liquidity: u64,\n}\n\n#[account]\npub struct User {\n    pub liquidity_provided: u64,\n}\n\n#[error_code]\npub enum ErrorCode {\n    #[msg(\"Slippage tolerance exceeded\")]\n    SlippageExceeded,\n}",
        "vulnerabilities": [
          "Price manipulation vulnerability: The swap function calculates the output amount based on the current pool balances, which can be manipulated by a large trade just before the swap.",
          "Lack of access control: The add_liquidity function doesn't have any restrictions on who can add liquidity, potentially allowing malicious actors to manipulate the pool.",
          "Rounding errors: The use of integer division in the swap calculation can lead to rounding errors, potentially causing loss of funds over time."
        ]
    },
    {
        "code": "use anchor_lang::prelude::*; use anchor_spl::token::{self, Token, TokenAccount, Transfer}; #[program] pub mod unsafe_yield_farming { use super::*; pub fn initialize_pool(ctx: Context<InitializePool>, reward_rate: u64) -> Result<()> { ctx.accounts.pool.admin = ctx.accounts.admin.key(); ctx.accounts.pool.reward_rate = reward_rate; ctx.accounts.pool.last_update_time = Clock::get()?.unix_timestamp; Ok(()) } pub fn stake(ctx: Context<Stake>, amount: u64) -> Result<()> { let pool = &mut ctx.accounts.pool; let user = &mut ctx.accounts.user; token::transfer(CpiContext::new(ctx.accounts.token_program.to_account_info(), Transfer { from: ctx.accounts.user_token_account.to_account_info(), to: ctx.accounts.pool_token_account.to_account_info(), authority: ctx.accounts.user.to_account_info(), }), amount)?; let current_time = Clock::get()?.unix_timestamp; let time_elapsed = current_time - pool.last_update_time; let pending_reward = (pool.reward_rate * time_elapsed as u64 * user.staked_amount) / pool.total_staked; user.pending_reward += pending_reward; user.staked_amount += amount; pool.total_staked += amount; pool.last_update_time = current_time; Ok(()) } pub fn unstake(ctx: Context<Unstake>, amount: u64) -> Result<()> { let pool = &mut ctx.accounts.pool; let user = &mut ctx.accounts.user; require!(user.staked_amount >= amount, ErrorCode::InsufficientStake); let current_time = Clock::get()?.unix_timestamp; let time_elapsed = current_time - pool.last_update_time; let pending_reward = (pool.reward_rate * time_elapsed as u64 * user.staked_amount) / pool.total_staked; user.pending_reward += pending_reward; token::transfer(CpiContext::new_with_signer(ctx.accounts.token_program.to_account_info(), Transfer { from: ctx.accounts.pool_token_account.to_account_info(), to: ctx.accounts.user_token_account.to_account_info(), authority: pool.to_account_info(), }, &[&[b\"pool\".as_ref(), &[pool.bump]]]), amount)?; user.staked_amount -= amount; pool.total_staked -= amount; pool.last_update_time = current_time; Ok(()) } pub fn claim_reward(ctx: Context<ClaimReward>) -> Result<()> { let pool = &mut ctx.accounts.pool; let user = &mut ctx.accounts.user; let current_time = Clock::get()?.unix_timestamp; let time_elapsed = current_time - pool.last_update_time; let pending_reward = (pool.reward_rate * time_elapsed as u64 * user.staked_amount) / pool.total_staked; let total_reward = user.pending_reward + pending_reward; token::transfer(CpiContext::new_with_signer(ctx.accounts.token_program.to_account_info(), Transfer { from: ctx.accounts.reward_token_account.to_account_info(), to: ctx.accounts.user_reward_account.to_account_info(), authority: pool.to_account_info(), }, &[&[b\"pool\".as_ref(), &[pool.bump]]]), total_reward)?; user.pending_reward = 0; pool.last_update_time = current_time; Ok(()) } }",
        "vulnerabilities": [
            "Integer overflow risk in reward calculations",
            "No slippage protection in unstake function",
            "Potential for reward manipulation through frequent small stakes/unstakes"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*; use anchor_spl::token::{self, Token, TokenAccount, Transfer}; #[program] pub mod unsafe_nft_rental { use super::*; pub fn list_nft(ctx: Context<ListNFT>, price_per_day: u64, max_rental_period: u64) -> Result<()> { ctx.accounts.rental.owner = ctx.accounts.owner.key(); ctx.accounts.rental.nft_mint = ctx.accounts.nft_mint.key(); ctx.accounts.rental.price_per_day = price_per_day; ctx.accounts.rental.max_rental_period = max_rental_period; ctx.accounts.rental.is_rented = false; token::transfer(CpiContext::new(ctx.accounts.token_program.to_account_info(), Transfer { from: ctx.accounts.owner_nft_account.to_account_info(), to: ctx.accounts.escrow_nft_account.to_account_info(), authority: ctx.accounts.owner.to_account_info(), }), 1)?; Ok(()) } pub fn rent_nft(ctx: Context<RentNFT>, rental_period: u64) -> Result<()> { let rental = &mut ctx.accounts.rental; require!(!rental.is_rented, ErrorCode::NFTAlreadyRented); require!(rental_period <= rental.max_rental_period, ErrorCode::RentalPeriodTooLong); let total_price = rental.price_per_day * rental_period; token::transfer(CpiContext::new(ctx.accounts.token_program.to_account_info(), Transfer { from: ctx.accounts.renter_token_account.to_account_info(), to: ctx.accounts.owner_token_account.to_account_info(), authority: ctx.accounts.renter.to_account_info(), }), total_price)?; token::transfer(CpiContext::new_with_signer(ctx.accounts.token_program.to_account_info(), Transfer { from: ctx.accounts.escrow_nft_account.to_account_info(), to: ctx.accounts.renter_nft_account.to_account_info(), authority: rental.to_account_info(), }, &[&[b\"rental\".as_ref(), &[rental.bump]]]), 1)?; rental.is_rented = true; rental.renter = ctx.accounts.renter.key(); rental.rental_end_time = Clock::get()?.unix_timestamp + (rental_period as i64 * 24 * 60 * 60); Ok(()) } pub fn return_nft(ctx: Context<ReturnNFT>) -> Result<()> { let rental = &mut ctx.accounts.rental; require!(rental.is_rented, ErrorCode::NFTNotRented); require!(Clock::get()?.unix_timestamp >= rental.rental_end_time, ErrorCode::RentalPeriodNotEnded); token::transfer(CpiContext::new(ctx.accounts.token_program.to_account_info(), Transfer { from: ctx.accounts.renter_nft_account.to_account_info(), to: ctx.accounts.escrow_nft_account.to_account_info(), authority: ctx.accounts.renter.to_account_info(), }), 1)?; rental.is_rented = false; rental.renter = Pubkey::default(); rental.rental_end_time = 0; Ok(()) } }",
        "vulnerabilities": [
            "No mechanism to handle early returns or extensions",
            "Lack of access control on return_nft function",
            "Missing checks for NFT authenticity before renting"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*; use anchor_spl::token::{self, Token, TokenAccount, Transfer}; #[program] pub mod unsafe_perpetual_futures { use super::*; pub fn initialize_market(ctx: Context<InitializeMarket>, leverage: u8, maintenance_margin_ratio: u64) -> Result<()> { ctx.accounts.market.admin = ctx.accounts.admin.key(); ctx.accounts.market.leverage = leverage; ctx.accounts.market.maintenance_margin_ratio = maintenance_margin_ratio; ctx.accounts.market.open_interest_long = 0; ctx.accounts.market.open_interest_short = 0; Ok(()) } pub fn open_position(ctx: Context<OpenPosition>, side: Side, collateral: u64, size: u64) -> Result<()> { let market = &mut ctx.accounts.market; let position = &mut ctx.accounts.position; let price = ctx.accounts.oracle.price; require!(collateral * market.leverage as u64 >= size * price / 1000000, ErrorCode::InsufficientCollateral); token::transfer(CpiContext::new(ctx.accounts.token_program.to_account_info(), Transfer { from: ctx.accounts.user_collateral_account.to_account_info(), to: ctx.accounts.market_collateral_account.to_account_info(), authority: ctx.accounts.user.to_account_info(), }), collateral)?; position.owner = ctx.accounts.user.key(); position.side = side; position.size = size; position.collateral = collateral; position.entry_price = price; match side { Side::Long => market.open_interest_long += size, Side::Short => market.open_interest_short += size, } Ok(()) } pub fn close_position(ctx: Context<ClosePosition>) -> Result<()> { let market = &mut ctx.accounts.market; let position = &ctx.accounts.position; let price = ctx.accounts.oracle.price; let pnl = match position.side { Side::Long => (price - position.entry_price) * position.size / 1000000, Side::Short => (position.entry_price - price) * position.size / 1000000, }; let total_return = position.collateral as i64 + pnl; if total_return > 0 { token::transfer(CpiContext::new_with_signer(ctx.accounts.token_program.to_account_info(), Transfer { from: ctx.accounts.market_collateral_account.to_account_info(), to: ctx.accounts.user_collateral_account.to_account_info(), authority: market.to_account_info(), }, &[&[b\"market\".as_ref(), &[market.bump]]]), total_return as u64)?; } match position.side { Side::Long => market.open_interest_long -= position.size, Side::Short => market.open_interest_short -= position.size, } Ok(()) } pub fn liquidate(ctx: Context<Liquidate>) -> Result<()> { let market = &mut ctx.accounts.market; let position = &ctx.accounts.position; let price = ctx.accounts.oracle.price; let unrealized_pnl = match position.side { Side::Long => (price - position.entry_price) * position.size / 1000000, Side::Short => (position.entry_price - price) * position.size / 1000000, }; let margin_ratio = (position.collateral as i64 + unrealized_pnl) * 10000 / (position.size * price / 1000000); require!(margin_ratio < market.maintenance_margin_ratio as i64, ErrorCode::CannotLiquidate); let liquidation_fee = position.collateral / 2; token::transfer(CpiContext::new_with_signer(ctx.accounts.token_program.to_account_info(), Transfer { from: ctx.accounts.market_collateral_account.to_account_info(), to: ctx.accounts.liquidator_account.to_account_info(), authority: market.to_account_info(), }, &[&[b\"market\".as_ref(), &[market.bump]]]), liquidation_fee)?; match position.side { Side::Long => market.open_interest_long -= position.size, Side::Short => market.open_interest_short -= position.size, } Ok(()) } }",
        "vulnerabilities": [
            "Lack of price impact consideration in open_position",
            "No funding rate mechanism to balance long and short positions",
            "Potential for oracle manipulation in liquidations"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*; use anchor_spl::token::{self, Token, TokenAccount, Transfer}; #[program] pub mod unsafe_escrow { use super::*; pub fn create_escrow(ctx: Context<CreateEscrow>, amount: u64, receiver: Pubkey) -> Result<()> { let escrow = &mut ctx.accounts.escrow; escrow.sender = ctx.accounts.sender.key(); escrow.receiver = receiver; escrow.amount = amount; escrow.is_completed = false; token::transfer(CpiContext::new(ctx.accounts.token_program.to_account_info(), Transfer { from: ctx.accounts.sender_token_account.to_account_info(), to: ctx.accounts.escrow_token_account.to_account_info(), authority: ctx.accounts.sender.to_account_info(), }), amount)?; Ok(()) } pub fn complete_escrow(ctx: Context<CompleteEscrow>) -> Result<()> { let escrow = &mut ctx.accounts.escrow; require!(!escrow.is_completed, ErrorCode::EscrowAlreadyCompleted); require!(ctx.accounts.receiver.key() == escrow.receiver, ErrorCode::InvalidReceiver); token::transfer(CpiContext::new_with_signer(ctx.accounts.token_program.to_account_info(), Transfer { from: ctx.accounts.escrow_token_account.to_account_info(), to: ctx.accounts.receiver_token_account.to_account_info(), authority: escrow.to_account_info(), }, &[&[b\"escrow\".as_ref(), &[escrow.bump]]]), escrow.amount)?; escrow.is_completed = true; Ok(()) } pub fn cancel_escrow(ctx: Context<CancelEscrow>) -> Result<()> { let escrow = &mut ctx.accounts.escrow; require!(!escrow.is_completed, ErrorCode::EscrowAlreadyCompleted); require!(ctx.accounts.sender.key() == escrow.sender, ErrorCode::InvalidSender); token::transfer(CpiContext::new_with_signer(ctx.accounts.token_program.to_account_info(), Transfer { from: ctx.accounts.escrow_token_account.to_account_info(), to: ctx.accounts.sender_token_account.to_account_info(), authority: escrow.to_account_info(), }, &[&[b\"escrow\".as_ref(), &[escrow.bump]]]), escrow.amount)?; escrow.is_completed = true; Ok(()) } }",
        "vulnerabilities": [
            "No time lock or expiration for escrow",
            "Lack of partial release mechanism",
            "Missing event emission for escrow state changes"
        ]
    },
    {
      "code": "pub fn initialize(ctx: Context<Initialize>) -> Result<()> {\n    let data = &mut ctx.accounts.data;\n    let initializer = &ctx.accounts.initializer;\n\n    if !initializer.is_signer {\n        return Err(ErrorCode::Unauthorized.into());\n    }\n\n    data.owner = initializer.key();\n    data.initialized = true;\n\n    emit!(InitializeEvent {\n        owner: initializer.key(),\n        timestamp: Clock::get()?.unix_timestamp\n    });\n\n    Ok(())\n}",
      "vulnerabilities": [
        "Unrestricted Price Manipulation",
        "Potential for uninitialized state",
        "Lack of event emission",
        "Lack of error handling"
      ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\ndeclare_id!(\"Stake11111111111111111111111111111111111111\");\n\n#[program]\npub mod staking_program {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, staking_period: i64) -> Result<()> {\n        let staking_pool = &mut ctx.accounts.staking_pool;\n        staking_pool.authority = ctx.accounts.authority.key();\n        staking_pool.staking_period = staking_period;\n        staking_pool.total_staked = 0;\n        Ok(())\n    }\n\n    pub fn stake(ctx: Context<Stake>, amount: u64) -> Result<()> {\n        let staking_pool = &mut ctx.accounts.staking_pool;\n        let user = &mut ctx.accounts.user;\n        let clock = Clock::get()?;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_account.to_account_info(),\n                    to: ctx.accounts.pool_token_account.to_account_info(),\n                    authority: user.to_account_info(),\n                },\n            ),\n            amount,\n        )?;\n\n        user.staked_amount = user.staked_amount.checked_add(amount).unwrap();\n        user.stake_timestamp = clock.unix_timestamp;\n        staking_pool.total_staked = staking_pool.total_staked.checked_add(amount).unwrap();\n\n        Ok(())\n    }\n\n    pub fn unstake(ctx: Context<Unstake>) -> Result<()> {\n        let staking_pool = &mut ctx.accounts.staking_pool;\n        let user = &mut ctx.accounts.user;\n        let clock = Clock::get()?;\n\n        require!(\n            clock.unix_timestamp >= user.stake_timestamp + staking_pool.staking_period,\n            ErrorCode::StakingPeriodNotCompleted\n        );\n\n        let amount = user.staked_amount;\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.pool_token_account.to_account_info(),\n                    to: ctx.accounts.user_token_account.to_account_info(),\n                    authority: staking_pool.to_account_info(),\n                },\n                &[&[&staking_pool.authority.to_bytes(), &[*ctx.bumps.get(\"staking_pool\").unwrap()]]],\n            ),\n            amount,\n        )?;\n\n        user.staked_amount = 0;\n        user.stake_timestamp = 0;\n        staking_pool.total_staked = staking_pool.total_staked.checked_sub(amount).unwrap();\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 8 + 8)]\n    pub staking_pool: Account<'info, StakingPool>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Stake<'info> {\n    #[account(mut)]\n    pub staking_pool: Account<'info, StakingPool>,\n    #[account(mut)]\n    pub user: Account<'info, User>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_account: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct Unstake<'info> {\n    #[account(mut)]\n    pub staking_pool: Account<'info, StakingPool>,\n    #[account(mut)]\n    pub user: Account<'info, User>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_account: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct StakingPool {\n    pub authority: Pubkey,\n    pub staking_period: i64,\n    pub total_staked: u64,\n}\n\n#[account]\npub struct User {\n    pub staked_amount: u64,\n    pub stake_timestamp: i64,\n}\n\n#[error_code]\npub enum ErrorCode {\n    #[msg(\"Staking period not completed\")]\n    StakingPeriodNotCompleted,\n}",
        "vulnerabilities": [
          "Lack of reentrancy protection: The stake and unstake functions modify state after external calls, which could be exploited in a reentrancy attack.",
          "Missing slippage protection: The unstake function doesn't account for potential changes in token value, which could lead to unfair unstaking in volatile markets.",
          "Centralization risk: The contract has a single authority that controls critical functions, creating a central point of failure."
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\ndeclare_id!(\"Lott11111111111111111111111111111111111111\");\n\n#[program]\npub mod lottery_program {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, ticket_price: u64) -> Result<()> {\n        let lottery = &mut ctx.accounts.lottery;\n        lottery.authority = ctx.accounts.authority.key();\n        lottery.ticket_price = ticket_price;\n        lottery.total_pot = 0;\n        lottery.participants = 0;\n        lottery.winner = Pubkey::default();\n        Ok(())\n    }\n\n    pub fn buy_ticket(ctx: Context<BuyTicket>) -> Result<()> {\n        let lottery = &mut ctx.accounts.lottery;\n        let participant = &mut ctx.accounts.participant;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.participant_token_account.to_account_info(),\n                    to: ctx.accounts.lottery_token_account.to_account_info(),\n                    authority: participant.to_account_info(),\n                },\n            ),\n            lottery.ticket_price,\n        )?;\n\n        lottery.total_pot = lottery.total_pot.checked_add(lottery.ticket_price).unwrap();\n        lottery.participants = lottery.participants.checked_add(1).unwrap();\n        participant.tickets = participant.tickets.checked_add(1).unwrap();\n\n        Ok(())\n    }\n\n    pub fn draw_winner(ctx: Context<DrawWinner>) -> Result<()> {\n        let lottery = &mut ctx.accounts.lottery;\n        require!(ctx.accounts.authority.key() == lottery.authority, ErrorCode::Unauthorized);\n\n        let clock = Clock::get()?;\n        let random_seed = clock.unix_timestamp as u64;\n        let winner_index = random_seed % lottery.participants;\n\n        // In a real implementation, we would iterate through participants to find the winner\n        // For simplicity, we're just setting a dummy winner here\n        lottery.winner = ctx.accounts.dummy_winner.key();\n\n        Ok(())\n    }\n\n    pub fn claim_prize(ctx: Context<ClaimPrize>) -> Result<()> {\n        let lottery = &mut ctx.accounts.lottery;\n        require!(ctx.accounts.winner.key() == lottery.winner, ErrorCode::NotWinner);\n\n        let prize_amount = lottery.total_pot;\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.lottery_token_account.to_account_info(),\n                    to: ctx.accounts.winner_token_account.to_account_info(),\n                    authority: lottery.to_account_info(),\n                },\n                &[&[&lottery.authority.to_bytes(), &[*ctx.bumps.get(\"lottery\").unwrap()]]],\n            ),\n            prize_amount,\n        )?;\n\n        lottery.total_pot = 0;\n        lottery.participants = 0;\n        lottery.winner = Pubkey::default();\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 8 + 8 + 8 + 32)]\n    pub lottery: Account<'info, Lottery>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct BuyTicket<'info> {\n    #[account(mut)]\n    pub lottery: Account<'info, Lottery>,\n    #[account(mut)]\n    pub participant: Account<'info, Participant>,\n    #[account(mut)]\n    pub participant_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub lottery_token_account: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct DrawWinner<'info> {\n    #[account(mut)]\n    pub lottery: Account<'info, Lottery>,\n    pub authority: Signer<'info>,\n    /// CHECK: This account is not read or written, just used as a dummy winner\n    pub dummy_winner: AccountInfo<'info>,\n}\n\n#[derive(Accounts)]\npub struct ClaimPrize<'info> {\n    #[account(mut)]\n    pub lottery: Account<'info, Lottery>,\n    pub winner: Signer<'info>,\n    #[account(mut)]\n    pub winner_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub lottery_token_account: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct Lottery {\n    pub authority: Pubkey,\n    pub ticket_price: u64,\n    pub total_pot: u64,\n    pub participants: u64,\n    pub winner: Pubkey,\n}\n\n#[account]\npub struct Participant {\n    pub tickets: u64,\n}\n\n#[error_code]\npub enum ErrorCode {\n    #[msg(\"Not authorized\")]\n    Unauthorized,\n    #[msg(\"Not the winner\")]\n    NotWinner,\n}",
        "vulnerabilities": [
          "Weak randomness: The draw_winner function uses a predictable source of randomness (unix timestamp), which could be exploited by attackers to manipulate the lottery outcome.",
          "Front-running vulnerability: The draw_winner function can be front-run, allowing an attacker to buy tickets right before the winner is drawn, increasing their chances unfairly.",
          "Centralization risk: The lottery authority has significant control over the lottery, including the ability to draw winners at will, which could be abused."
        ]
    },
    {
        "code": "use anchor_lang::prelude::*; use anchor_spl::token::{self, Token, TokenAccount, Transfer}; #[program] pub mod secure_staking { use super::*; pub fn initialize(ctx: Context<Initialize>, staking_period: i64, reward_rate: u64) -> Result<()> { require!(staking_period > 0, ErrorCode::InvalidStakingPeriod); require!(reward_rate > 0 && reward_rate <= 10000, ErrorCode::InvalidRewardRate); let staking_pool = &mut ctx.accounts.staking_pool; staking_pool.authority = ctx.accounts.authority.key(); staking_pool.staking_mint = ctx.accounts.staking_mint.key(); staking_pool.staking_vault = ctx.accounts.staking_vault.key(); staking_pool.reward_mint = ctx.accounts.reward_mint.key(); staking_pool.reward_vault = ctx.accounts.reward_vault.key(); staking_pool.staking_period = staking_period; staking_pool.reward_rate = reward_rate; staking_pool.last_update_time = Clock::get()?.unix_timestamp; staking_pool.total_staked = 0; Ok(()) } pub fn stake(ctx: Context<Stake>, amount: u64) -> Result<()> { require!(amount > 0, ErrorCode::InvalidAmount); let staking_pool = &mut ctx.accounts.staking_pool; let user_stake = &mut ctx.accounts.user_stake; update_rewards(staking_pool, user_stake)?; token::transfer(CpiContext::new(ctx.accounts.token_program.to_account_info(), Transfer { from: ctx.accounts.user_token_account.to_account_info(), to: ctx.accounts.staking_vault.to_account_info(), authority: ctx.accounts.user.to_account_info(), }), amount)?; user_stake.staked_amount = user_stake.staked_amount.checked_add(amount).ok_or(ErrorCode::MathOverflow)?; staking_pool.total_staked = staking_pool.total_staked.checked_add(amount).ok_or(ErrorCode::MathOverflow)?; user_stake.last_update_time = Clock::get()?.unix_timestamp; emit!(StakeEvent { user: ctx.accounts.user.key(), amount }); Ok(()) } pub fn unstake(ctx: Context<Unstake>, amount: u64) -> Result<()> { require!(amount > 0, ErrorCode::InvalidAmount); let staking_pool = &mut ctx.accounts.staking_pool; let user_stake = &mut ctx.accounts.user_stake; require!(Clock::get()?.unix_timestamp >= user_stake.last_update_time.checked_add(staking_pool.staking_period).ok_or(ErrorCode::MathOverflow)?, ErrorCode::StakingPeriodNotComplete); require!(user_stake.staked_amount >= amount, ErrorCode::InsufficientStakedAmount); update_rewards(staking_pool, user_stake)?; token::transfer(CpiContext::new_with_signer(ctx.accounts.token_program.to_account_info(), Transfer { from: ctx.accounts.staking_vault.to_account_info(), to: ctx.accounts.user_token_account.to_account_info(), authority: staking_pool.to_account_info(), }, &[&[b\"staking_pool\".as_ref(), &[staking_pool.bump]]]), amount)?; user_stake.staked_amount = user_stake.staked_amount.checked_sub(amount).ok_or(ErrorCode::MathOverflow)?; staking_pool.total_staked = staking_pool.total_staked.checked_sub(amount).ok_or(ErrorCode::MathOverflow)?; emit!(UnstakeEvent { user: ctx.accounts.user.key(), amount }); Ok(()) } pub fn claim_rewards(ctx: Context<ClaimRewards>) -> Result<()> { let staking_pool = &mut ctx.accounts.staking_pool; let user_stake = &mut ctx.accounts.user_stake; update_rewards(staking_pool, user_stake)?; let rewards_to_claim = user_stake.pending_rewards; require!(rewards_to_claim > 0, ErrorCode::NoRewardsToClaim); token::transfer(CpiContext::new_with_signer(ctx.accounts.token_program.to_account_info(), Transfer { from: ctx.accounts.reward_vault.to_account_info(), to: ctx.accounts.user_reward_account.to_account_info(), authority: staking_pool.to_account_info(), }, &[&[b\"staking_pool\".as_ref(), &[staking_pool.bump]]]), rewards_to_claim)?; user_stake.pending_rewards = 0; emit!(ClaimRewardsEvent { user: ctx.accounts.user.key(), amount: rewards_to_claim }); Ok(()) } fn update_rewards(staking_pool: &mut Account<StakingPool>, user_stake: &mut Account<UserStake>) -> Result<()> { let current_time = Clock::get()?.unix_timestamp; let time_elapsed = current_time.checked_sub(staking_pool.last_update_time).ok_or(ErrorCode::MathOverflow)?; if time_elapsed > 0 && staking_pool.total_staked > 0 { let reward_per_token = (staking_pool.reward_rate as u128).checked_mul(time_elapsed as u128).ok_or(ErrorCode::MathOverflow)?.checked_mul(1e9 as u128).ok_or(ErrorCode::MathOverflow)?.checked_div(staking_pool.total_staked as u128).ok_or(ErrorCode::MathOverflow)?; staking_pool.accumulated_reward_per_token = staking_pool.accumulated_reward_per_token.checked_add(reward_per_token as u64).ok_or(ErrorCode::MathOverflow)?; } let pending_reward = (user_stake.staked_amount as u128).checked_mul(staking_pool.accumulated_reward_per_token.checked_sub(user_stake.reward_debt_per_token).ok_or(ErrorCode::MathOverflow)? as u128).ok_or(ErrorCode::MathOverflow)?.checked_div(1e9 as u128).ok_or(ErrorCode::MathOverflow)?; user_stake.pending_rewards = user_stake.pending_rewards.checked_add(pending_reward as u64).ok_or(ErrorCode::MathOverflow)?; user_stake.reward_debt_per_token = staking_pool.accumulated_reward_per_token; staking_pool.last_update_time = current_time; Ok(()) } }",
        "vulnerabilities": [
            "Potential for precision loss in reward calculations due to integer division",
            "Reliance on Solana's Clock for time-based operations, which could be manipulated in certain scenarios"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*; use anchor_spl::token::{self, Token, TokenAccount, Transfer, MintTo}; #[program] pub mod secure_amm { use super::*; pub fn initialize_pool(ctx: Context<InitializePool>, fee: u64) -> Result<()> { require!(fee > 0 && fee <= 10000, ErrorCode::InvalidFee); let pool = &mut ctx.accounts.pool; pool.token_a_mint = ctx.accounts.token_a_mint.key(); pool.token_b_mint = ctx.accounts.token_b_mint.key(); pool.token_a_reserve = ctx.accounts.token_a_reserve.key(); pool.token_b_reserve = ctx.accounts.token_b_reserve.key(); pool.lp_mint = ctx.accounts.lp_mint.key(); pool.fee = fee; pool.total_lp_supply = 0; Ok(()) } pub fn add_liquidity(ctx: Context<AddLiquidity>, amount_a: u64, amount_b: u64, min_lp_tokens: u64) -> Result<()> { require!(amount_a > 0 && amount_b > 0, ErrorCode::InvalidAmount); let pool = &mut ctx.accounts.pool; let reserve_a = ctx.accounts.token_a_reserve.amount; let reserve_b = ctx.accounts.token_b_reserve.amount; let lp_tokens_to_mint = if pool.total_lp_supply == 0 { (amount_a as u128).checked_mul(amount_b as u128).ok_or(ErrorCode::MathOverflow)?.sqrt() as u64 } else { std::cmp::min((amount_a as u128).checked_mul(pool.total_lp_supply as u128).ok_or(ErrorCode::MathOverflow)?.checked_div(reserve_a as u128).ok_or(ErrorCode::MathOverflow)? as u64, (amount_b as u128).checked_mul(pool.total_lp_supply as u128).ok_or(ErrorCode::MathOverflow)?.checked_div(reserve_b as u128).ok_or(ErrorCode::MathOverflow)? as u64) }; require!(lp_tokens_to_mint >= min_lp_tokens, ErrorCode::SlippageExceeded); token::transfer(CpiContext::new(ctx.accounts.token_program.to_account_info(), Transfer { from: ctx.accounts.user_token_a.to_account_info(), to: ctx.accounts.token_a_reserve.to_account_info(), authority: ctx.accounts.user.to_account_info(), }), amount_a)?; token::transfer(CpiContext::new(ctx.accounts.token_program.to_account_info(), Transfer { from: ctx.accounts.user_token_b.to_account_info(), to: ctx.accounts.token_b_reserve.to_account_info(), authority: ctx.accounts.user.to_account_info(), }), amount_b)?; token::mint_to(CpiContext::new_with_signer(ctx.accounts.token_program.to_account_info(), MintTo { mint: ctx.accounts.lp_mint.to_account_info(), to: ctx.accounts.user_lp_token.to_account_info(), authority: pool.to_account_info(), }, &[&[b\"pool\".as_ref(), &[pool.bump]]]), lp_tokens_to_mint)?; pool.total_lp_supply = pool.total_lp_supply.checked_add(lp_tokens_to_mint).ok_or(ErrorCode::MathOverflow)?; emit!(AddLiquidityEvent { user: ctx.accounts.user.key(), amount_a, amount_b, lp_tokens_minted: lp_tokens_to_mint }); Ok(()) } pub fn swap(ctx: Context<Swap>, amount_in: u64, minimum_amount_out: u64) -> Result<()> { require!(amount_in > 0, ErrorCode::InvalidAmount); let pool = &ctx.accounts.pool; let (reserve_in, reserve_out) = if ctx.accounts.token_in_reserve.key() == pool.token_a_reserve { (ctx.accounts.token_in_reserve.amount, ctx.accounts.token_out_reserve.amount) } else { (ctx.accounts.token_out_reserve.amount, ctx.accounts.token_in_reserve.amount) }; let amount_out = calculate_output_amount(amount_in, reserve_in, reserve_out, pool.fee)?; require!(amount_out >= minimum_amount_out, ErrorCode::SlippageExceeded); token::transfer(CpiContext::new(ctx.accounts.token_program.to_account_info(), Transfer { from: ctx.accounts.user_token_in.to_account_info(), to: ctx.accounts.token_in_reserve.to_account_info(), authority: ctx.accounts.user.to_account_info(), }), amount_in)?; token::transfer(CpiContext::new_with_signer(ctx.accounts.token_program.to_account_info(), Transfer { from: ctx.accounts.token_out_reserve.to_account_info(), to: ctx.accounts.user_token_out.to_account_info(), authority: pool.to_account_info(), }, &[&[b\"pool\".as_ref(), &[pool.bump]]]), amount_out)?; emit!(SwapEvent { user: ctx.accounts.user.key(), amount_in, amount_out }); Ok(()) } fn calculate_output_amount(amount_in: u64, reserve_in: u64, reserve_out: u64, fee: u64) -> Result<u64> { let amount_in_with_fee = (amount_in as u128).checked_mul(10000u128.checked_sub(fee as u128).ok_or(ErrorCode::MathOverflow)?).ok_or(ErrorCode::MathOverflow)?; let numerator = amount_in_with_fee.checked_mul(reserve_out as u128).ok_or(ErrorCode::MathOverflow)?; let denominator = (reserve_in as u128).checked_mul(10000).ok_or(ErrorCode::MathOverflow)?.checked_add(amount_in_with_fee).ok_or(ErrorCode::MathOverflow)?; Ok((numerator.checked_div(denominator).ok_or(ErrorCode::MathOverflow)?) as u64) } }",
        "vulnerabilities": [
            "Potential for small rounding errors in liquidity calculations",
            "Possible front-running attacks in swap transactions"
        ]
    },
    {
      "code": "use solana_program::{\n    account_info::{next_account_info, AccountInfo},\n    entrypoint::ProgramResult,\n    program::invoke_signed,\n    pubkey::Pubkey,\n    msg,\n};\n\npub fn process_instruction(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    instruction_data: &[u8],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let user_account = next_account_info(account_info_iter)?;\n    let external_contract = next_account_info(account_info_iter)?;\n\n    if !user_account.is_signer {\n        return Err(ProgramError::MissingRequiredSignature);\n    }\n\n    let (pda, bump_seed) = Pubkey::find_program_address(&[b\"escrow\"], program_id);\n    let seeds = &[b\"escrow\"&[bump_seed]];\n\n    msg!(\"Calling external contract\");\n    invoke_signed(\n        &instruction_data,\n        &[user_account.clone(), external_contract.clone()],\n        &[&seeds],\n    )?;\n\n    msg!(\"External call completed successfully\");\n    Ok(())\n}",
      "vulnerabilities": [
        "Blind call to external contract",
        "Lack of input validation",
        "Reentrancy attack",
        "Lack of access control"
      ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\ndeclare_id!(\"VoteSys111111111111111111111111111111111111\");\n\n#[program]\npub mod vulnerable_voting_system {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, voting_period: i64) -> Result<()> {\n        let voting_system = &mut ctx.accounts.voting_system;\n        voting_system.admin = ctx.accounts.admin.key();\n        voting_system.voting_period = voting_period;\n        voting_system.total_votes = 0;\n        Ok(())\n    }\n\n    pub fn create_proposal(ctx: Context<CreateProposal>, proposal_description: String) -> Result<()> {\n        let proposal = &mut ctx.accounts.proposal;\n        let voting_system = &ctx.accounts.voting_system;\n\n        proposal.description = proposal_description;\n        proposal.creator = ctx.accounts.creator.key();\n        proposal.yes_votes = 0;\n        proposal.no_votes = 0;\n        proposal.created_at = Clock::get()?.unix_timestamp;\n        proposal.voting_ends_at = proposal.created_at + voting_system.voting_period;\n\n        Ok(())\n    }\n\n    pub fn cast_vote(ctx: Context<CastVote>, vote: bool) -> Result<()> {\n        let proposal = &mut ctx.accounts.proposal;\n        let voter = &ctx.accounts.voter;\n\n        // Vulnerability 1: No check for voting period expiration\n        // This allows users to vote even after the voting period has ended\n\n        if vote {\n            proposal.yes_votes += 1;\n        } else {\n            proposal.no_votes += 1;\n        }\n\n        // Vulnerability 2: No prevention of double voting\n        // Users can vote multiple times on the same proposal\n\n        Ok(())\n    }\n\n    pub fn end_voting(ctx: Context<EndVoting>) -> Result<()> {\n        let proposal = &mut ctx.accounts.proposal;\n        let voting_system = &mut ctx.accounts.voting_system;\n\n        // Vulnerability 3: No check for admin privileges\n        // Any user can end the voting process, not just the admin\n\n        proposal.is_finalized = true;\n        voting_system.total_votes += proposal.yes_votes + proposal.no_votes;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = admin, space = 8 + 32 + 8 + 8)]\n    pub voting_system: Account<'info, VotingSystem>,\n    #[account(mut)]\n    pub admin: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct CreateProposal<'info> {\n    #[account(mut)]\n    pub voting_system: Account<'info, VotingSystem>,\n    #[account(init, payer = creator, space = 8 + 256 + 32 + 8 + 8 + 8 + 8 + 1)]\n    pub proposal: Account<'info, Proposal>,\n    #[account(mut)]\n    pub creator: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct CastVote<'info> {\n    #[account(mut)]\n    pub proposal: Account<'info, Proposal>,\n    pub voter: Signer<'info>,\n}\n\n#[derive(Accounts)]\npub struct EndVoting<'info> {\n    #[account(mut)]\n    pub voting_system: Account<'info, VotingSystem>,\n    #[account(mut)]\n    pub proposal: Account<'info, Proposal>,\n    pub user: Signer<'info>,\n}\n\n#[account]\npub struct VotingSystem {\n    pub admin: Pubkey,\n    pub voting_period: i64,\n    pub total_votes: u64,\n}\n\n#[account]\npub struct Proposal {\n    pub description: String,\n    pub creator: Pubkey,\n    pub yes_votes: u64,\n    pub no_votes: u64,\n    pub created_at: i64,\n    pub voting_ends_at: i64,\n    pub is_finalized: bool,\n}",
        "vulnerabilities": [
            "Voting period expiration: The cast_vote function allows users to vote even after the voting period has ended.",
            "No prevention of double voting: The cast_vote function doesn't prevent users from voting multiple times on the same proposal.",
            "No check for admin privileges in end_voting: Any user can call the end_voting function, not just the admin."
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\nmod vulnerable_lending {\n    use super::*;\n\n    pub fn initialize_pool(ctx: Context<InitializePool>, pool_bump: u8) -> Result<()> {\n        let pool = &mut ctx.accounts.pool;\n        pool.bump = pool_bump;\n        pool.total_deposits = 0;\n        pool.total_borrows = 0;\n        Ok(())\n    }\n\n    pub fn deposit(ctx: Context<Deposit>, amount: u64) -> Result<()> {\n        let pool = &mut ctx.accounts.pool;\n        let user = &mut ctx.accounts.user;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_account.to_account_info(),\n                    to: ctx.accounts.pool_token_account.to_account_info(),\n                    authority: user.to_account_info(),\n                },\n            ),\n            amount,\n        )?;\n\n        pool.total_deposits += amount;\n        user.deposited_amount += amount;\n\n        Ok(())\n    }\n\n    pub fn borrow(ctx: Context<Borrow>, amount: u64) -> Result<()> {\n        let pool = &mut ctx.accounts.pool;\n        let user = &mut ctx.accounts.user;\n\n        require!(amount <= pool.total_deposits - pool.total_borrows, LendingError::InsufficientFunds);\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.pool_token_account.to_account_info(),\n                    to: ctx.accounts.user_token_account.to_account_info(),\n                    authority: pool.to_account_info(),\n                },\n                &[&[b\"pool\".as_ref(), &[pool.bump]]],\n            ),\n            amount,\n        )?;\n\n        pool.total_borrows += amount;\n        user.borrowed_amount += amount;\n\n        Ok(())\n    }\n\n    pub fn repay(ctx: Context<Repay>, amount: u64) -> Result<()> {\n        let pool = &mut ctx.accounts.pool;\n        let user = &mut ctx.accounts.user;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_account.to_account_info(),\n                    to: ctx.accounts.pool_token_account.to_account_info(),\n                    authority: user.to_account_info(),\n                },\n            ),\n            amount,\n        )?;\n\n        pool.total_borrows -= amount;\n        user.borrowed_amount -= amount;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct InitializePool<'info> {\n    #[account(init, payer = user, space = 8 + 8 + 8 + 1, seeds = [b\"pool\"], bump)]\n    pub pool: Account<'info, Pool>,\n    #[account(mut)]\n    pub user: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Deposit<'info> {\n    #[account(mut)]\n    pub pool: Account<'info, Pool>,\n    #[account(mut)]\n    pub user: Account<'info, User>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_account: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct Borrow<'info> {\n    #[account(mut)]\n    pub pool: Account<'info, Pool>,\n    #[account(mut)]\n    pub user: Account<'info, User>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_account: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct Repay<'info> {\n    #[account(mut)]\n    pub pool: Account<'info, Pool>,\n    #[account(mut)]\n    pub user: Account<'info, User>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_account: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct Pool {\n    pub bump: u8,\n    pub total_deposits: u64,\n    pub total_borrows: u64,\n}\n\n#[account]\npub struct User {\n    pub deposited_amount: u64,\n    pub borrowed_amount: u64,\n}\n\n#[error_code]\npub enum LendingError {\n    #[msg(\"Insufficient funds in the pool\")]\n    InsufficientFunds,\n}",
        "vulnerabilities": [
          "Integer overflow risk in arithmetic operations",
          "Lack of access control in critical functions",
          "Missing checks for user's borrow limit"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\nmod vulnerable_staking {\n    use super::*;\n\n    pub fn initialize_pool(ctx: Context<InitializePool>, pool_bump: u8) -> Result<()> {\n        let pool = &mut ctx.accounts.pool;\n        pool.bump = pool_bump;\n        pool.total_staked = 0;\n        pool.reward_rate = 100; // 1% per day\n        Ok(())\n    }\n\n    pub fn stake(ctx: Context<Stake>, amount: u64) -> Result<()> {\n        let pool = &mut ctx.accounts.pool;\n        let user = &mut ctx.accounts.user;\n        let clock = Clock::get()?;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_account.to_account_info(),\n                    to: ctx.accounts.pool_token_account.to_account_info(),\n                    authority: user.to_account_info(),\n                },\n            ),\n            amount,\n        )?;\n\n        pool.total_staked += amount;\n        user.staked_amount += amount;\n        user.last_stake_timestamp = clock.unix_timestamp;\n\n        Ok(())\n    }\n\n    pub fn unstake(ctx: Context<Unstake>, amount: u64) -> Result<()> {\n        let pool = &mut ctx.accounts.pool;\n        let user = &mut ctx.accounts.user;\n        let clock = Clock::get()?;\n\n        require!(amount <= user.staked_amount, StakingError::InsufficientStake);\n\n        let time_staked = clock.unix_timestamp - user.last_stake_timestamp;\n        let reward = (amount * pool.reward_rate * time_staked as u64) / (100 * 24 * 60 * 60);\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.pool_token_account.to_account_info(),\n                    to: ctx.accounts.user_token_account.to_account_info(),\n                    authority: pool.to_account_info(),\n                },\n                &[&[b\"pool\".as_ref(), &[pool.bump]]],\n            ),\n            amount + reward,\n        )?;\n\n        pool.total_staked -= amount;\n        user.staked_amount -= amount;\n        user.last_stake_timestamp = clock.unix_timestamp;\n\n        Ok(())\n    }\n\n    pub fn update_reward_rate(ctx: Context<UpdateRewardRate>, new_rate: u64) -> Result<()> {\n        let pool = &mut ctx.accounts.pool;\n        pool.reward_rate = new_rate;\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct InitializePool<'info> {\n    #[account(init, payer = user, space = 8 + 8 + 8 + 1, seeds = [b\"pool\"], bump)]\n    pub pool: Account<'info, Pool>,\n    #[account(mut)]\n    pub user: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Stake<'info> {\n    #[account(mut)]\n    pub pool: Account<'info, Pool>,\n    #[account(mut)]\n    pub user: Account<'info, User>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_account: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct Unstake<'info> {\n    #[account(mut)]\n    pub pool: Account<'info, Pool>,\n    #[account(mut)]\n    pub user: Account<'info, User>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_account: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct UpdateRewardRate<'info> {\n    #[account(mut)]\n    pub pool: Account<'info, Pool>,\n    pub authority: Signer<'info>,\n}\n\n#[account]\npub struct Pool {\n    pub bump: u8,\n    pub total_staked: u64,\n    pub reward_rate: u64,\n}\n\n#[account]\npub struct User {\n    pub staked_amount: u64,\n    pub last_stake_timestamp: i64,\n}\n\n#[error_code]\npub enum StakingError {\n    #[msg(\"Insufficient staked amount\")]\n    InsufficientStake,\n}",
        "vulnerabilities": [
          "Potential for precision loss in reward calculation",
          "Lack of access control for updating reward rate",
          "Missing checks for maximum stake amount"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\nmod vulnerable_flashloan {\n    use super::*;\n\n    pub fn initialize_pool(ctx: Context<InitializePool>, pool_bump: u8) -> Result<()> {\n        let pool = &mut ctx.accounts.pool;\n        pool.bump = pool_bump;\n        pool.total_liquidity = 0;\n        pool.fee_percentage = 100; // 1% fee\n        Ok(())\n    }\n\n    pub fn deposit(ctx: Context<Deposit>, amount: u64) -> Result<()> {\n        let pool = &mut ctx.accounts.pool;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_account.to_account_info(),\n                    to: ctx.accounts.pool_token_account.to_account_info(),\n                    authority: ctx.accounts.user.to_account_info(),\n                },\n            ),\n            amount,\n        )?;\n\n        pool.total_liquidity += amount;\n\n        Ok(())\n    }\n\n    pub fn flashloan(ctx: Context<Flashloan>, amount: u64) -> Result<()> {\n        let pool = &ctx.accounts.pool;\n        require!(amount <= pool.total_liquidity, FlashloanError::InsufficientLiquidity);\n\n        // Transfer tokens to the borrower\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.pool_token_account.to_account_info(),\n                    to: ctx.accounts.borrower_token_account.to_account_info(),\n                    authority: pool.to_account_info(),\n                },\n                &[&[b\"pool\".as_ref(), &[pool.bump]]],\n            ),\n            amount,\n        )?;\n\n        // Call the borrower's callback function\n        ctx.accounts.borrower_program.flashloan_callback(amount)?;\n\n        // Calculate fee\n        let fee = amount.checked_mul(pool.fee_percentage).unwrap() / 10000;\n        let repay_amount = amount.checked_add(fee).unwrap();\n\n        // Repay the loan with fee\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.borrower_token_account.to_account_info(),\n                    to: ctx.accounts.pool_token_account.to_account_info(),\n                    authority: ctx.accounts.borrower.to_account_info(),\n                },\n            ),\n            repay_amount,\n        )?;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct InitializePool<'info> {\n    #[account(init, payer = user, space = 8 + 8 + 8 + 1, seeds = [b\"pool\"], bump)]\n    pub pool: Account<'info, Pool>,\n    #[account(mut)]\n    pub user: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Deposit<'info> {\n    #[account(mut)]\n    pub pool: Account<'info, Pool>,\n    pub user: Signer<'info>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_account: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct Flashloan<'info> {\n    #[account(mut)]\n    pub pool: Account<'info, Pool>,\n    pub borrower: Signer<'info>,\n    #[account(mut)]\n    pub borrower_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_account: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n    pub borrower_program: Program<'info, FlashloanCallback>,\n}\n\n#[account]\npub struct Pool {\n    pub bump: u8,\n    pub total_liquidity: u64,\n    pub fee_percentage: u64,\n}\n\n#[error_code]\npub enum FlashloanError {\n    #[msg(\"Insufficient liquidity in the pool\")]\n    InsufficientLiquidity,\n}\n\n#[interface]\npub trait FlashloanCallback {\n    fn flashloan_callback(&self, amount: u64) -> Result<()>;\n}",
        "vulnerabilities": [
            "Reentrancy vulnerability in flashloan function",
            "Lack of access control for initializing the pool",
            "Missing checks for maximum flashloan amount"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\nmod vulnerable_multisig_wallet {\n    use super::*;\n\n    pub fn create_wallet(ctx: Context<CreateWallet>, owners: Vec<Pubkey>, threshold: u8) -> Result<()> {\n        let wallet = &mut ctx.accounts.wallet;\n        wallet.owners = owners;\n        wallet.threshold = threshold;\n        wallet.nonce = 0;\n        Ok(())\n    }\n\n    pub fn propose_transaction(\n        ctx: Context<ProposeTransaction>,\n        to: Pubkey,\n        amount: u64,\n        data: Vec<u8>,\n    ) -> Result<()> {\n        let wallet = &mut ctx.accounts.wallet;\n        let transaction = &mut ctx.accounts.transaction;\n\n        transaction.to = to;\n        transaction.amount = amount;\n        transaction.data = data;\n        transaction.owner_set_seqno = wallet.nonce;\n        transaction.signatures = vec![false; wallet.owners.len()];\n        transaction.executed = false;\n\n        wallet.nonce += 1;\n\n        Ok(())\n    }\n\n    pub fn approve(ctx: Context<Approve>) -> Result<()> {\n        let wallet = &ctx.accounts.wallet;\n        let transaction = &mut ctx.accounts.transaction;\n        let owner_index = wallet\n            .owners\n            .iter()\n            .position(|a| a == ctx.accounts.owner.key)\n            .unwrap();\n\n        transaction.signatures[owner_index] = true;\n\n        Ok(())\n    }\n\n    pub fn execute_transaction(ctx: Context<ExecuteTransaction>) -> Result<()> {\n        let wallet = &ctx.accounts.wallet;\n        let transaction = &mut ctx.accounts.transaction;\n\n        require!(!transaction.executed, MultisigError::AlreadyExecuted);\n\n        let sig_count = transaction\n            .signatures\n            .iter()\n            .filter(|&approved| *approved)\n            .count() as u8;\n\n        require!(sig_count >= wallet.threshold, MultisigError::NotEnoughSignatures);\n\n        transaction.executed = true;\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.wallet_token_account.to_account_info(),\n                    to: ctx.accounts.to_token_account.to_account_info(),\n                    authority: wallet.to_account_info(),\n                },\n                &[&[b\"wallet\".as_ref(), &[*ctx.bumps.get(\"wallet\").unwrap()]]],\n            ),\n            transaction.amount,\n        )?;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct CreateWallet<'info> {\n    #[account(init, payer = user, space = 8 + 32 * 10 + 1 + 8, seeds = [b\"wallet\"], bump)]\n    pub wallet: Account<'info, Wallet>,\n    #[account(mut)]\n    pub user: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct ProposeTransaction<'info> {\n    #[account(mut)]\n    pub wallet: Account<'info, Wallet>,\n    #[account(init, payer = proposer, space = 8 + 32 + 8 + 4 + 256 + 8 + 10 + 1)]\n    pub transaction: Account<'info, Transaction>,\n    #[account(mut)]\n    pub proposer: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Approve<'info> {\n    pub wallet: Account<'info, Wallet>,\n    #[account(mut)]\n    pub transaction: Account<'info, Transaction>,\n    pub owner: Signer<'info>,\n}\n\n#[derive(Accounts)]\npub struct ExecuteTransaction<'info> {\n    #[account(mut)]\n    pub wallet: Account<'info, Wallet>,\n    #[account(mut)]\n    pub transaction: Account<'info, Transaction>,\n    #[account(mut)]\n    pub wallet_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub to_token_account: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct Wallet {\n    pub owners: Vec<Pubkey>,\n    pub threshold: u8,\n    pub nonce: u64,\n}\n\n#[account]\npub struct Transaction {\n    pub to: Pubkey,\n    pub amount: u64,\n    pub data: Vec<u8>,\n    pub owner_set_seqno: u64,\n    pub signatures: Vec<bool>,\n    pub executed: bool,\n}\n\n#[error_code]\npub enum MultisigError {\n    #[msg(\"Transaction has already been executed\")]\n    AlreadyExecuted,\n    #[msg(\"Not enough signatures to execute transaction\")]\n    NotEnoughSignatures,\n}",
        "vulnerabilities": [
            "Lack of proper access control in approve function",
            "Missing check for transaction expiration",
            "Potential for transaction ordering manipulation"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\n\n#[program]\npub mod secure_voting {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, candidates: Vec<String>, end_time: i64) -> Result<()> {\n        let voting = &mut ctx.accounts.voting;\n        require!(candidates.len() > 0, VotingError::NoCandidates);\n        require!(end_time > clock::Clock::get()?.unix_timestamp, VotingError::InvalidEndTime);\n        voting.candidates = candidates;\n        voting.end_time = end_time;\n        voting.votes = vec![0; voting.candidates.len()];\n        Ok(())\n    }\n\n    pub fn vote(ctx: Context<Vote>, candidate_index: u64) -> Result<()> {\n        let voting = &mut ctx.accounts.voting;\n        require!(clock::Clock::get()?.unix_timestamp <= voting.end_time, VotingError::VotingClosed);\n        require!(candidate_index < voting.candidates.len() as u64, VotingError::InvalidCandidate);\n        voting.votes[candidate_index as usize] += 1;\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 8 * 10 + 8)]\n    pub voting: Account<'info, Voting>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Vote<'info> {\n    #[account(mut)]\n    pub voting: Account<'info, Voting>,\n    #[account(mut)]\n    pub voter: Signer<'info>,\n}\n\n#[account]\npub struct Voting {\n    pub candidates: Vec<String>,\n    pub votes: Vec<u64>,\n    pub end_time: i64,\n}\n\n#[error_code]\npub enum VotingError {\n    #[msg(\"No candidates provided\")]\n    NoCandidates,\n    #[msg(\"Invalid end time\")]\n    InvalidEndTime,\n    #[msg(\"Voting is closed\")]\n    VotingClosed,\n    #[msg(\"Invalid candidate\")]\n    InvalidCandidate,\n}",
        "vulnerabilities": []
    },    
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\nmod vulnerable_dao {\n    use super::*;\n\n    pub fn initialize_dao(ctx: Context<InitializeDao>, name: String, quorum: u64) -> Result<()> {\n        let dao = &mut ctx.accounts.dao;\n        dao.name = name;\n        dao.quorum = quorum;\n        dao.proposal_count = 0;\n        Ok(())\n    }\n\n    pub fn create_proposal(ctx: Context<CreateProposal>, description: String, amount: u64) -> Result<()> {\n        let dao = &mut ctx.accounts.dao;\n        let proposal = &mut ctx.accounts.proposal;\n\n        proposal.id = dao.proposal_count;\n        proposal.description = description;\n        proposal.amount = amount;\n        proposal.yes_votes = 0;\n        proposal.no_votes = 0;\n        proposal.executed = false;\n\n        dao.proposal_count += 1;\n\n        Ok(())\n    }\n\n    pub fn vote(ctx: Context<Vote>, vote: bool) -> Result<()> {\n        let dao = &ctx.accounts.dao;\n        let proposal = &mut ctx.accounts.proposal;\n        let voter = &ctx.accounts.voter;\n\n        let token_balance = ctx.accounts.voter_token_account.amount;\n\n        if vote {\n            proposal.yes_votes += token_balance;\n        } else {\n            proposal.no_votes += token_balance;\n        }\n\n        Ok(())\n    }\n\n    pub fn execute_proposal(ctx: Context<ExecuteProposal>) -> Result<()> {\n        let dao = &ctx.accounts.dao;\n        let proposal = &mut ctx.accounts.proposal;\n\n        require!(!proposal.executed, DaoError::AlreadyExecuted);\n        require!(proposal.yes_votes > proposal.no_votes, DaoError::ProposalRejected);\n        require!(proposal.yes_votes >= dao.quorum, DaoError::QuorumNotReached);\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.dao_token_account.to_account_info(),\n                    to: ctx.accounts.recipient_token_account.to_account_info(),\n                    authority: dao.to_account_info(),\n                },\n                &[&[b\"dao\".as_ref(), &[*ctx.bumps.get(\"dao\").unwrap()]]],\n            ),\n            proposal.amount,\n        )?;\n\n        proposal.executed = true;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct InitializeDao<'info> {\n    #[account(init, payer = creator, space = 8 + 32 + 8 + 8, seeds = [b\"dao\"], bump)]\n    pub dao: Account<'info, Dao>,\n    #[account(mut)]\n    pub creator: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct CreateProposal<'info> {\n    #[account(mut)]\n    pub dao: Account<'info, Dao>,\n    #[account(init, payer = proposer, space = 8 + 8 + 256 + 8 + 8 + 8 + 1)]\n    pub proposal: Account<'info, Proposal>,\n    #[account(mut)]\n    pub proposer: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Vote<'info> {\n    pub dao: Account<'info, Dao>,\n    #[account(mut)]\n    pub proposal: Account<'info, Proposal>,\n    pub voter: Signer<'info>,\n    pub voter_token_account: Account<'info, TokenAccount>,\n}\n\n#[derive(Accounts)]\npub struct ExecuteProposal<'info> {\n    #[account(mut)]\n    pub dao: Account<'info, Dao>,\n    #[account(mut)]\n    pub proposal: Account<'info, Proposal>,\n    #[account(mut)]\n    pub dao_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub recipient_token_account: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct Dao {\n    pub name: String,\n    pub quorum: u64,\n    pub proposal_count: u64,\n}\n\n#[account]\npub struct Proposal {\n    pub id: u64,\n    pub description: String,\n    pub amount: u64,\n    pub yes_votes: u64,\n    pub no_votes: u64,\n    pub executed: bool,\n}\n\n#[error_code]\npub enum DaoError {\n    #[msg(\"Proposal has already been executed\")]\n    AlreadyExecuted,\n    #[msg(\"Proposal was rejected\")]\n    ProposalRejected,\n    #[msg(\"Quorum not reached\")]\n    QuorumNotReached,\n}",
        "vulnerabilities": [
          "Lack of double voting prevention",
          "Missing time lock for proposal execution",
          "Potential for flash loan attacks in voting"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\npub mod vulnerable_vesting {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, release_time: i64) -> Result<()> {\n        let vesting = &mut ctx.accounts.vesting;\n        vesting.authority = ctx.accounts.authority.key();\n        vesting.release_time = release_time;\n        Ok(())\n    }\n\n    pub fn deposit(ctx: Context<Deposit>, amount: u64) -> Result<()> {\n        let vesting = &mut ctx.accounts.vesting;\n        let user = &ctx.accounts.user;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_account.to_account_info(),\n                    to: ctx.accounts.vesting_token_account.to_account_info(),\n                    authority: user.to_account_info(),\n                },\n            ),\n            amount,\n        )?;\n\n        vesting.total_deposits += amount;\n        vesting.user_deposits.insert(user.key(), amount);\n\n        Ok(())\n    }\n\n    pub fn withdraw(ctx: Context<Withdraw>) -> Result<()> {\n        let vesting = &mut ctx.accounts.vesting;\n        let user = &ctx.accounts.user;\n        let user_deposit = *vesting.user_deposits.get(&user.key()).unwrap_or(&0);\n\n        require!(Clock::get().unwrap().unix_timestamp >= vesting.release_time, ErrorCode::ReleaseTimeNotReached);\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.vesting_token_account.to_account_info(),\n                    to: ctx.accounts.user_token_account.to_account_info(),\n                    authority: vesting.to_account_info(),\n                },\n                &[&[&vesting.authority.to_bytes(), &[*ctx.bumps.get(\"vesting\").unwrap()]]],\n            ),\n            user_deposit,\n        )?;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 8 + 64 + 64)]\n    pub vesting: Account<'info, Vesting>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Deposit<'info> {\n    #[account(mut)]\n    pub vesting: Account<'info, Vesting>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub vesting_token_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct Withdraw<'info> {\n    #[account(mut)]\n    pub vesting: Account<'info, Vesting>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub vesting_token_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct Vesting {\n    pub authority: Pubkey,\n    pub release_time: i64,\n    pub total_deposits: u64,\n    pub user_deposits: std::collections::HashMap<Pubkey, u64>,\n}",
        "vulnerabilities": [
            "No penalty for early withdrawal attempts",
            "Possible overflow in deposit amounts",
            "Missing handling of partial withdrawals"
        ]
    },    
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\npub mod vulnerable_exchange {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, fee_rate: u64) -> Result<()> {\n        let exchange = &mut ctx.accounts.exchange;\n        exchange.authority = ctx.accounts.authority.key();\n        exchange.fee_rate = fee_rate;\n        Ok(())\n    }\n\n    pub fn create_order(ctx: Context<CreateOrder>, amount: u64, price: u64) -> Result<()> {\n        let exchange = &mut ctx.accounts.exchange;\n        let order = &mut ctx.accounts.order;\n        let user = &ctx.accounts.user;\n\n        order.owner = user.key();\n        order.amount = amount;\n        order.price = price;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_account.to_account_info(),\n                    to: ctx.accounts.exchange_token_account.to_account_info(),\n                    authority: user.to_account_info(),\n                },\n            ),\n            amount,\n        )?;\n\n        exchange.orders.push(*order.to_account_info().key);\n        Ok(())\n    }\n\n    pub fn execute_order(ctx: Context<ExecuteOrder>) -> Result<()> {\n        let exchange = &mut ctx.accounts.exchange;\n        let order = &ctx.accounts.order;\n        let user = &ctx.accounts.user;\n\n        require!(order.amount > 0, ErrorCode::InvalidOrder);\n\n        let total_amount = order.amount * order.price;\n        let fee = total_amount * exchange.fee_rate / 10000;\n        let transfer_amount = total_amount - fee;\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.exchange_token_account.to_account_info(),\n                    to: ctx.accounts.user_token_account.to_account_info(),\n                    authority: exchange.to_account_info(),\n                },\n                &[&[&exchange.authority.to_bytes(), &[*ctx.bumps.get(\"exchange\").unwrap()]]],\n            ),\n            transfer_amount,\n        )?;\n\n        exchange.fees_collected += fee;\n        exchange.orders.retain(|&x| x != *order.to_account_info().key);\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 8 + 64 + 64)]\n    pub exchange: Account<'info, Exchange>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct CreateOrder<'info> {\n    #[account(mut)]\n    pub exchange: Account<'info, Exchange>,\n    #[account(init, payer = user, space = 8 + 32 + 8 + 8)]\n    pub order: Account<'info, Order>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub exchange_token_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct ExecuteOrder<'info> {\n    #[account(mut)]\n    pub exchange: Account<'info, Exchange>,\n    #[account(mut, close = user)]\n    pub order: Account<'info, Order>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub exchange_token_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct Exchange {\n    pub authority: Pubkey,\n    pub fee_rate: u64,\n    pub fees_collected: u64,\n    pub orders: Vec<Pubkey>,\n}\n\n#[account]\npub struct Order {\n    pub owner: Pubkey,\n    pub amount: u64,\n    pub price: u64,\n}\n\n#[error_code]\npub enum ErrorCode {\n    #[msg(\"Invalid order\")]\n    InvalidOrder,\n}",
        "vulnerabilities": [
            "Lack of access control in execute_order function",
            "Integer overflow vulnerability in fee calculation",
            "Missing checks for order cancellation and refunds"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\n\n#[program]\npub mod charity_donation {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, target_amount: u64, deadline: i64) -> Result<()> {\n        let campaign = &mut ctx.accounts.campaign;\n        require!(target_amount > 0, CharityError::InvalidTargetAmount);\n        require!(deadline > clock::Clock::get()?.unix_timestamp, CharityError::InvalidDeadline);\n        campaign.target_amount = target_amount;\n        campaign.deadline = deadline;\n        campaign.collected_amount = 0;\n        Ok(())\n    }\n\n    pub fn donate(ctx: Context<Donate>, amount: u64) -> Result<()> {\n        let campaign = &mut ctx.accounts.campaign;\n        require!(clock::Clock::get()?.unix_timestamp <= campaign.deadline, CharityError::CampaignEnded);\n        campaign.collected_amount = campaign.collected_amount.checked_add(amount).ok_or(CharityError::Overflow)?;\n        Ok(())\n    }\n\n    pub fn withdraw(ctx: Context<Withdraw>, amount: u64) -> Result<()> {\n        let campaign = &mut ctx.accounts.campaign;\n        require!(clock::Clock::get()?.unix_timestamp > campaign.deadline, CharityError::CampaignActive);\n        require!(campaign.collected_amount >= campaign.target_amount, CharityError::TargetNotMet);\n        require!(ctx.accounts.recipient.key() == ctx.accounts.authority.key(), CharityError::Unauthorized);\n        campaign.collected_amount = campaign.collected_amount.checked_sub(amount).ok_or(CharityError::Underflow)?;\n        **ctx.accounts.recipient.to_account_info().try_borrow_mut_lamports()? += amount;\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 8 + 8 + 8)]\n    pub campaign: Account<'info, Campaign>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Donate<'info> {\n    #[account(mut)]\n    pub campaign: Account<'info, Campaign>,\n    pub contributor: Signer<'info>,\n}\n\n#[derive(Accounts)]\npub struct Withdraw<'info> {\n    #[account(mut)]\n    pub campaign: Account<'info, Campaign>,\n    #[account(mut)]\n    pub recipient: AccountInfo<'info>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n}\n\n#[account]\npub struct Campaign {\n    pub target_amount: u64,\n    pub collected_amount: u64,\n    pub deadline: i64,\n}\n\n#[error_code]\npub enum CharityError {\n    #[msg(\"Invalid target amount\")]\n    InvalidTargetAmount,\n    #[msg(\"Invalid deadline\")]\n    InvalidDeadline,\n    #[msg(\"Campaign has ended\")]\n    CampaignEnded,\n    #[msg(\"Target amount not met\")]\n    TargetNotMet,\n    #[msg(\"Campaign is still active\")]\n    CampaignActive,\n    #[msg(\"Unauthorized access\")]\n    Unauthorized,\n    #[msg(\"Overflow occurred\")]\n    Overflow,\n    #[msg(\"Underflow occurred\")]\n    Underflow,\n}",
        "vulnerabilities": []
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\npub mod vulnerable_escrow {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, timeout: i64) -> Result<()> {\n        let escrow = &mut ctx.accounts.escrow;\n        escrow.authority = ctx.accounts.authority.key();\n        escrow.timeout = timeout;\n        Ok(())\n    }\n\n    pub fn deposit(ctx: Context<Deposit>, amount: u64) -> Result<()> {\n        let escrow = &mut ctx.accounts.escrow;\n        let user = &ctx.accounts.user;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_account.to_account_info(),\n                    to: ctx.accounts.escrow_token_account.to_account_info(),\n                    authority: user.to_account_info(),\n                },\n            ),\n            amount,\n        )?;\n\n        escrow.total_deposits += amount;\n        escrow.user_deposits.insert(user.key(), amount);\n\n        Ok(())\n    }\n\n    pub fn release(ctx: Context<Release>) -> Result<()> {\n        let escrow = &mut ctx.accounts.escrow;\n        let recipient = &ctx.accounts.recipient;\n        let amount = escrow.total_deposits;\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.escrow_token_account.to_account_info(),\n                    to: ctx.accounts.recipient_token_account.to_account_info(),\n                    authority: escrow.to_account_info(),\n                },\n                &[&[&escrow.authority.to_bytes(), &[*ctx.bumps.get(\"escrow\").unwrap()]]],\n            ),\n            amount,\n        )?;\n\n        Ok(())\n    }\n\n    pub fn refund(ctx: Context<Refund>) -> Result<()> {\n        let escrow = &mut ctx.accounts.escrow;\n        let user = &ctx.accounts.user;\n        let amount = *escrow.user_deposits.get(&user.key()).unwrap_or(&0);\n\n        require!(Clock::get().unwrap().unix_timestamp >= escrow.timeout, ErrorCode::TimeoutNotReached);\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.escrow_token_account.to_account_info(),\n                    to: ctx.accounts.user_token_account.to_account_info(),\n                    authority: escrow.to_account_info(),\n                },\n                &[&[&escrow.authority.to_bytes(), &[*ctx.bumps.get(\"escrow\").unwrap()]]],\n            ),\n            amount,\n        )?;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 8 + 64 + 64)]\n    pub escrow: Account<'info, Escrow>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Deposit<'info> {\n    #[account(mut)]\n    pub escrow: Account<'info, Escrow>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub escrow_token_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct Release<'info> {\n    #[account(mut)]\n    pub escrow: Account<'info, Escrow>,\n    #[account(mut)]\n    pub recipient_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub escrow_token_account: Account<'info, TokenAccount>,\n    pub authority: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct Refund<'info> {\n    #[account(mut)]\n    pub escrow: Account<'info, Escrow>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub escrow_token_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct Escrow {\n    pub authority: Pubkey,\n    pub timeout: i64,\n    pub total_deposits: u64,\n    pub user_deposits: std::collections::HashMap<Pubkey, u64>,\n}",
        "vulnerabilities": [
            "Absence of validation for authorized token releases, potentially allowing unauthorized or excessive withdrawals",
            "Unprotected arithmetic in deposit handling, risking integer overflow and incorrect balance tracking",
            "Lack of partial refund mechanism, potentially trapping user funds in case of incomplete transactions"
        ]
    },    
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\nmod vulnerable_flash_loan {\n    use super::*;\n\n    pub fn initialize_pool(ctx: Context<InitializePool>, pool_seed: u64) -> Result<()> {\n        let pool = &mut ctx.accounts.pool;\n        pool.authority = ctx.accounts.authority.key();\n        pool.token_mint = ctx.accounts.token_mint.key();\n        pool.total_liquidity = 0;\n        pool.seed = pool_seed;\n        Ok(())\n    }\n\n    pub fn deposit(ctx: Context<Deposit>, amount: u64) -> Result<()> {\n        let pool = &mut ctx.accounts.pool;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_account.to_account_info(),\n                    to: ctx.accounts.pool_token_account.to_account_info(),\n                    authority: ctx.accounts.user.to_account_info(),\n                },\n            ),\n            amount,\n        )?;\n\n        pool.total_liquidity += amount;\n\n        Ok(())\n    }\n\n    pub fn flash_loan(ctx: Context<FlashLoan>, amount: u64) -> Result<()> {\n        let pool = &ctx.accounts.pool;\n        require!(amount <= pool.total_liquidity, FlashLoanError::InsufficientLiquidity);\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.pool_token_account.to_account_info(),\n                    to: ctx.accounts.borrower_token_account.to_account_info(),\n                    authority: pool.to_account_info(),\n                },\n                &[&[b\"pool\", &pool.seed.to_le_bytes(), &[*ctx.bumps.get(\"pool\").unwrap()]]],\n            ),\n            amount,\n        )?;\n\n        // Borrower's logic goes here\n        // ...\n\n        // Repay loan\n        let fee = amount / 1000; // 0.1% fee\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.borrower_token_account.to_account_info(),\n                    to: ctx.accounts.pool_token_account.to_account_info(),\n                    authority: ctx.accounts.borrower.to_account_info(),\n                },\n            ),\n            amount + fee,\n        )?;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct InitializePool<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 32 + 8 + 8, seeds = [b\"pool\", pool_seed.to_le_bytes().as_ref()], bump)]\n    pub pool: Account<'info, FlashLoanPool>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub token_mint: Account<'info, Token>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Deposit<'info> {\n    #[account(mut)]\n    pub pool: Account<'info, FlashLoanPool>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct FlashLoan<'info> {\n    #[account(mut)]\n    pub pool: Account<'info, FlashLoanPool>,\n    #[account(mut)]\n    pub pool_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub borrower_token_account: Account<'info, TokenAccount>,\n    pub borrower: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct FlashLoanPool {\n    pub authority: Pubkey,\n    pub token_mint: Pubkey,\n    pub total_liquidity: u64,\n    pub seed: u64,\n}\n\n#[error_code]\npub enum FlashLoanError {\n    #[msg(\"Insufficient liquidity in the pool\")]\n    InsufficientLiquidity,\n}",
        "vulnerabilities": [
            "Missing reentrancy guards in flash loan function, exposing contract to potential recursive calls and fund drainage",
            "Absence of borrower contract validation, allowing malicious contracts to exploit flash loan functionality",
            "Inadequate access control for critical operations, risking unauthorized modifications to contract state"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\npub mod vulnerable_staking {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, reward_rate: u64) -> Result<()> {\n        let staking_pool = &mut ctx.accounts.staking_pool;\n        staking_pool.authority = ctx.accounts.authority.key();\n        staking_pool.reward_rate = reward_rate;\n        Ok(())\n    }\n\n    pub fn stake(ctx: Context<Stake>, amount: u64) -> Result<()> {\n        let staking_pool = &mut ctx.accounts.staking_pool;\n        let user = &ctx.accounts.user;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_account.to_account_info(),\n                    to: ctx.accounts.pool_token_account.to_account_info(),\n                    authority: user.to_account_info(),\n                },\n            ),\n            amount,\n        )?;\n\n        staking_pool.total_staked += amount;\n        staking_pool.user_stakes.insert(user.key(), amount);\n\n        Ok(())\n    }\n\n    pub fn claim_rewards(ctx: Context<ClaimRewards>) -> Result<()> {\n        let staking_pool = &ctx.accounts.staking_pool;\n        let user = &ctx.accounts.user;\n\n        let stake_amount = staking_pool.user_stakes.get(&user.key()).copied().unwrap_or(0);\n        let reward = stake_amount * staking_pool.reward_rate;\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.pool_token_account.to_account_info(),\n                    to: ctx.accounts.user_token_account.to_account_info(),\n                    authority: staking_pool.to_account_info(),\n                },\n                &[&[&staking_pool.authority.to_bytes(), &[*ctx.bumps.get(\"staking_pool\").unwrap()]]],\n            ),\n            reward,\n        )?;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 8 + 64 + 64)]\n    pub staking_pool: Account<'info, StakingPool>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Stake<'info> {\n    #[account(mut)]\n    pub staking_pool: Account<'info, StakingPool>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct ClaimRewards<'info> {\n    #[account(mut)]\n    pub staking_pool: Account<'info, StakingPool>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct StakingPool {\n    pub authority: Pubkey,\n    pub reward_rate: u64,\n    pub total_staked: u64,\n    pub user_stakes: std::collections::HashMap<Pubkey, u64>,\n}",
        "vulnerabilities": [
            "Unprotected state changes in stake and claim functions, exposing contract to reentrancy attacks and potential fund loss",
            "Insufficient validation of reward rates, potentially leading to economic imbalances or contract insolvency",
            "Unprotected arithmetic in reward calculations, risking integer overflow and incorrect reward distributions"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\npub mod vulnerable_auction {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, starting_price: u64) -> Result<()> {\n        let auction = &mut ctx.accounts.auction;\n        auction.authority = ctx.accounts.authority.key();\n        auction.highest_bid = starting_price;\n        auction.ended = false;\n        Ok(())\n    }\n\n    pub fn bid(ctx: Context<Bid>, bid_amount: u64) -> Result<()> {\n        let auction = &mut ctx.accounts.auction;\n        let user = &ctx.accounts.user;\n\n        require!(bid_amount > auction.highest_bid, ErrorCode::BidTooLow);\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_account.to_account_info(),\n                    to: ctx.accounts.auction_token_account.to_account_info(),\n                    authority: user.to_account_info(),\n                },\n            ),\n            bid_amount,\n        )?;\n\n        auction.highest_bid = bid_amount;\n        auction.highest_bidder = user.key();\n\n        Ok(())\n    }\n\n    pub fn end_auction(ctx: Context<EndAuction>) -> Result<()> {\n        let auction = &mut ctx.accounts.auction;\n\n        require!(!auction.ended, ErrorCode::AuctionAlreadyEnded);\n\n        auction.ended = true;\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.auction_token_account.to_account_info(),\n                    to: ctx.accounts.authority_token_account.to_account_info(),\n                    authority: auction.to_account_info(),\n                },\n                &[&[&auction.authority.to_bytes(), &[*ctx.bumps.get(\"auction\").unwrap()]]],\n            ),\n            auction.highest_bid,\n        )?;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 8 + 32 + 1)]\n    pub auction: Account<'info, Auction>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Bid<'info> {\n    #[account(mut)]\n    pub auction: Account<'info, Auction>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub auction_token_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct EndAuction<'info> {\n    #[account(mut)]\n    pub auction: Account<'info, Auction>,\n    #[account(mut)]\n    pub auction_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub authority_token_account: Account<'info, TokenAccount>,\n    pub authority: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct Auction {\n    pub authority: Pubkey,\n    pub highest_bid: u64,\n    pub highest_bidder: Pubkey,\n    pub ended: bool,\n}", 
        "vulnerabilities": [
            "Lack of refund mechanism for outbid participants, potentially leading to locked funds and decreased participation",
            "Unrestricted access to auction termination function, allowing premature or malicious ending of auctions",
            "Missing validation of auction end time, risking early termination or indefinite continuation of auctions"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\npub mod vulnerable_exchange {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, fee_rate: u64) -> Result<()> {\n        let exchange = &mut ctx.accounts.exchange;\n        exchange.authority = ctx.accounts.authority.key();\n        exchange.fee_rate = fee_rate;\n        Ok(())\n    }\n\n    pub fn exchange_tokens(ctx: Context<ExchangeTokens>, amount: u64) -> Result<()> {\n        let exchange = &ctx.accounts.exchange;\n        let user = &ctx.accounts.user;\n\n        let fee = amount * exchange.fee_rate / 100;\n        let amount_after_fee = amount - fee;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_account.to_account_info(),\n                    to: ctx.accounts.exchange_token_account.to_account_info(),\n                    authority: user.to_account_info(),\n                },\n            ),\n            amount,\n        )?;\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.exchange_token_account.to_account_info(),\n                    to: ctx.accounts.user_token_account.to_account_info(),\n                    authority: exchange.to_account_info(),\n                },\n                &[&[&exchange.authority.to_bytes(), &[*ctx.bumps.get(\"exchange\").unwrap()]]],\n            ),\n            amount_after_fee,\n        )?;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 8)]\n    pub exchange: Account<'info, Exchange>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct ExchangeTokens<'info> {\n    #[account(mut)]\n    pub exchange: Account<'info, Exchange>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub exchange_token_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct Exchange {\n    pub authority: Pubkey,\n    pub fee_rate: u64,\n}",
        "vulnerabilities": [
            "Static fee structure, potentially leading to suboptimal pricing during varying market conditions",
            "Absence of slippage protection, exposing users to potential value loss in volatile markets",
            "Uncapped fee rates, risking excessive charges and potential economic attacks"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\npub mod vulnerable_voting {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {\n        let voting_system = &mut ctx.accounts.voting_system;\n        voting_system.authority = ctx.accounts.authority.key();\n        voting_system.total_votes = 0;\n        Ok(())\n    }\n\n    pub fn vote(ctx: Context<Vote>, candidate: Pubkey) -> Result<()> {\n        let voting_system = &mut ctx.accounts.voting_system;\n        let user = &ctx.accounts.user;\n\n        require!(voting_system.voters.insert(user.key()), ErrorCode::AlreadyVoted);\n\n        voting_system.total_votes += 1;\n        let votes = voting_system.votes.entry(candidate).or_insert(0);\n        *votes += 1;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 8 + 64)]\n    pub voting_system: Account<'info, VotingSystem>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Vote<'info> {\n    #[account(mut)]\n    pub voting_system: Account<'info, VotingSystem>,\n    pub user: Signer<'info>,\n}\n\n#[account]\npub struct VotingSystem {\n    pub authority: Pubkey,\n    pub total_votes: u64,\n    pub votes: std::collections::HashMap<Pubkey, u64>,\n    pub voters: std::collections::HashSet<Pubkey>,\n}",
        "vulnerabilities": [
            "Lack of safeguards against duplicate voting, potentially allowing users to inflate their voting power",
            "Insufficient validation of candidate eligibility, risking inclusion of invalid or malicious candidates",
            "Absence of per-user voting limits, potentially leading to centralization of voting power"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\npub mod vulnerable_lottery {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, ticket_price: u64) -> Result<()> {\n        let lottery = &mut ctx.accounts.lottery;\n        lottery.authority = ctx.accounts.authority.key();\n        lottery.ticket_price = ticket_price;\n        Ok(())\n    }\n\n    pub fn buy_ticket(ctx: Context<BuyTicket>) -> Result<()> {\n        let lottery = &mut ctx.accounts.lottery;\n        let user = &ctx.accounts.user;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_account.to_account_info(),\n                    to: ctx.accounts.lottery_token_account.to_account_info(),\n                    authority: user.to_account_info(),\n                },\n            ),\n            lottery.ticket_price,\n        )?;\n\n        lottery.participants.push(user.key());\n\n        Ok(())\n    }\n\n    pub fn draw_winner(ctx: Context<DrawWinner>) -> Result<()> {\n        let lottery = &mut ctx.accounts.lottery;\n        let winner_index = (Clock::get().unwrap().unix_timestamp as usize) % lottery.participants.len();\n        let winner = lottery.participants[winner_index];\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.lottery_token_account.to_account_info(),\n                    to: ctx.accounts.winner_token_account.to_account_info(),\n                    authority: lottery.to_account_info(),\n                },\n                &[&[&lottery.authority.to_bytes(), &[*ctx.bumps.get(\"lottery\").unwrap()]]],\n            ),\n            ctx.accounts.lottery_token_account.amount,\n        )?;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 8 + 64)]\n    pub lottery: Account<'info, Lottery>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct BuyTicket<'info> {\n    #[account(mut)]\n    pub lottery: Account<'info, Lottery>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub lottery_token_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct DrawWinner<'info> {\n    #[account(mut)]\n    pub lottery: Account<'info, Lottery>,\n    #[account(mut)]\n    pub winner_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub lottery_token_account: Account<'info, TokenAccount>,\n    pub authority: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct Lottery {\n    pub authority: Pubkey,\n    pub ticket_price: u64,\n    pub participants: Vec<Pubkey>,\n}",
        "vulnerabilities": [
            "Use of predictable on-chain data for randomness, making winner selection manipulable by miners or users",
            "Unbounded ticket purchases per user, risking lottery manipulation and unfair advantage to wealthy participants"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\npub mod vulnerable_lending {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, interest_rate: u64) -> Result<()> {\n        let lending = &mut ctx.accounts.lending;\n        lending.authority = ctx.accounts.authority.key();\n        lending.interest_rate = interest_rate;\n        Ok(())\n    }\n\n    pub fn lend(ctx: Context<Lend>, amount: u64) -> Result<()> {\n        let lending = &mut ctx.accounts.lending;\n        let user = &ctx.accounts.user;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_account.to_account_info(),\n                    to: ctx.accounts.lending_token_account.to_account_info(),\n                    authority: user.to_account_info(),\n                },\n            ),\n            amount,\n        )?;\n\n        lending.total_lent += amount;\n        lending.user_loans.insert(user.key(), amount);\n\n        Ok(())\n    }\n\n    pub fn repay(ctx: Context<Repay>, amount: u64) -> Result<()> {\n        let lending = &mut ctx.accounts.lending;\n        let user = &ctx.accounts.user;\n        let user_loan = *lending.user_loans.get(&user.key()).unwrap_or(&0);\n\n        require!(user_loan >= amount, ErrorCode::InsufficientLoan);\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.lending_token_account.to_account_info(),\n                    to: ctx.accounts.user_token_account.to_account_info(),\n                    authority: lending.to_account_info(),\n                },\n                &[&[&lending.authority.to_bytes(), &[*ctx.bumps.get(\"lending\").unwrap()]]],\n            ),\n            amount,\n        )?;\n\n        lending.total_lent -= amount;\n        lending.user_loans.insert(user.key(), user_loan - amount);\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 8 + 64 + 64)]\n    pub lending: Account<'info, Lending>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Lend<'info> {\n    #[account(mut)]\n    pub lending: Account<'info, Lending>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub lending_token_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct Repay<'info> {\n    #[account(mut)]\n    pub lending: Account<'info, Lending>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub lending_token_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct Lending {\n    pub authority: Pubkey,\n    pub interest_rate: u64,\n    pub total_lent: u64,\n    pub user_loans: std::collections::HashMap<Pubkey, u64>,\n}",
        "vulnerabilities": [
            "Absence of interest accrual mechanism, potentially leading to economic losses for lenders",
            "Unprotected arithmetic in loan amount handling, risking integer overflow and incorrect debt tracking",
            "Lack of late payment penalties, potentially encouraging defaults and reducing protocol sustainability"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\npub mod vulnerable_exchange {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, fee: u64) -> Result<()> {\n        let exchange = &mut ctx.accounts.exchange;\n        exchange.authority = ctx.accounts.authority.key();\n        exchange.fee = fee;\n        Ok(())\n    }\n\n    pub fn exchange_tokens(ctx: Context<ExchangeTokens>, amount: u64) -> Result<()> {\n        let exchange = &mut ctx.accounts.exchange;\n        let user = &ctx.accounts.user;\n        let fee = exchange.fee;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_account.to_account_info(),\n                    to: ctx.accounts.exchange_token_account.to_account_info(),\n                    authority: user.to_account_info(),\n                },\n            ),\n            amount,\n        )?;\n\n        let net_amount = amount - fee;\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.exchange_token_account.to_account_info(),\n                    to: ctx.accounts.user_token_account.to_account_info(),\n                    authority: exchange.to_account_info(),\n                },\n                &[&[&exchange.authority.to_bytes(), &[*ctx.bumps.get(\"exchange\").unwrap()]]],\n            ),\n            net_amount,\n        )?;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 8 + 64)]\n    pub exchange: Account<'info, Exchange>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct ExchangeTokens<'info> {\n    #[account(mut)]\n    pub exchange: Account<'info, Exchange>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub exchange_token_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct Exchange {\n    pub authority: Pubkey,\n    pub fee: u64,\n}",
        "vulnerabilities": [
            "Absence of dynamic exchange rate calculation, potentially leading to unfair or manipulated token swaps",
            "Lack of safeguards against fee manipulation, risking excessive charges or economic attacks on the protocol"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\npub mod vulnerable_voting {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {\n        let voting = &mut ctx.accounts.voting;\n        voting.authority = ctx.accounts.authority.key();\n        Ok(())\n    }\n\n    pub fn create_proposal(ctx: Context<CreateProposal>, description: String) -> Result<()> {\n        let voting = &mut ctx.accounts.voting;\n        let proposal = Proposal {\n            id: voting.proposals.len() as u64,\n            description,\n            votes_for: 0,\n            votes_against: 0,\n        };\n        voting.proposals.push(proposal);\n        Ok(())\n    }\n\n    pub fn vote(ctx: Context<Vote>, proposal_id: u64, vote_for: bool) -> Result<()> {\n        let voting = &mut ctx.accounts.voting;\n        let proposal = voting.proposals.get_mut(proposal_id as usize).ok_or(ErrorCode::ProposalNotFound)?;\n\n        if vote_for {\n            proposal.votes_for += 1;\n        } else {\n            proposal.votes_against += 1;\n        }\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 64 + 256)]\n    pub voting: Account<'info, Voting>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct CreateProposal<'info> {\n    #[account(mut)]\n    pub voting: Account<'info, Voting>,\n    pub authority: Signer<'info>,\n}\n\n#[derive(Accounts)]\npub struct Vote<'info> {\n    #[account(mut)]\n    pub voting: Account<'info, Voting>,\n    pub voter: Signer<'info>,\n}\n\n#[account]\npub struct Voting {\n    pub authority: Pubkey,\n    pub proposals: Vec<Proposal>,\n}\n\n#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]\npub struct Proposal {\n    pub id: u64,\n    pub description: String,\n    pub votes_for: u64,\n    pub votes_against: u64,\n}",
        "vulnerabilities": [
            "Missing protection against repeated voting, allowing users to unfairly influence proposal outcomes",
            "Absence of proposal expiration mechanism, potentially leading to stale or irrelevant governance decisions"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\npub mod vulnerable_subscription {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, price: u64, duration: i64) -> Result<()> {\n        let subscription = &mut ctx.accounts.subscription;\n        subscription.authority = ctx.accounts.authority.key();\n        subscription.price = price;\n        subscription.duration = duration;\n        Ok(())\n    }\n\n    pub fn subscribe(ctx: Context<Subscribe>) -> Result<()> {\n        let subscription = &mut ctx.accounts.subscription;\n        let user = &ctx.accounts.user;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_account.to_account_info(),\n                    to: ctx.accounts.subscription_token_account.to_account_info(),\n                    authority: user.to_account_info(),\n                },\n            ),\n            subscription.price,\n        )?;\n\n        subscription.subscriptions.insert(user.key(), Clock::get().unwrap().unix_timestamp + subscription.duration);\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 8 + 8)]\n    pub subscription: Account<'info, Subscription>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Subscribe<'info> {\n    #[account(mut)]\n    pub subscription: Account<'info, Subscription>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub subscription_token_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct Subscription {\n    pub authority: Pubkey,\n    pub price: u64,\n    pub duration: i64,\n    pub subscriptions: std::collections::HashMap<Pubkey, i64>,\n}",
        "vulnerabilities": [
            "Lack of checks for duplicate subscriptions, potentially allowing users to gain unfair advantages or drain resources",
            "Unprotected arithmetic in duration calculations, risking integer overflow and incorrect subscription periods"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\npub mod vulnerable_escrow {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, duration: i64) -> Result<()> {\n        let escrow = &mut ctx.accounts.escrow;\n        escrow.authority = ctx.accounts.authority.key();\n        escrow.duration = duration;\n        Ok(())\n    }\n\n    pub fn deposit(ctx: Context<Deposit>, amount: u64) -> Result<()> {\n        let escrow = &mut ctx.accounts.escrow;\n        let user = &ctx.accounts.user;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_account.to_account_info(),\n                    to: ctx.accounts.escrow_token_account.to_account_info(),\n                    authority: user.to_account_info(),\n                },\n            ),\n            amount,\n        )?;\n\n        escrow.total_deposits += amount;\n        escrow.deposits.insert(user.key(), amount);\n\n        Ok(())\n    }\n\n    pub fn release(ctx: Context<Release>, amount: u64) -> Result<()> {\n        let escrow = &mut ctx.accounts.escrow;\n        let user = &ctx.accounts.user;\n        let user_deposit = *escrow.deposits.get(&user.key()).unwrap_or(&0);\n\n        require!(Clock::get().unwrap().unix_timestamp >= escrow.duration, ErrorCode::EscrowNotMatured);\n        require!(user_deposit >= amount, ErrorCode::InsufficientDeposit);\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.escrow_token_account.to_account_info(),\n                    to: ctx.accounts.user_token_account.to_account_info(),\n                    authority: escrow.to_account_info(),\n                },\n                &[&[&escrow.authority.to_bytes(), &[*ctx.bumps.get(\"escrow\").unwrap()]]],\n            ),\n            amount,\n        )?;\n\n        escrow.total_deposits -= amount;\n        escrow.deposits.insert(user.key(), user_deposit - amount);\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 8 + 64)]\n    pub escrow: Account<'info, Escrow>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Deposit<'info> {\n    #[account(mut)]\n    pub escrow: Account<'info, Escrow>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub escrow_token_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct Release<'info> {\n    #[account(mut)]\n    pub escrow: Account<'info, Escrow>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub escrow_token_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct Escrow {\n    pub authority: Pubkey,\n    pub duration: i64,\n    pub total_deposits: u64,\n    pub deposits: std::collections::HashMap<Pubkey, u64>,\n}",
        "vulnerabilities": [
            "Absence of early withdrawal disincentives, potentially destabilizing the protocol's liquidity",
            "Unprotected arithmetic in deposit handling, risking integer overflow and incorrect balance tracking"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\npub mod vulnerable_auction {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, start_time: i64, end_time: i64) -> Result<()> {\n        let auction = &mut ctx.accounts.auction;\n        auction.authority = ctx.accounts.authority.key();\n        auction.start_time = start_time;\n        auction.end_time = end_time;\n        Ok(())\n    }\n\n    pub fn place_bid(ctx: Context<PlaceBid>, amount: u64) -> Result<()> {\n        let auction = &mut ctx.accounts.auction;\n        let user = &ctx.accounts.user;\n        let current_time = Clock::get().unwrap().unix_timestamp;\n\n        require!(current_time >= auction.start_time && current_time <= auction.end_time, ErrorCode::AuctionNotActive);\n        require!(amount > auction.highest_bid, ErrorCode::BidTooLow);\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_account.to_account_info(),\n                    to: ctx.accounts.auction_token_account.to_account_info(),\n                    authority: user.to_account_info(),\n                },\n            ),\n            amount,\n        )?;\n\n        auction.highest_bid = amount;\n        auction.highest_bidder = user.key();\n\n        Ok(())\n    }\n\n    pub fn claim_item(ctx: Context<ClaimItem>) -> Result<()> {\n        let auction = &mut ctx.accounts.auction;\n        let user = &ctx.accounts.user;\n        let current_time = Clock::get().unwrap().unix_timestamp;\n\n        require!(current_time > auction.end_time, ErrorCode::AuctionNotEnded);\n        require!(auction.highest_bidder == user.key(), ErrorCode::NotHighestBidder);\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.auction_token_account.to_account_info(),\n                    to: ctx.accounts.user_token_account.to_account_info(),\n                    authority: auction.to_account_info(),\n                },\n                &[&[&auction.authority.to_bytes(), &[*ctx.bumps.get(\"auction\").unwrap()]]],\n            ),\n            auction.highest_bid,\n        )?;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 8 + 8 + 8)]\n    pub auction: Account<'info, Auction>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct PlaceBid<'info> {\n    #[account(mut)]\n    pub auction: Account<'info, Auction>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub auction_token_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct ClaimItem<'info> {\n    #[account(mut)]\n    pub auction: Account<'info, Auction>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub auction_token_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct Auction {\n    pub authority: Pubkey,\n    pub start_time: i64,\n    pub end_time: i64,\n    pub highest_bid: u64,\n    pub highest_bidder: Pubkey,\n}",   
        "vulnerabilities": [
            "Lack of refund mechanism for outbid participants, potentially leading to locked funds and decreased participation",
            "Unbounded bidding per user, risking auction manipulation and unfair advantage to wealthy participants"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\npub mod vulnerable_auction {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, end_time: i64) -> Result<()> {\n        let auction = &mut ctx.accounts.auction;\n        auction.authority = ctx.accounts.authority.key();\n        auction.end_time = end_time;\n        Ok(())\n    }\n\n    pub fn bid(ctx: Context<Bid>, amount: u64) -> Result<()> {\n        let auction = &mut ctx.accounts.auction;\n        let user = &ctx.accounts.user;\n\n        require!(Clock::get().unwrap().unix_timestamp < auction.end_time, ErrorCode::AuctionEnded);\n        require!(amount > auction.highest_bid, ErrorCode::BidTooLow);\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_account.to_account_info(),\n                    to: ctx.accounts.auction_token_account.to_account_info(),\n                    authority: user.to_account_info(),\n                },\n            ),\n            amount,\n        )?;\n\n        auction.highest_bid = amount;\n        auction.highest_bidder = user.key();\n\n        Ok(())\n    }\n\n    pub fn end_auction(ctx: Context<EndAuction>) -> Result<()> {\n        let auction = &mut ctx.accounts.auction;\n        require!(Clock::get().unwrap().unix_timestamp >= auction.end_time, ErrorCode::AuctionNotEnded);\n\n        let highest_bid = auction.highest_bid;\n        let highest_bidder = auction.highest_bidder;\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.auction_token_account.to_account_info(),\n                    to: ctx.accounts.authority_token_account.to_account_info(),\n                    authority: auction.to_account_info(),\n                },\n                &[&[&auction.authority.to_bytes(), &[*ctx.bumps.get(\"auction\").unwrap()]]],\n            ),\n            highest_bid,\n        )?;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 8 + 64 + 64)]\n    pub auction: Account<'info, Auction>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Bid<'info> {\n    #[account(mut)]\n    pub auction: Account<'info, Auction>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub auction_token_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct EndAuction<'info> {\n    #[account(mut)]\n    pub auction: Account<'info, Auction>,\n    #[account(mut)]\n    pub authority_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub auction_token_account: Account<'info, TokenAccount>,\n    pub authority: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct Auction {\n    pub authority: Pubkey,\n    pub end_time: i64,\n    pub highest_bid: u64,\n    pub highest_bidder: Pubkey,\n}",
        "vulnerabilities": [
            "Missing refund functionality for outbid users, potentially trapping funds and discouraging participation",
            "Unprotected arithmetic in bid processing, risking integer overflow and incorrect bid tracking",
            "Absence of penalties for failed bids, potentially encouraging disruptive bidding behavior"
        ]          
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\npub mod vulnerable_crowdfunding {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, goal: u64, deadline: i64) -> Result<()> {\n        let crowdfunding = &mut ctx.accounts.crowdfunding;\n        crowdfunding.authority = ctx.accounts.authority.key();\n        crowdfunding.goal = goal;\n        crowdfunding.deadline = deadline;\n        Ok(())\n    }\n\n    pub fn contribute(ctx: Context<Contribute>, amount: u64) -> Result<()> {\n        let crowdfunding = &mut ctx.accounts.crowdfunding;\n        let user = &ctx.accounts.user;\n\n        require!(Clock::get().unwrap().unix_timestamp < crowdfunding.deadline, ErrorCode::CampaignEnded);\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_account.to_account_info(),\n                    to: ctx.accounts.crowdfunding_token_account.to_account_info(),\n                    authority: user.to_account_info(),\n                },\n            ),\n            amount,\n        )?;\n\n        crowdfunding.total_contributions += amount;\n        crowdfunding.user_contributions.insert(user.key(), amount);\n\n        Ok(())\n    }\n\n    pub fn withdraw(ctx: Context<Withdraw>) -> Result<()> {\n        let crowdfunding = &mut ctx.accounts.crowdfunding;\n        require!(Clock::get().unwrap().unix_timestamp >= crowdfunding.deadline, ErrorCode::CampaignNotEnded);\n        require!(crowdfunding.total_contributions >= crowdfunding.goal, ErrorCode::GoalNotMet);\n\n        let amount = crowdfunding.total_contributions;\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.crowdfunding_token_account.to_account_info(),\n                    to: ctx.accounts.authority_token_account.to_account_info(),\n                    authority: crowdfunding.to_account_info(),\n                },\n                &[&[&crowdfunding.authority.to_bytes(), &[*ctx.bumps.get(\"crowdfunding\").unwrap()]]],\n            ),\n            amount,\n        )?;\n\n        Ok(())\n    }\n\n    pub fn refund(ctx: Context<Refund>) -> Result<()> {\n        let crowdfunding = &mut ctx.accounts.crowdfunding;\n        let user = &ctx.accounts.user;\n        let amount = *crowdfunding.user_contributions.get(&user.key()).unwrap_or(&0);\n\n        require!(Clock::get().unwrap().unix_timestamp >= crowdfunding.deadline, ErrorCode::CampaignNotEnded);\n        require!(crowdfunding.total_contributions < crowdfunding.goal, ErrorCode::GoalMet);\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.crowdfunding_token_account.to_account_info(),\n                    to: ctx.accounts.user_token_account.to_account_info(),\n                    authority: crowdfunding.to_account_info(),\n                },\n                &[&[&crowdfunding.authority.to_bytes(), &[*ctx.bumps.get(\"crowdfunding\").unwrap()]]],\n            ),\n            amount,\n        )?;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 8 + 64 + 64)]\n    pub crowdfunding: Account<'info, Crowdfunding>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Contribute<'info> {\n    #[account(mut)]\n    pub crowdfunding: Account<'info, Crowdfunding>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub crowdfunding_token_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct Withdraw<'info> {\n    #[account(mut)]\n    pub crowdfunding: Account<'info, Crowdfunding>,\n    #[account(mut)]\n    pub authority_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub crowdfunding_token_account: Account<'info, TokenAccount>,\n    pub authority: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct Refund<'info> {\n    #[account(mut)]\n    pub crowdfunding: Account<'info, Crowdfunding>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub crowdfunding_token_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct Crowdfunding {\n    pub authority: Pubkey,\n    pub goal: u64,\n    pub deadline: i64,\n    pub total_contributions: u64,\n    pub user_contributions: std::collections::HashMap<Pubkey, u64>,\n}",
        "vulnerabilities": [
            "Lack of partial refund mechanism for over-funding scenarios, potentially leading to locked excess contributions",
            "Unprotected arithmetic in contribution handling, risking integer overflow and incorrect funding totals"
        ]
    },    
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\npub mod vulnerable_staking {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, reward_rate: u64) -> Result<()> {\n        let staking = &mut ctx.accounts.staking;\n        staking.authority = ctx.accounts.authority.key();\n        staking.reward_rate = reward_rate;\n        Ok(())\n    }\n\n    pub fn stake(ctx: Context<Stake>, amount: u64) -> Result<()> {\n        let staking = &mut ctx.accounts.staking;\n        let user = &ctx.accounts.user;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_account.to_account_info(),\n                    to: ctx.accounts.staking_token_account.to_account_info(),\n                    authority: user.to_account_info(),\n                },\n            ),\n            amount,\n        )?;\n\n        staking.total_staked += amount;\n        staking.user_stakes.insert(user.key(), amount);\n\n        Ok(())\n    }\n\n    pub fn unstake(ctx: Context<Unstake>, amount: u64) -> Result<()> {\n        let staking = &mut ctx.accounts.staking;\n        let user = &ctx.accounts.user;\n        let user_stake = *staking.user_stakes.get(&user.key()).unwrap_or(&0);\n\n        require!(user_stake >= amount, ErrorCode::InsufficientStake);\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.staking_token_account.to_account_info(),\n                    to: ctx.accounts.user_token_account.to_account_info(),\n                    authority: staking.to_account_info(),\n                },\n                &[&[&staking.authority.to_bytes(), &[*ctx.bumps.get(\"staking\").unwrap()]]],\n            ),\n            amount,\n        )?;\n\n        staking.total_staked -= amount;\n        staking.user_stakes.insert(user.key(), user_stake - amount);\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 8 + 64 + 64)]\n    pub staking: Account<'info, Staking>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Stake<'info> {\n    #[account(mut)]\n    pub staking: Account<'info, Staking>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub staking_token_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct Unstake<'info> {\n    #[account(mut)]\n    pub staking: Account<'info, Staking>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub staking_token_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct Staking {\n    pub authority: Pubkey,\n    pub reward_rate: u64,\n    pub total_staked: u64,\n    pub user_stakes: std::collections::HashMap<Pubkey, u64>,\n}",
        "vulnerabilities": [
            "Missing reward calculation mechanism for staked tokens, potentially leading to unfair distribution or loss of incentives",
            "Unprotected arithmetic in stake processing, risking integer overflow and incorrect stake tracking",
            "Absence of unstaking penalties, potentially leading to liquidity instability and reduced protocol security"
        ]
    },     
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\nmod vulnerable_yield_farm {\n    use super::*;\n\n    pub fn initialize_farm(ctx: Context<InitializeFarm>, farm_seed: u64, reward_per_block: u64) -> Result<()> {\n        let farm = &mut ctx.accounts.farm;\n        farm.authority = ctx.accounts.authority.key();\n        farm.staking_token = ctx.accounts.staking_token.key();\n        farm.reward_token = ctx.accounts.reward_token.key();\n        farm.seed = farm_seed;\n        farm.reward_per_block = reward_per_block;\n        farm.last_reward_block = Clock::get()?.slot;\n        farm.total_staked = 0;\n        farm.acc_reward_per_share = 0;\n        Ok(())\n    }\n\n    pub fn stake(ctx: Context<Stake>, amount: u64) -> Result<()> {\n        let farm = &mut ctx.accounts.farm;\n        let user = &mut ctx.accounts.user_info;\n\n        update_pool(farm)?;\n\n        if user.amount > 0 {\n            let pending_reward = (user.amount as u128 * farm.acc_reward_per_share as u128 / 1e12 as u128) as u64 - user.reward_debt;\n            token::transfer(\n                CpiContext::new_with_signer(\n                    ctx.accounts.token_program.to_account_info(),\n                    Transfer {\n                        from: ctx.accounts.farm_reward.to_account_info(),\n                        to: ctx.accounts.user_reward.to_account_info(),\n                        authority: farm.to_account_info(),\n                    },\n                    &[&[b\"farm\", &farm.seed.to_le_bytes(), &[ctx.bumps.farm]]],\n                ),\n                pending_reward,\n            )?;\n        }\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_staking.to_account_info(),\n                    to: ctx.accounts.farm_staking.to_account_info(),\n                    authority: ctx.accounts.user.to_account_info(),\n                },\n            ),\n            amount,\n        )?;\n\n        user.amount += amount;\n        farm.total_staked += amount;\n        user.reward_debt = (user.amount as u128 * farm.acc_reward_per_share as u128 / 1e12 as u128) as u64;\n\n        Ok(())\n    }\n\n    pub fn unstake(ctx: Context<Unstake>, amount: u64) -> Result<()> {\n        let farm = &mut ctx.accounts.farm;\n        let user = &mut ctx.accounts.user_info;\n\n        require!(user.amount >= amount, YieldFarmError::InsufficientBalance);\n\n        update_pool(farm)?;\n\n        let pending_reward = (user.amount as u128 * farm.acc_reward_per_share as u128 / 1e12 as u128) as u64 - user.reward_debt;\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.farm_reward.to_account_info(),\n                    to: ctx.accounts.user_reward.to_account_info(),\n                    authority: farm.to_account_info(),\n                },\n                &[&[b\"farm\", &farm.seed.to_le_bytes(), &[ctx.bumps.farm]]],\n            ),\n            pending_reward,\n        )?;\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.farm_staking.to_account_info(),\n                    to: ctx.accounts.user_staking.to_account_info(),\n                    authority: farm.to_account_info(),\n                },\n                &[&[b\"farm\", &farm.seed.to_le_bytes(), &[ctx.bumps.farm]]],\n            ),\n            amount,\n        )?;\n\n        user.amount -= amount;\n        farm.total_staked -= amount;\n        user.reward_debt = (user.amount as u128 * farm.acc_reward_per_share as u128 / 1e12 as u128) as u64;\n\n        Ok(())\n    }\n}\n\nfn update_pool(farm: &mut Account<YieldFarm>) -> Result<()> {\n    let current_block = Clock::get()?.slot;\n    if current_block <= farm.last_reward_block {\n        return Ok(());\n    }\n\n    if farm.total_staked == 0 {\n        farm.last_reward_block = current_block;\n        return Ok(());\n    }\n\n    let blocks_elapsed = current_block - farm.last_reward_block;\n    let reward = blocks_elapsed * farm.reward_per_block;\n    farm.acc_reward_per_share += (reward as u128 * 1e12 as u128 / farm.total_staked as u128) as u64;\n    farm.last_reward_block = current_block;\n\n    Ok(())\n}\n\n#[derive(Accounts)]\npub struct InitializeFarm<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 32 + 32 + 8 + 8 + 8 + 8 + 8, seeds = [b\"farm\", &farm_seed.to_le_bytes()], bump)]\n    pub farm: Account<'info, YieldFarm>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub staking_token: Account<'info, TokenAccount>,\n    pub reward_token: Account<'info, TokenAccount>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Stake<'info> {\n    #[account(mut)]\n    pub farm: Account<'info, YieldFarm>,\n    #[account(mut)]\n    pub user_info: Account<'info, UserInfo>,\n    #[account(mut)]\n    pub user_staking: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub farm_staking: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub user_reward: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub farm_reward: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct Unstake<'info> {\n    #[account(mut)]\n    pub farm: Account<'info, YieldFarm>,\n    #[account(mut)]\n    pub user_info: Account<'info, UserInfo>,\n    #[account(mut)]\n    pub user_staking: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub farm_staking: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub user_reward: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub farm_reward: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct YieldFarm {\n    pub authority: Pubkey,\n    pub staking_token: Pubkey,\n    pub reward_token: Pubkey,\n    pub seed: u64,\n    pub reward_per_block: u64,\n    pub last_reward_block: u64,\n    pub total_staked: u64,\n    pub acc_reward_per_share: u64,\n}\n\n#[account]\npub struct UserInfo {\n    pub amount: u64,\n    pub reward_debt: u64,\n}\n\n#[error_code]\npub enum YieldFarmError {\n    #[msg(\"Insufficient balance for unstaking\")]\n    InsufficientBalance,\n}",
        "vulnerabilities": [
            "Use of integer division in reward calculations, leading to potential loss of precision and unfair reward distribution",
            "Unrestricted access to yield farm initialization, allowing unauthorized setting of crucial parameters",
            "Potential accumulation of rounding errors in reward tracking, risking inaccurate long-term reward allocations"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\npub mod escrow_service {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, amount: u64, timeout: i64) -> Result<()> {\n        let escrow = &mut ctx.accounts.escrow;\n        escrow.amount = amount;\n        escrow.timeout = timeout;\n        escrow.is_fulfilled = false;\n        Ok(())\n    }\n\n    pub fn deposit(ctx: Context<Deposit>, amount: u64) -> Result<()> {\n        let escrow = &mut ctx.accounts.escrow;\n        require!(ctx.accounts.depositor.amount >= amount, EscrowError::InsufficientFunds);\n        let cpi_accounts = Transfer {\n            from: ctx.accounts.depositor.to_account_info().clone(),\n            to: ctx.accounts.escrow_vault.to_account_info().clone(),\n            authority: ctx.accounts.depositor_authority.clone(),\n        };\n        let cpi_program = ctx.accounts.token_program.clone();\n        let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);\n        token::transfer(cpi_ctx, amount)?;\n        escrow.amount += amount;\n        Ok(())\n    }\n\n    pub fn withdraw(ctx: Context<Withdraw>) -> Result<()> {\n        let escrow = &mut ctx.accounts.escrow;\n        require!(escrow.is_fulfilled, EscrowError::EscrowNotFulfilled);\n        let cpi_accounts = Transfer {\n            from: ctx.accounts.escrow_vault.to_account_info().clone(),\n            to: ctx.accounts.beneficiary.to_account_info().clone(),\n            authority: ctx.accounts.escrow_authority.clone(),\n        };\n        let cpi_program = ctx.accounts.token_program.clone();\n        let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);\n        token::transfer(cpi_ctx, escrow.amount)?;\n        escrow.amount = 0;\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 8 + 8)]\n    pub escrow: Account<'info, Escrow>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Deposit<'info> {\n    #[account(mut)]\n    pub escrow: Account<'info, Escrow>,\n    #[account(mut)]\n    pub depositor: Account<'info, TokenAccount>,\n    pub depositor_authority: Signer<'info>,\n    #[account(mut)]\n    pub escrow_vault: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct Withdraw<'info> {\n    #[account(mut)]\n    pub escrow: Account<'info, Escrow>,\n    #[account(mut)]\n    pub beneficiary: Account<'info, TokenAccount>,\n    pub escrow_authority: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct Escrow {\n    pub amount: u64,\n    pub timeout: i64,\n    pub is_fulfilled: bool,\n}\n\n#[error_code]\npub enum EscrowError {\n    #[msg(\"Insufficient funds\")]\n    InsufficientFunds,\n    #[msg(\"Escrow not fulfilled\")]\n    EscrowNotFulfilled,\n}",
        "vulnerabilities": []
    },    
    {
      
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\nmod vulnerable_auction {\n    use super::*;\n\n    pub fn create_auction(ctx: Context<CreateAuction>, start_price: u64, auction_duration: i64) -> Result<()> {\n        let auction = &mut ctx.accounts.auction;\n        auction.seller = ctx.accounts.seller.key();\n        auction.nft_mint = ctx.accounts.nft_mint.key();\n        auction.start_price = start_price;\n        auction.current_bid = start_price;\n        auction.highest_bidder = ctx.accounts.seller.key();\n        auction.end_time = Clock::get()?.unix_timestamp + auction_duration;\n        auction.ended = false;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.seller_nft_account.to_account_info(),\n                    to: ctx.accounts.auction_nft_account.to_account_info(),\n                    authority: ctx.accounts.seller.to_account_info(),\n                },\n            ),\n            1,\n        )?;\n\n        Ok(())\n    }\n\n    pub fn place_bid(ctx: Context<PlaceBid>, bid_amount: u64) -> Result<()> {\n        let auction = &mut ctx.accounts.auction;\n        let now = Clock::get()?.unix_timestamp;\n\n        require!(!auction.ended, AuctionError::AuctionEnded);\n        require!(now < auction.end_time, AuctionError::AuctionEnded);\n        require!(bid_amount > auction.current_bid, AuctionError::BidTooLow);\n\n        // Transfer tokens from bidder to auction escrow\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.bidder_token_account.to_account_info(),\n                    to: ctx.accounts.auction_token_account.to_account_info(),\n                    authority: ctx.accounts.bidder.to_account_info(),\n                },\n            ),\n            bid_amount,\n        )?;\n\n        // Refund previous highest bidder\n        if auction.highest_bidder != auction.seller {\n            token::transfer(\n                CpiContext::new_with_signer(\n                    ctx.accounts.token_program.to_account_info(),\n                    Transfer {\n                        from: ctx.accounts.auction_token_account.to_account_info(),\n                        to: ctx.accounts.previous_bidder_token_account.to_account_info(),\n                        authority: auction.to_account_info(),\n                    },\n                    &[&[b\"auction\", auction.nft_mint.as_ref(), &[*ctx.bumps.get(\"auction\").unwrap()]]],\n                ),\n                auction.current_bid,\n            )?;\n        }\n\n        auction.current_bid = bid_amount;\n        auction.highest_bidder = ctx.accounts.bidder.key();\n\n        Ok(())\n    }\n\n    pub fn end_auction(ctx: Context<EndAuction>) -> Result<()> {\n        let auction = &mut ctx.accounts.auction;\n        let now = Clock::get()?.unix_timestamp;\n\n        require!(!auction.ended, AuctionError::AuctionAlreadyEnded);\n        require!(now >= auction.end_time, AuctionError::AuctionNotEnded);\n\n        // Transfer NFT to highest bidder\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.auction_nft_account.to_account_info(),\n                    to: ctx.accounts.winner_nft_account.to_account_info(),\n                    authority: auction.to_account_info(),\n                },\n                &[&[b\"auction\", auction.nft_mint.as_ref(), &[*ctx.bumps.get(\"auction\").unwrap()]]],\n            ),\n            1,\n        )?;\n\n        // Transfer funds to seller\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.auction_token_account.to_account_info(),\n                    to: ctx.accounts.seller_token_account.to_account_info(),\n                    authority: auction.to_account_info(),\n                },\n                &[&[b\"auction\", auction.nft_mint.as_ref(), &[*ctx.bumps.get(\"auction\").unwrap()]]],\n            ),\n            auction.current_bid,\n        )?;\n\n        auction.ended = true;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct CreateAuction<'info> {\n    #[account(init, payer = seller, space = 8 + 32 + 32 + 8 + 8 + 32 + 8 + 1, seeds = [b\"auction\", nft_mint.key().as_ref()], bump)]\n    pub auction: Account<'info, Auction>,\n    #[account(mut)]\n    pub seller: Signer<'info>,\n    pub nft_mint: Account<'info, Token>,\n    #[account(mut)]\n    pub seller_nft_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub auction_nft_account: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct PlaceBid<'info> {\n    #[account(mut)]\n    pub auction: Account<'info, Auction>,\n    #[account(mut)]\n    pub bidder: Signer<'info>,\n    #[account(mut)]\n    pub bidder_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub auction_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    /// CHECK: This account is not read or written to, it just receives tokens\n    pub previous_bidder_token_account: AccountInfo<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct EndAuction<'info> {\n    #[account(mut)]\n    pub auction: Account<'info, Auction>,\n    #[account(mut)]\n    pub auction_nft_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub winner_nft_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub auction_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub seller_token_account: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct Auction {\n    pub seller: Pubkey,\n    pub nft_mint: Pubkey,\n    pub start_price: u64,\n    pub current_bid: u64,\n    pub highest_bidder: Pubkey,\n    pub end_time: i64,\n    pub ended: bool,\n}\n\n#[error_code]\npub enum AuctionError {\n    #[msg(\"Auction has already ended\")]\n    AuctionEnded,\n    #[msg(\"Bid is too low\")]\n    BidTooLow,\n    #[msg(\"Auction has not ended yet\")]\n    AuctionNotEnded,\n    #[msg(\"Auction has already been ended\")]\n    AuctionAlreadyEnded,\n}",
        "vulnerabilities": [
          "Lack of access control for ending the auction",
          "Potential integer overflow in bid amount calculations",
          "No protection against front-running in bid placement"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\nmod vulnerable_yield_farm {\n    use super::*;\n\n    pub fn initialize_pool(ctx: Context<InitializePool>, reward_per_block: u64) -> Result<()> {\n        let pool = &mut ctx.accounts.pool;\n        pool.total_staked = 0;\n        pool.reward_per_block = reward_per_block;\n        pool.last_reward_block = ctx.accounts.clock.slot;\n        pool.accrued_reward_per_share = 0;\n        Ok(())\n    }\n\n    pub fn stake(ctx: Context<Stake>, amount: u64) -> Result<()> {\n        let pool = &mut ctx.accounts.pool;\n        let user = &mut ctx.accounts.user;\n\n        update_pool(pool, ctx.accounts.clock.slot)?;\n\n        if user.amount > 0 {\n            let pending_reward = (user.amount as u128)\n                .checked_mul(pool.accrued_reward_per_share as u128)\n                .unwrap()\n                .checked_div(1e12 as u128)\n                .unwrap()\n                .checked_sub(user.reward_debt as u128)\n                .unwrap() as u64;\n            token::transfer(\n                CpiContext::new_with_signer(\n                    ctx.accounts.token_program.to_account_info(),\n                    Transfer {\n                        from: ctx.accounts.pool_reward_account.to_account_info(),\n                        to: ctx.accounts.user_reward_account.to_account_info(),\n                        authority: pool.to_account_info(),\n                    },\n                    &[&[b\"pool\".as_ref(), &[*ctx.bumps.get(\"pool\").unwrap()]]],\n                ),\n                pending_reward,\n            )?;\n        }\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_account.to_account_info(),\n                    to: ctx.accounts.pool_token_account.to_account_info(),\n                    authority: ctx.accounts.user.to_account_info(),\n                },\n            ),\n            amount,\n        )?;\n\n        user.amount += amount;\n        pool.total_staked += amount;\n        user.reward_debt = (user.amount as u128)\n            .checked_mul(pool.accrued_reward_per_share as u128)\n            .unwrap()\n            .checked_div(1e12 as u128)\n            .unwrap() as u64;\n\n        Ok(())\n    }\n\n    pub fn unstake(ctx: Context<Unstake>, amount: u64) -> Result<()> {\n        let pool = &mut ctx.accounts.pool;\n        let user = &mut ctx.accounts.user;\n\n        update_pool(pool, ctx.accounts.clock.slot)?;\n\n        let pending_reward = (user.amount as u128)\n            .checked_mul(pool.accrued_reward_per_share as u128)\n            .unwrap()\n            .checked_div(1e12 as u128)\n            .unwrap()\n            .checked_sub(user.reward_debt as u128)\n            .unwrap() as u64;\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.pool_reward_account.to_account_info(),\n                    to: ctx.accounts.user_reward_account.to_account_info(),\n                    authority: pool.to_account_info(),\n                },\n                &[&[b\"pool\".as_ref(), &[*ctx.bumps.get(\"pool\").unwrap()]]],\n            ),\n            pending_reward,\n        )?;\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.pool_token_account.to_account_info(),\n                    to: ctx.accounts.user_token_account.to_account_info(),\n                    authority: pool.to_account_info(),\n                },\n                &[&[b\"pool\".as_ref(), &[*ctx.bumps.get(\"pool\").unwrap()]]],\n            ),\n            amount,\n        )?;\n\n        user.amount -= amount;\n        pool.total_staked -= amount;\n        user.reward_debt = (user.amount as u128)\n            .checked_mul(pool.accrued_reward_per_share as u128)\n            .unwrap()\n            .checked_div(1e12 as u128)\n            .unwrap() as u64;\n\n        Ok(())\n    }\n}\n\nfn update_pool(pool: &mut Account<Pool>, current_block: u64) -> Result<()> {\n    if current_block <= pool.last_reward_block {\n        return Ok(());\n    }\n\n    if pool.total_staked == 0 {\n        pool.last_reward_block = current_block;\n        return Ok(());\n    }\n\n    let blocks_elapsed = current_block - pool.last_reward_block;\n    let reward = blocks_elapsed.checked_mul(pool.reward_per_block).unwrap();\n    pool.accrued_reward_per_share += (reward as u128)\n        .checked_mul(1e12)\n        .unwrap()\n        .checked_div(pool.total_staked as u128)\n        .unwrap() as u64;\n    pool.last_reward_block = current_block;\n\n    Ok(())\n}\n\n#[derive(Accounts)]\npub struct InitializePool<'info> {\n    #[account(init, payer = creator, space = 8 + 8 + 8 + 8 + 8, seeds = [b\"pool\"], bump)]\n    pub pool: Account<'info, Pool>,\n    #[account(mut)]\n    pub creator: Signer<'info>,\n    pub system_program: Program<'info, System>,\n    pub clock: Sysvar<'info, Clock>,\n}\n\n#[derive(Accounts)]\npub struct Stake<'info> {\n    #[account(mut)]\n    pub pool: Account<'info, Pool>,\n    #[account(mut)]\n    pub user: Account<'info, User>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_reward_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub user_reward_account: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n    pub clock: Sysvar<'info, Clock>,\n}\n\n#[derive(Accounts)]\npub struct Unstake<'info> {\n    #[account(mut)]\n    pub pool: Account<'info, Pool>,\n    #[account(mut)]\n    pub user: Account<'info, User>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_reward_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub user_reward_account: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n    pub clock: Sysvar<'info, Clock>,\n}\n\n#[account]\npub struct Pool {\n    pub total_staked: u64,\n    pub reward_per_block: u64,\n    pub last_reward_block: u64,\n    pub accrued_reward_per_share: u64,\n}\n\n#[account]\npub struct User {\n    pub amount: u64,\n    pub reward_debt: u64,\n}",
        "vulnerabilities": [
          "Potential for precision loss in reward calculations",
          "Lack of slippage protection for staking and unstaking",
          "Missing access control for initializing the pool"
        ]
    },
    {
      "code": "use solana_program::{\n    account_info::{next_account_info, AccountInfo},\n    entrypoint::ProgramResult,\n    program_error::ProgramError,\n    pubkey::Pubkey,\n    msg,\n};\n\npub fn process_instruction(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    instruction_data: &[u8],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let account = next_account_info(account_info_iter)?;\n\n    if !account.is_signer {\n        return Err(ProgramError::MissingRequiredSignature);\n    }\n\n    // Process instruction data\n    match instruction_data.get(0) {\n        Some(0) => {\n            msg!(\"Instruction: Initialize account\");\n            // Initialize account logic\n        },\n        Some(1) => {\n            msg!(\"Instruction: Update account\");\n            // Update account logic\n        },\n        _ => return Err(ProgramError::InvalidInstructionData),\n    }\n\n    Ok(())\n}",
      "vulnerabilities": [
        "Potential for arithmetic overflows/underflows",
        "Incomplete code",
        "Lack of event emission"
      ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\nmod vulnerable_dex {\n    use super::*;\n\n    pub fn initialize_pool(ctx: Context<InitializePool>, pool_seed: u64) -> Result<()> {\n        let pool = &mut ctx.accounts.pool;\n        pool.authority = ctx.accounts.authority.key();\n        pool.token_a = ctx.accounts.token_a.key();\n        pool.token_b = ctx.accounts.token_b.key();\n        pool.seed = pool_seed;\n        pool.total_a = 0;\n        pool.total_b = 0;\n        Ok(())\n    }\n\n    pub fn add_liquidity(ctx: Context<AddLiquidity>, amount_a: u64, amount_b: u64) -> Result<()> {\n        let pool = &mut ctx.accounts.pool;\n        pool.total_a += amount_a;\n        pool.total_b += amount_b;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_a.to_account_info(),\n                    to: ctx.accounts.pool_token_a.to_account_info(),\n                    authority: ctx.accounts.user.to_account_info(),\n                },\n            ),\n            amount_a,\n        )?;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_b.to_account_info(),\n                    to: ctx.accounts.pool_token_b.to_account_info(),\n                    authority: ctx.accounts.user.to_account_info(),\n                },\n            ),\n            amount_b,\n        )?;\n\n        Ok(())\n    }\n\n    pub fn swap(ctx: Context<Swap>, amount_in: u64, minimum_amount_out: u64) -> Result<()> {\n        let pool = &mut ctx.accounts.pool;\n        let (amount_out, fee) = calculate_swap(amount_in, pool.total_a, pool.total_b);\n        require!(amount_out >= minimum_amount_out, DexError::SlippageExceeded);\n\n        pool.total_a += amount_in;\n        pool.total_b -= amount_out;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_a.to_account_info(),\n                    to: ctx.accounts.pool_token_a.to_account_info(),\n                    authority: ctx.accounts.user.to_account_info(),\n                },\n            ),\n            amount_in,\n        )?;\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.pool_token_b.to_account_info(),\n                    to: ctx.accounts.user_token_b.to_account_info(),\n                    authority: pool.to_account_info(),\n                },\n                &[&[b\"pool\", &pool.seed.to_le_bytes(), &[ctx.bumps.pool]]],\n            ),\n            amount_out,\n        )?;\n\n        Ok(())\n    }\n}\n\nfn calculate_swap(amount_in: u64, reserve_a: u64, reserve_b: u64) -> (u64, u64) {\n    let amount_with_fee = amount_in * 997;\n    let numerator = amount_with_fee * reserve_b;\n    let denominator = (reserve_a * 1000) + amount_with_fee;\n    let amount_out = numerator / denominator;\n    let fee = amount_in / 1000;\n    (amount_out, fee)\n}\n\n#[derive(Accounts)]\npub struct InitializePool<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 32 + 32 + 8 + 8 + 8, seeds = [b\"pool\", &pool_seed.to_le_bytes()], bump)]\n    pub pool: Account<'info, DexPool>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub token_a: Account<'info, TokenAccount>,\n    pub token_b: Account<'info, TokenAccount>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct AddLiquidity<'info> {\n    #[account(mut)]\n    pub pool: Account<'info, DexPool>,\n    #[account(mut)]\n    pub user_token_a: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub user_token_b: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_a: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_b: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct Swap<'info> {\n    #[account(mut)]\n    pub pool: Account<'info, DexPool>,\n    #[account(mut)]\n    pub user_token_a: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub user_token_b: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_a: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_b: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct DexPool {\n    pub authority: Pubkey,\n    pub token_a: Pubkey,\n    pub token_b: Pubkey,\n    pub seed: u64,\n    pub total_a: u64,\n    pub total_b: u64,\n}\n\n#[error_code]\npub enum DexError {\n    #[msg(\"Slippage tolerance exceeded\")]\n    SlippageExceeded,\n}",
        "vulnerabilities": [
          "Front-running: Lack of protection against sandwich attacks in the swap function",
          "Reentrancy: Potential for reentrancy attacks in add_liquidity and swap functions",
          "Integer overflow: Unchecked arithmetic operations in calculate_swap function"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\npub mod vulnerable_staking {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, reward_rate: u64) -> Result<()> {\n        let staking_pool = &mut ctx.accounts.staking_pool;\n        staking_pool.authority = ctx.accounts.authority.key();\n        staking_pool.reward_rate = reward_rate;\n        staking_pool.last_update_time = Clock::get()?.unix_timestamp;\n        Ok(())\n    }\n\n    pub fn stake(ctx: Context<Stake>, amount: u64) -> Result<()> {\n        let staking_pool = &mut ctx.accounts.staking_pool;\n        let user = &ctx.accounts.user;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_account.to_account_info(),\n                    to: ctx.accounts.pool_token_account.to_account_info(),\n                    authority: user.to_account_info(),\n                },\n            ),\n            amount,\n        )?;\n\n        staking_pool.total_staked += amount;\n        staking_pool.user_stakes.insert(user.key(), amount);\n        Ok(())\n    }\n\n    pub fn claim_rewards(ctx: Context<ClaimRewards>) -> Result<()> {\n        let staking_pool = &mut ctx.accounts.staking_pool;\n        let user = &ctx.accounts.user;\n\n        let user_stake = staking_pool.user_stakes.get(&user.key()).unwrap_or(&0);\n        let current_time = Clock::get()?.unix_timestamp;\n        let time_elapsed = (current_time - staking_pool.last_update_time) as u64;\n\n        let reward = user_stake * staking_pool.reward_rate * time_elapsed / (24 * 60 * 60);\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.pool_token_account.to_account_info(),\n                    to: ctx.accounts.user_token_account.to_account_info(),\n                    authority: staking_pool.to_account_info(),\n                },\n                &[&[&staking_pool.authority.to_bytes(), &[*ctx.bumps.get(\"staking_pool\").unwrap()]]],\n            ),\n            reward,\n        )?;\n\n        staking_pool.last_update_time = current_time;\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 8 + 8 + 64 + 64)]\n    pub staking_pool: Account<'info, StakingPool>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Stake<'info> {\n    #[account(mut)]\n    pub staking_pool: Account<'info, StakingPool>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct ClaimRewards<'info> {\n    #[account(mut)]\n    pub staking_pool: Account<'info, StakingPool>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct StakingPool {\n    pub authority: Pubkey,\n    pub reward_rate: u64,\n    pub last_update_time: i64,\n    pub total_staked: u64,\n    pub user_stakes: std::collections::HashMap<Pubkey, u64>,\n}",
        "vulnerabilities": [
            "Integer overflow in reward calculation",
            "Lack of checks for sufficient reward tokens in the pool",
            "Missing unstake functionality"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\nmod vulnerable_bridge {\n    use super::*;\n\n    pub fn initialize_bridge(ctx: Context<InitializeBridge>, bridge_seed: u64) -> Result<()> {\n        let bridge = &mut ctx.accounts.bridge;\n        bridge.authority = ctx.accounts.authority.key();\n        bridge.token = ctx.accounts.token.key();\n        bridge.seed = bridge_seed;\n        bridge.total_locked = 0;\n        Ok(())\n    }\n\n    pub fn lock_tokens(ctx: Context<LockTokens>, amount: u64, recipient: String) -> Result<()> {\n        let bridge = &mut ctx.accounts.bridge;\n        bridge.total_locked += amount;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token.to_account_info(),\n                    to: ctx.accounts.bridge_token.to_account_info(),\n                    authority: ctx.accounts.user.to_account_info(),\n                },\n            ),\n            amount,\n        )?;\n\n        emit!(TokensLocked {\n            user: ctx.accounts.user.key(),\n            amount,\n            recipient\n        });\n\n        Ok(())\n    }\n\n    pub fn unlock_tokens(ctx: Context<UnlockTokens>, amount: u64, tx_hash: String) -> Result<()> {\n        let bridge = &mut ctx.accounts.bridge;\n        require!(bridge.total_locked >= amount, BridgeError::InsufficientFunds);\n\n        bridge.total_locked -= amount;\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.bridge_token.to_account_info(),\n                    to: ctx.accounts.recipient_token.to_account_info(),\n                    authority: bridge.to_account_info(),\n                },\n                &[&[b\"bridge\", &bridge.seed.to_le_bytes(), &[ctx.bumps.bridge]]],\n            ),\n            amount,\n        )?;\n\n        emit!(TokensUnlocked {\n            recipient: ctx.accounts.recipient.key(),\n            amount,\n            tx_hash\n        });\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct InitializeBridge<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 32 + 8 + 8, seeds = [b\"bridge\", &bridge_seed.to_le_bytes()], bump)]\n    pub bridge: Account<'info, Bridge>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub token: Account<'info, TokenAccount>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct LockTokens<'info> {\n    #[account(mut)]\n    pub bridge: Account<'info, Bridge>,\n    #[account(mut)]\n    pub user_token: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub bridge_token: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct UnlockTokens<'info> {\n    #[account(mut)]\n    pub bridge: Account<'info, Bridge>,\n    #[account(mut)]\n    pub bridge_token: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub recipient_token: Account<'info, TokenAccount>,\n    pub recipient: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct Bridge {\n    pub authority: Pubkey,\n    pub token: Pubkey,\n    pub seed: u64,\n    pub total_locked: u64,\n}\n\n#[error_code]\npub enum BridgeError {\n    #[msg(\"Insufficient funds in the bridge\")]\n    InsufficientFunds,\n}\n\n#[event]\npub struct TokensLocked {\n    pub user: Pubkey,\n    pub amount: u64,\n    pub recipient: String,\n}\n\n#[event]\npub struct TokensUnlocked {\n    pub recipient: Pubkey,\n    pub amount: u64,\n    pub tx_hash: String,\n}",
        "vulnerabilities": [
          "Oracle manipulation: Lack of proper validation for unlock_tokens function",
          "Access control: Missing checks for authorized relayers in unlock_tokens",
          "Centralization risk: Single authority for the bridge"
        ]
    },
    {
      "code": "use solana_program::{\n    account_info::{next_account_info, AccountInfo},\n    entrypoint::ProgramResult,\n    program::invoke,\n    pubkey::Pubkey,\n    msg,\n};\n\npub fn process_instruction(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    instruction_data: &[u8],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let caller_account = next_account_info(account_info_iter)?;\n    let external_program = next_account_info(account_info_iter)?;\n\n    if !caller_account.is_signer {\n        return Err(ProgramError::MissingRequiredSignature);\n    }\n\n    msg!(\"Calling external program\");\n    invoke(\n        &instruction_data,\n        &[caller_account.clone(), external_program.clone()],\n    )?;\n\n    msg!(\"External call completed\");\n    Ok(())\n}",
      "vulnerabilities": [
            "Unprotected state changes before external calls, exposing contract to reentrancy attacks and potential fund drainage",
            "Absence of function-level access controls, allowing unauthorized users to execute sensitive operations",
            "Unchecked external contract calls, risking execution of malicious code or unexpected state changes",
            "Insufficient error handling, potentially leaving transactions in an inconsistent state or exposing sensitive information"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\npub mod vulnerable_lottery {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, ticket_price: u64) -> Result<()> {\n        let lottery = &mut ctx.accounts.lottery;\n        lottery.authority = ctx.accounts.authority.key();\n        lottery.ticket_price = ticket_price;\n        lottery.is_active = true;\n        Ok(())\n    }\n\n    pub fn buy_ticket(ctx: Context<BuyTicket>) -> Result<()> {\n        let lottery = &mut ctx.accounts.lottery;\n        let user = &ctx.accounts.user;\n\n        require!(lottery.is_active, ErrorCode::LotteryNotActive);\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_account.to_account_info(),\n                    to: ctx.accounts.lottery_token_account.to_account_info(),\n                    authority: user.to_account_info(),\n                },\n            ),\n            lottery.ticket_price,\n        )?;\n\n        lottery.participants.push(user.key());\n        lottery.total_pot += lottery.ticket_price;\n        Ok(())\n    }\n\n    pub fn draw_winner(ctx: Context<DrawWinner>) -> Result<()> {\n        let lottery = &mut ctx.accounts.lottery;\n        let clock = Clock::get()?;\n\n        require!(lottery.is_active, ErrorCode::LotteryNotActive);\n        require!(!lottery.participants.is_empty(), ErrorCode::NoParticipants);\n\n        let winner_index = (clock.unix_timestamp as usize) % lottery.participants.len();\n        let winner = lottery.participants[winner_index];\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.lottery_token_account.to_account_info(),\n                    to: ctx.accounts.winner_token_account.to_account_info(),\n                    authority: lottery.to_account_info(),\n                },\n                &[&[&lottery.authority.to_bytes(), &[*ctx.bumps.get(\"lottery\").unwrap()]]],\n            ),\n            lottery.total_pot,\n        )?;\n\n        lottery.is_active = false;\n        lottery.winner = Some(winner);\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 8 + 1 + 32 + 64 + 64)]\n    pub lottery: Account<'info, Lottery>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct BuyTicket<'info> {\n    #[account(mut)]\n    pub lottery: Account<'info, Lottery>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub lottery_token_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct DrawWinner<'info> {\n    #[account(mut)]\n    pub lottery: Account<'info, Lottery>,\n    #[account(mut)]\n    pub lottery_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub winner_token_account: Account<'info, TokenAccount>,\n    pub authority: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct Lottery {\n    pub authority: Pubkey,\n    pub ticket_price: u64,\n    pub is_active: bool,\n    pub winner: Option<Pubkey>,\n    pub total_pot: u64,\n    pub participants: Vec<Pubkey>,\n}\n\n#[error_code]\npub enum ErrorCode {\n    #[msg(\"Lottery is not active\")]\n    LotteryNotActive,\n    #[msg(\"No participants in the lottery\")]\n    NoParticipants,\n}",
        "vulnerabilities": [
            "Use of block variables for randomness, making winner selection predictable and manipulable by miners",
            "Unrestricted access to winner selection function, allowing unauthorized users to manipulate the lottery outcome",
            "Unbounded participant list, risking contract failure due to gas limits or economic imbalances"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\nmod vulnerable_lottery {\n    use super::*;\n\n    pub fn initialize_lottery(ctx: Context<InitializeLottery>, ticket_price: u64, max_tickets: u64, draw_time: i64) -> Result<()> {\n        let lottery = &mut ctx.accounts.lottery;\n        lottery.creator = ctx.accounts.creator.key();\n        lottery.ticket_price = ticket_price;\n        lottery.max_tickets = max_tickets;\n        lottery.draw_time = draw_time;\n        lottery.tickets_sold = 0;\n        lottery.is_active = true;\n        Ok(())\n    }\n\n    pub fn buy_ticket(ctx: Context<BuyTicket>) -> Result<()> {\n        let lottery = &mut ctx.accounts.lottery;\n        require!(lottery.is_active, LotteryError::LotteryInactive);\n        require!(lottery.tickets_sold < lottery.max_tickets, LotteryError::SoldOut);\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.buyer_token_account.to_account_info(),\n                    to: ctx.accounts.lottery_token_account.to_account_info(),\n                    authority: ctx.accounts.buyer.to_account_info(),\n                },\n            ),\n            lottery.ticket_price,\n        )?;\n\n        lottery.tickets_sold += 1;\n        Ok(())\n    }\n\n    pub fn draw_winner(ctx: Context<DrawWinner>) -> Result<()> {\n        let lottery = &mut ctx.accounts.lottery;\n        let clock = Clock::get()?;\n\n        require!(lottery.is_active, LotteryError::LotteryInactive);\n        require!(clock.unix_timestamp >= lottery.draw_time, LotteryError::DrawTimeNotReached);\n\n        let winner_index = clock.unix_timestamp as u64 % lottery.tickets_sold;\n        let prize_amount = lottery.ticket_price * lottery.tickets_sold;\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.lottery_token_account.to_account_info(),\n                    to: ctx.accounts.winner_token_account.to_account_info(),\n                    authority: lottery.to_account_info(),\n                },\n                &[&[b\"lottery\".as_ref(), &[*ctx.bumps.get(\"lottery\").unwrap()]]],\n            ),\n            prize_amount,\n        )?;\n\n        lottery.is_active = false;\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct InitializeLottery<'info> {\n    #[account(init, payer = creator, space = 8 + 32 + 8 + 8 + 8 + 8 + 1, seeds = [b\"lottery\"], bump)]\n    pub lottery: Account<'info, Lottery>,\n    #[account(mut)]\n    pub creator: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct BuyTicket<'info> {\n    #[account(mut)]\n    pub lottery: Account<'info, Lottery>,\n    #[account(mut)]\n    pub buyer: Signer<'info>,\n    #[account(mut)]\n    pub buyer_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub lottery_token_account: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct DrawWinner<'info> {\n    #[account(mut)]\n    pub lottery: Account<'info, Lottery>,\n    #[account(mut)]\n    pub lottery_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub winner_token_account: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct Lottery {\n    pub creator: Pubkey,\n    pub ticket_price: u64,\n    pub max_tickets: u64,\n    pub draw_time: i64,\n    pub tickets_sold: u64,\n    pub is_active: bool,\n}\n\n#[error_code]\npub enum LotteryError {\n    #[msg(\"Lottery is not active\")]\n    LotteryInactive,\n    #[msg(\"Lottery is sold out\")]\n    SoldOut,\n    #[msg(\"Draw time has not been reached\")]\n    DrawTimeNotReached,\n}",
        "vulnerabilities": [
        "Deterministic randomness in winner selection, enabling participants to predict or influence outcomes",
        "Lack of access restrictions on winner drawing function, allowing unauthorized manipulation of results",
        "Absence of minimum participant threshold, potentially leading to unfair or economically non-viable draws"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\nmod vulnerable_vesting {\n    use super::*;\n\n    pub fn create_vesting_schedule(\n        ctx: Context<CreateVestingSchedule>,\n        total_amount: u64,\n        start_time: i64,\n        end_time: i64,\n        cliff_time: i64,\n    ) -> Result<()> {\n        let vesting = &mut ctx.accounts.vesting;\n        vesting.creator = ctx.accounts.creator.key();\n        vesting.beneficiary = ctx.accounts.beneficiary.key();\n        vesting.total_amount = total_amount;\n        vesting.start_time = start_time;\n        vesting.end_time = end_time;\n        vesting.cliff_time = cliff_time;\n        vesting.released_amount = 0;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.creator_token_account.to_account_info(),\n                    to: ctx.accounts.vesting_token_account.to_account_info(),\n                    authority: ctx.accounts.creator.to_account_info(),\n                },\n            ),\n            total_amount,\n        )?;\n\n        Ok(())\n    }\n\n    pub fn release_tokens(ctx: Context<ReleaseTokens>) -> Result<()> {\n        let vesting = &mut ctx.accounts.vesting;\n        let clock = Clock::get()?;\n        let current_time = clock.unix_timestamp;\n\n        require!(current_time >= vesting.cliff_time, VestingError::CliffNotReached);\n\n        let vesting_duration = vesting.end_time - vesting.start_time;\n        let time_elapsed = current_time - vesting.start_time;\n        let vested_amount = (vesting.total_amount as u128)\n            .checked_mul(time_elapsed as u128)\n            .unwrap()\n            .checked_div(vesting_duration as u128)\n            .unwrap() as u64;\n\n        let releasable_amount = vested_amount.checked_sub(vesting.released_amount).unwrap();\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.vesting_token_account.to_account_info(),\n                    to: ctx.accounts.beneficiary_token_account.to_account_info(),\n                    authority: vesting.to_account_info(),\n                },\n                &[&[b\"vesting\".as_ref(), vesting.creator.as_ref(), vesting.beneficiary.as_ref(), &[*ctx.bumps.get(\"vesting\").unwrap()]]],\n            ),\n            releasable_amount,\n        )?;\n\n        vesting.released_amount += releasable_amount;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct CreateVestingSchedule<'info> {\n    #[account(init, payer = creator, space = 8 + 32 + 32 + 8 + 8 + 8 + 8 + 8, seeds = [b\"vesting\", creator.key().as_ref(), beneficiary.key().as_ref()], bump)]\n    pub vesting: Account<'info, Vesting>,\n    #[account(mut)]\n    pub creator: Signer<'info>,\n    /// CHECK: This is not dangerous because we don't read or write from this account\n    pub beneficiary: AccountInfo<'info>,\n    #[account(mut)]\n    pub creator_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub vesting_token_account: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct ReleaseTokens<'info> {\n    #[account(mut)]\n    pub vesting: Account<'info, Vesting>,\n    #[account(mut)]\n    pub vesting_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub beneficiary_token_account: Account<'info, TokenAccount>,\n    pub beneficiary: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct Vesting {\n    pub creator: Pubkey,\n    pub beneficiary: Pubkey,\n    pub total_amount: u64,\n    pub start_time: i64,\n    pub end_time: i64,\n    pub cliff_time: i64,\n    pub released_amount: u64,\n}\n\n#[error_code]\npub enum VestingError {\n    #[msg(\"Cliff period has not been reached\")]\n    CliffNotReached,\n}",
        "vulnerabilities": [
            "Potential rounding errors in vesting calculations, leading to discrepancies in token distribution over time",
            "Unrestricted token release function, allowing unauthorized withdrawal of vested tokens",
            "Insufficient validation of vesting schedule parameters, risking creation of invalid or exploitable vesting terms"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\nmod vulnerable_swap {\n    use super::*;\n\n    pub fn initialize_pool(\n        ctx: Context<InitializePool>,\n        fee_numerator: u64,\n        fee_denominator: u64,\n    ) -> Result<()> {\n        let pool = &mut ctx.accounts.pool;\n        pool.token_a_account = ctx.accounts.token_a_account.key();\n        pool.token_b_account = ctx.accounts.token_b_account.key();\n        pool.fee_numerator = fee_numerator;\n        pool.fee_denominator = fee_denominator;\n        Ok(())\n    }\n\n    pub fn swap(\n        ctx: Context<Swap>,\n        amount_in: u64,\n        minimum_amount_out: u64,\n    ) -> Result<()> {\n        let pool = &ctx.accounts.pool;\n\n        let balance_a = ctx.accounts.token_a_account.amount;\n        let balance_b = ctx.accounts.token_b_account.amount;\n\n        let amount_out = (balance_b as u128)\n            .checked_mul(amount_in as u128)\n            .unwrap()\n            .checked_div(balance_a.checked_add(amount_in).unwrap() as u128)\n            .unwrap() as u64;\n\n        let fee = amount_out\n            .checked_mul(pool.fee_numerator)\n            .unwrap()\n            .checked_div(pool.fee_denominator)\n            .unwrap();\n\n        let amount_out_after_fee = amount_out.checked_sub(fee).unwrap();\n\n        require!(amount_out_after_fee >= minimum_amount_out, SwapError::SlippageExceeded);\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_a_account.to_account_info(),\n                    to: ctx.accounts.token_a_account.to_account_info(),\n                    authority: ctx.accounts.user.to_account_info(),\n                },\n            ),\n            amount_in,\n        )?;\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.token_b_account.to_account_info(),\n                    to: ctx.accounts.user_token_b_account.to_account_info(),\n                    authority: pool.to_account_info(),\n                },\n                &[&[b\"pool\".as_ref(), &[*ctx.bumps.get(\"pool\").unwrap()]]],\n            ),\n            amount_out_after_fee,\n        )?;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct InitializePool<'info> {\n    #[account(init, payer = creator, space = 8 + 32 + 32 + 8 + 8, seeds = [b\"pool\"], bump)]\n    pub pool: Account<'info, Pool>,\n    #[account(mut)]\n    pub creator: Signer<'info>,\n    pub token_a_account: Account<'info, TokenAccount>,\n    pub token_b_account: Account<'info, TokenAccount>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Swap<'info> {\n    #[account(mut)]\n    pub pool: Account<'info, Pool>,\n    #[account(mut)]\n    pub token_a_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub token_b_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub user_token_a_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub user_token_b_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct Pool {\n    pub token_a_account: Pubkey,\n    pub token_b_account: Pubkey,\n    pub fee_numerator: u64,\n    pub fee_denominator: u64,\n}\n\n#[error_code]\npub enum SwapError {\n    #[msg(\"Slippage tolerance exceeded\")]\n    SlippageExceeded,\n}",
        "vulnerabilities": [
            "Missing liquidity verification before operations, potentially leading to failed transactions or extreme slippage",
            "Unprotected pool initialization function, allowing unauthorized setting or alteration of crucial pool parameters",
            "Lack of transaction ordering protection, exposing users to potential value extraction through front-running"
        ]
    },
    
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\ndeclare_id!(\"Swap11111111111111111111111111111111111111\");\n\n#[program]\npub mod vulnerable_token_swap {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {\n        let swap_pool = &mut ctx.accounts.swap_pool;\n        swap_pool.authority = ctx.accounts.authority.key();\n        swap_pool.token_a_balance = 0;\n        swap_pool.token_b_balance = 0;\n        Ok(())\n    }\n\n    pub fn deposit(ctx: Context<Deposit>, amount_a: u64, amount_b: u64) -> Result<()> {\n        let swap_pool = &mut ctx.accounts.swap_pool;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_a.to_account_info(),\n                    to: ctx.accounts.pool_token_a.to_account_info(),\n                    authority: ctx.accounts.user.to_account_info(),\n                },\n            ),\n            amount_a,\n        )?;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_b.to_account_info(),\n                    to: ctx.accounts.pool_token_b.to_account_info(),\n                    authority: ctx.accounts.user.to_account_info(),\n                },\n            ),\n            amount_b,\n        )?;\n\n        swap_pool.token_a_balance += amount_a;\n        swap_pool.token_b_balance += amount_b;\n\n        Ok(())\n    }\n\n    pub fn swap(ctx: Context<Swap>, amount_in: u64, min_amount_out: u64) -> Result<()> {\n        let swap_pool = &mut ctx.accounts.swap_pool;\n        let token_a_balance = swap_pool.token_a_balance;\n        let token_b_balance = swap_pool.token_b_balance;\n\n        // Vulnerability 1: No slippage protection\n        let amount_out = (amount_in * token_b_balance) / token_a_balance;\n\n        // Vulnerability 2: No check for minimum output amount\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_a.to_account_info(),\n                    to: ctx.accounts.pool_token_a.to_account_info(),\n                    authority: ctx.accounts.user.to_account_info(),\n                },\n            ),\n            amount_in,\n        )?;\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.pool_token_b.to_account_info(),\n                    to: ctx.accounts.user_token_b.to_account_info(),\n                    authority: swap_pool.to_account_info(),\n                },\n                &[&[&swap_pool.authority.to_bytes(), &[*ctx.bumps.get(\"swap_pool\").unwrap()]]],\n            ),\n            amount_out,\n        )?;\n\n        swap_pool.token_a_balance += amount_in;\n        swap_pool.token_b_balance -= amount_out;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 8 + 8)]\n    pub swap_pool: Account<'info, SwapPool>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Deposit<'info> {\n    #[account(mut)]\n    pub swap_pool: Account<'info, SwapPool>,\n    pub user: Signer<'info>,\n    #[account(mut)]\n    pub user_token_a: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub user_token_b: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_a: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_b: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct Swap<'info> {\n    #[account(mut)]\n    pub swap_pool: Account<'info, SwapPool>,\n    pub user: Signer<'info>,\n    #[account(mut)]\n    pub user_token_a: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub user_token_b: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_a: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_b: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct SwapPool {\n    pub authority: Pubkey,\n    pub token_a_balance: u64,\n    pub token_b_balance: u64,\n}",
        "vulnerabilities": [
            "No slippage protection: The swap function calculates the output amount without considering potential price impact, which could lead to unfavorable trades for users.",
            "No check for minimum output amount: The swap function doesn't verify if the calculated output amount meets the user's minimum expectations, potentially leading to unexpected losses.",
            "Lack of access control: There's no check to ensure that only authorized users can call sensitive functions like initialize or deposit."
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\n\ndeclare_id!(\"Escr11111111111111111111111111111111111111\");\n\n#[program]\npub mod vulnerable_escrow {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, amount: u64) -> Result<()> {\n        let escrow = &mut ctx.accounts.escrow;\n        escrow.seller = ctx.accounts.seller.key();\n        escrow.buyer = ctx.accounts.buyer.key();\n        escrow.amount = amount;\n        escrow.is_completed = false;\n        Ok(())\n    }\n\n    pub fn deposit(ctx: Context<Deposit>) -> Result<()> {\n        let escrow = &mut ctx.accounts.escrow;\n        let seller = &ctx.accounts.seller;\n\n        // Vulnerability 1: No check if the deposit has already been made\n        escrow.is_deposited = true;\n        Ok(())\n    }\n\n    pub fn complete(ctx: Context<Complete>) -> Result<()> {\n        let escrow = &mut ctx.accounts.escrow;\n\n        // Vulnerability 2: No check if the escrow has already been completed\n        escrow.is_completed = true;\n\n        // Vulnerability 3: No actual transfer of funds\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = seller, space = 8 + 32 + 32 + 8 + 1 + 1)]\n    pub escrow: Account<'info, Escrow>,\n    #[account(mut)]\n    pub seller: Signer<'info>,\n    /// CHECK: This is not dangerous because we don't read or write from this account\n    pub buyer: AccountInfo<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Deposit<'info> {\n    #[account(mut)]\n    pub escrow: Account<'info, Escrow>,\n    pub seller: Signer<'info>,\n}\n\n#[derive(Accounts)]\npub struct Complete<'info> {\n    #[account(mut)]\n    pub escrow: Account<'info, Escrow>,\n    pub buyer: Signer<'info>,\n}\n\n#[account]\npub struct Escrow {\n    pub seller: Pubkey,\n    pub buyer: Pubkey,\n    pub amount: u64,\n    pub is_deposited: bool,\n    pub is_completed: bool,\n}",
        "vulnerabilities": [
            "No check if deposit has already been made: The deposit function doesn't verify if the funds have already been deposited, potentially allowing multiple deposits.",
            "No check if escrow has already been completed: The complete function doesn't verify if the escrow has already been completed, potentially allowing multiple completions.",
            "No actual transfer of funds: The escrow doesn't handle the actual transfer of tokens or SOL, making it non-functional as an escrow system."
        ]
    },
    {
      "code": "use solana_program::{\n    account_info::{next_account_info, AccountInfo},\n    entrypoint::ProgramResult,\n    pubkey::Pubkey,\n    msg,\n};\n\npub fn process_instruction(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    instruction_data: &[u8],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let signer_account = next_account_info(account_info_iter)?;\n\n    if !signer_account.is_signer {\n        return Err(ProgramError::MissingRequiredSignature);\n    }\n\n    let signature = signer_account.try_borrow_data()?;\n    msg!(\"Received signature: {:?}\", signature);\n\n    // Verify signature here\n    // ...\n\n    Ok(())\n}",
      "vulnerabilities": [
        "Lack of signature verification",
        "Lack of access control",
        "Potential for unauthorized actions",
        "Lack of input validation"
      ]
    },
    {
      "code": "use solana_program::{\n    account_info::{next_account_info, AccountInfo},\n    entrypoint::ProgramResult,\n    program_error::ProgramError,\n    pubkey::Pubkey,\n    msg,\n};\n\npub fn process_instruction(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    instruction_data: &[u8],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let user_account = next_account_info(account_info_iter)?;\n\n    if !user_account.is_signer {\n        return Err(ProgramError::MissingRequiredSignature);\n    }\n\n    match some_function(user_account) {\n        Ok(_) => msg!(\"Function executed successfully\"),\n        Err(e) => {\n            msg!(\"Error occurred: {:?}\", e);\n            return Err(e);\n        }\n    }\n\n    Ok(())\n}\n\nfn some_function(account: &AccountInfo) -> Result<(), ProgramError> {\n    // ... some logic that might return an error ...\n    Ok(())\n}",
      "vulnerabilities": [
            "Insufficient error handling may lead to unexpected contract behavior and potential exploitation of failed operations.",
            "Unmanaged exceptions could cause contract to halt or behave unpredictably, potentially leaving funds locked or vulnerable.",
            "Absence of robust input validation exposes the contract to malicious data injection and potential exploitation.",
            "Inadequate authorization checks may allow unauthorized users to perform restricted actions, compromising contract security."
        ]
    },
    {
      "code": "use solana_program::{\n    account_info::{next_account_info, AccountInfo},\n    entrypoint::ProgramResult,\n    program::invoke,\n    pubkey::Pubkey,\n    msg,\n};\n\npub fn process_instruction(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    instruction_data: &[u8],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let user_account = next_account_info(account_info_iter)?;\n    let external_contract = next_account_info(account_info_iter)?;\n\n    if !user_account.is_signer {\n        return Err(ProgramError::MissingRequiredSignature);\n    }\n\n    msg!(\"Invoking external contract\");\n    invoke(\n        &instruction_data,\n        &[user_account.clone(), external_contract.clone()],\n    )?;\n\n    msg!(\"External contract invocation completed\");\n    Ok(())\n}",
      "vulnerabilities": [
            "Unchecked external contract calls risk unexpected behavior or malicious code execution, potentially compromising contract integrity.",
            "Lack of thorough input sanitization leaves the contract susceptible to injection attacks and manipulation of critical parameters.",
            "Missing or inadequate reentrancy guards allow malicious contracts to recursively call functions, potentially draining funds or corrupting state.",
            "Insufficient access control mechanisms may permit unauthorized users to execute privileged functions, compromising contract security."
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\npub mod vulnerable_flash_loan {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, fee_rate: u64) -> Result<()> {\n        let flash_loan_pool = &mut ctx.accounts.flash_loan_pool;\n        flash_loan_pool.authority = ctx.accounts.authority.key();\n        flash_loan_pool.fee_rate = fee_rate;\n        Ok(())\n    }\n\n    pub fn deposit(ctx: Context<Deposit>, amount: u64) -> Result<()> {\n        let flash_loan_pool = &mut ctx.accounts.flash_loan_pool;\n        let user = &ctx.accounts.user;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_account.to_account_info(),\n                    to: ctx.accounts.pool_token_account.to_account_info(),\n                    authority: user.to_account_info(),\n                },\n            ),\n            amount,\n        )?;\n\n        flash_loan_pool.total_deposits += amount;\n        Ok(())\n    }\n\n    pub fn flash_loan(ctx: Context<FlashLoan>, amount: u64) -> Result<()> {\n        let flash_loan_pool = &mut ctx.accounts.flash_loan_pool;\n        let user = &ctx.accounts.user;\n\n        require!(amount <= flash_loan_pool.total_deposits, ErrorCode::InsufficientFunds);\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.pool_token_account.to_account_info(),\n                    to: ctx.accounts.user_token_account.to_account_info(),\n                    authority: flash_loan_pool.to_account_info(),\n                },\n                &[&[&flash_loan_pool.authority.to_bytes(), &[*ctx.bumps.get(\"flash_loan_pool\").unwrap()]]],\n            ),\n            amount,\n        )?;\n\n        // User's custom logic goes here\n\n        let fee = amount * flash_loan_pool.fee_rate / 10000;\n        let repay_amount = amount + fee;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_account.to_account_info(),\n                    to: ctx.accounts.pool_token_account.to_account_info(),\n                    authority: user.to_account_info(),\n                },\n            ),\n            repay_amount,\n        )?;\n\n        flash_loan_pool.total_deposits += fee;\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 8 + 8)]\n    pub flash_loan_pool: Account<'info, FlashLoanPool>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Deposit<'info> {\n    #[account(mut)]\n    pub flash_loan_pool: Account<'info, FlashLoanPool>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct FlashLoan<'info> {\n    #[account(mut)]\n    pub flash_loan_pool: Account<'info, FlashLoanPool>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct FlashLoanPool {\n    pub authority: Pubkey,\n    pub fee_rate: u64,\n    pub total_deposits: u64,\n}\n\n#[error_code]\npub enum ErrorCode {\n    #[msg(\"Insufficient funds in the pool\")]\n    InsufficientFunds,\n}",
        "vulnerabilities": [
            "Unprotected state changes in flash_loan function enable malicious reentrancy, potentially leading to fund drainage or contract manipulation.",
            "Absence of slippage checks in deposit and flash_loan functions exposes users to front-running and unfavorable exchange rates.",
            "Lack of proper access restrictions on critical functions allows unauthorized users to perform privileged operations, compromising contract integrity."
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\ndeclare_id!(\"Stak11111111111111111111111111111111111111\");\n\n#[program]\npub mod vulnerable_staking {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {\n        let staking_pool = &mut ctx.accounts.staking_pool;\n        staking_pool.authority = ctx.accounts.authority.key();\n        staking_pool.total_staked = 0;\n        Ok(())\n    }\n\n    pub fn stake(ctx: Context<Stake>, amount: u64) -> Result<()> {\n        let staking_pool = &mut ctx.accounts.staking_pool;\n        let user = &mut ctx.accounts.user;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_account.to_account_info(),\n                    to: ctx.accounts.pool_token_account.to_account_info(),\n                    authority: user.to_account_info(),\n                },\n            ),\n            amount,\n        )?;\n\n        user.staked_amount += amount;\n        staking_pool.total_staked += amount;\n\n        Ok(())\n    }\n\n    pub fn unstake(ctx: Context<Unstake>, amount: u64) -> Result<()> {\n        let staking_pool = &mut ctx.accounts.staking_pool;\n        let user = &mut ctx.accounts.user;\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.pool_token_account.to_account_info(),\n                    to: ctx.accounts.user_token_account.to_account_info(),\n                    authority: staking_pool.to_account_info(),\n                },\n                &[&[&staking_pool.authority.to_bytes(), &[*ctx.bumps.get(\"staking_pool\").unwrap()]]],\n            ),\n            amount,\n        )?;\n\n        user.staked_amount -= amount;\n        staking_pool.total_staked -= amount;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 8)]\n    pub staking_pool: Account<'info, StakingPool>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Stake<'info> {\n    #[account(mut)]\n    pub staking_pool: Account<'info, StakingPool>,\n    #[account(mut)]\n    pub user: Account<'info, User>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_account: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct Unstake<'info> {\n    #[account(mut)]\n    pub staking_pool: Account<'info, StakingPool>,\n    #[account(mut)]\n    pub user: Account<'info, User>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_account: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct StakingPool {\n    pub authority: Pubkey,\n    pub total_staked: u64,\n}\n\n#[account]\npub struct User {\n    pub staked_amount: u64,\n}",
        "vulnerabilities": [
            "Inadequate access control mechanisms potentially allow unauthorized users to execute restricted functions, compromising contract security.",
            "Unchecked arithmetic operations risk integer overflow, leading to unexpected behavior and potential fund loss.",
            "Failure to validate staking periods may result in exploitation of reward mechanisms or unexpected contract behavior."
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\n\ndeclare_id!(\"Lott11111111111111111111111111111111111111\");\n\n#[program]\npub mod vulnerable_lottery {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, ticket_price: u64) -> Result<()> {\n        let lottery = &mut ctx.accounts.lottery;\n        lottery.admin = ctx.accounts.admin.key();\n        lottery.ticket_price = ticket_price;\n        lottery.total_tickets = 0;\n        lottery.is_completed = false;\n        Ok(())\n    }\n\n    pub fn buy_ticket(ctx: Context<BuyTicket>) -> Result<()> {\n        let lottery = &mut ctx.accounts.lottery;\n        let player = &ctx.accounts.player;\n\n        // Vulnerability 1: No check if the lottery is still open\n        lottery.total_tickets += 1;\n\n        // Vulnerability 2: No actual payment for the ticket\n        Ok(())\n    }\n\n    pub fn draw_winner(ctx: Context<DrawWinner>) -> Result<()> {\n        let lottery = &mut ctx.accounts.lottery;\n\n        // Vulnerability 3: Predictable randomness\n        let winner_index = Clock::get()?.unix_timestamp % lottery.total_tickets as i64;\n        lottery.winner = Some(winner_index as u64);\n        lottery.is_completed = true;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = admin, space = 8 + 32 + 8 + 8 + 1 + 8)]\n    pub lottery: Account<'info, Lottery>,\n    #[account(mut)]\n    pub admin: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct BuyTicket<'info> {\n    #[account(mut)]\n    pub lottery: Account<'info, Lottery>,\n    pub player: Signer<'info>,\n}\n\n#[derive(Accounts)]\npub struct DrawWinner<'info> {\n    #[account(mut)]\n    pub lottery: Account<'info, Lottery>,\n    pub admin: Signer<'info>,\n}\n\n#[account]\npub struct Lottery {\n    pub admin: Pubkey,\n    pub ticket_price: u64,\n    pub total_tickets: u64,\n    pub is_completed: bool,\n    pub winner: Option<u64>,\n}",
        "vulnerabilities": [
            "No check if lottery is still open: The buy_ticket function doesn't verify if the lottery is still open, potentially allowing ticket purchases after the drawing.",
            "No actual payment for tickets: The buy_ticket function doesn't handle the transfer of funds for purchasing tickets, making the lottery effectively free to enter.",
            "Predictable randomness: The draw_winner function uses a predictable source of randomness (blockchain timestamp), which could be manipulated by miners or validators."
        ]
    },
    {
      "code": "use solana_program::{\n    account_info::{next_account_info, AccountInfo},\n    entrypoint::ProgramResult,\n    pubkey::Pubkey,\n    msg,\n};\n\npub fn process_instruction(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    instruction_data: &[u8],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let signer_account = next_account_info(account_info_iter)?;\n\n    if !signer_account.is_signer {\n        return Err(ProgramError::MissingRequiredSignature);\n    }\n\n    let signature = signer_account.try_borrow_data()?;\n    msg!(\"Received signature: {:?}\", signature);\n\n    // TODO: Implement signature verification\n    // ...\n\n    Ok(())\n}",
      "vulnerabilities": [
            "Inadequate authentication: No signature verification implemented, allowing potential impersonation or unauthorized access",
            "Insufficient authorization: Lack of access control mechanisms, enabling any user to perform restricted operations",
            "Security breach risk: Potential for unauthorized actions due to missing or inadequate security checks",
            "Data integrity issues: Absence of input validation, potentially leading to injection attacks or unexpected behavior"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\npub mod escrow {\n    use super::*;\n\n    pub fn create_escrow(ctx: Context<CreateEscrow>, amount: u64) -> Result<()> {\n        let escrow = &mut ctx.accounts.escrow;\n        escrow.amount = amount;\n        escrow.sender = ctx.accounts.sender.key();\n        escrow.recipient = ctx.accounts.recipient.key();\n        Ok(())\n    }\n\n    pub fn release_funds(ctx: Context<ReleaseFunds>) -> Result<()> {\n        let escrow = &ctx.accounts.escrow;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.escrow_account.to_account_info(),\n                    to: ctx.accounts.recipient_account.to_account_info(),\n                    authority: ctx.accounts.sender.to_account_info(),\n                },\n            ),\n            escrow.amount,\n        )?;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct CreateEscrow<'info> {\n    #[account(init, payer = sender, space = 8 + 32 + 32 + 8)]\n    pub escrow: Account<'info, Escrow>,\n    #[account(mut)]\n    pub sender: Signer<'info>,\n    #[account(mut)]\n    pub recipient: AccountInfo<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct ReleaseFunds<'info> {\n    #[account(mut)]\n    pub escrow: Account<'info, Escrow>,\n    #[account(mut)]\n    pub escrow_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub recipient_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub sender: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct Escrow {\n    pub sender: Pubkey,\n    pub recipient: Pubkey,\n    pub amount: u64,\n}\n\n#[error_code]\npub enum EscrowError {\n    #[msg(\"No funds available\")]\n    NoFundsAvailable,\n}",
        "vulnerabilities": [
            "Immediate fund accessibility: No timelock mechanism implemented for fund withdrawals, potentially compromising security",
            "Recipient authentication flaw: Lack of verification process for fund recipients, risking misdirected transfers"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n#[program]\npub mod vulnerable_exchange {\n    use super::*;\n    pub fn initialize(ctx: Context<Initialize>, fee_rate: u64) -> Result<()> {\n        let exchange = &mut ctx.accounts.exchange;\n        exchange.authority = ctx.accounts.authority.key();\n        exchange.fee_rate = fee_rate;\n        Ok(())\n    }\n    pub fn create_order(ctx: Context<CreateOrder>, amount: u64, price: u64) -> Result<()> {\n        let exchange = &mut ctx.accounts.exchange;\n        let order = &mut ctx.accounts.order;\n        order.owner = ctx.accounts.user.key();\n        order.amount = amount;\n        order.price = price;\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_account.to_account_info(),\n                    to: ctx.accounts.exchange_token_account.to_account_info(),\n                    authority: ctx.accounts.user.to_account_info(),\n                },\n            ),\n            amount,\n        )?;\n        exchange.orders.push(*order.to_account_info().key);\n        Ok(())\n    }\n    pub fn execute_order(ctx: Context<ExecuteOrder>) -> Result<()> {\n        let exchange = &mut ctx.accounts.exchange;\n        let order = &ctx.accounts.order;\n        let amount = order.amount;\n        let price = order.price;\n        let total = amount.checked_mul(price).ok_or(ErrorCode::Overflow)?;\n        let fee = total.checked_mul(exchange.fee_rate).ok_or(ErrorCode::Overflow)?.checked_div(10000).ok_or(ErrorCode::Overflow)?;\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.buyer_token_account.to_account_info(),\n                    to: ctx.accounts.seller_token_account.to_account_info(),\n                    authority: ctx.accounts.buyer.to_account_info(),\n                },\n            ),\n            total,\n        )?;\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.exchange_token_account.to_account_info(),\n                    to: ctx.accounts.buyer_token_account.to_account_info(),\n                    authority: exchange.to_account_info(),\n                },\n            ),\n            amount,\n        )?;\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.buyer_token_account.to_account_info(),\n                    to: ctx.accounts.exchange_fee_account.to_account_info(),\n                    authority: ctx.accounts.buyer.to_account_info(),\n                },\n            ),\n            fee,\n        )?;\n        exchange.orders.retain(|&x| x != *order.to_account_info().key);\n        Ok(())\n    }\n}\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 8 + 64)]\n    pub exchange: Account<'info, Exchange>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n#[derive(Accounts)]\npub struct CreateOrder<'info> {\n    #[account(mut)]\n    pub exchange: Account<'info, Exchange>,\n    #[account(init, payer = user, space = 8 + 32 + 8 + 8)]\n    pub order: Account<'info, Order>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub exchange_token_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n    pub system_program: Program<'info, System>,\n}\n#[derive(Accounts)]\npub struct ExecuteOrder<'info> {\n    #[account(mut)]\n    pub exchange: Account<'info, Exchange>,\n    #[account(mut)]\n    pub order: Account<'info, Order>,\n    #[account(mut)]\n    pub buyer_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub seller_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub exchange_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub exchange_fee_account: Account<'info, TokenAccount>,\n    pub buyer: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n#[account]\npub struct Exchange {\n    pub authority: Pubkey,\n    pub fee_rate: u64,\n    pub orders: Vec<Pubkey>,\n}\n#[account]\npub struct Order {\n    pub owner: Pubkey,\n    pub amount: u64,\n    pub price: u64,\n}",
        "vulnerabilities": [
            "Unrestricted order execution: Lack of access control in execute_order function, allowing unauthorized users to process orders",
            "Arithmetic vulnerability: Potential integer overflow in fee calculation, possibly leading to incorrect fee amounts",
            "Limited user control: Missing order cancellation functionality, preventing users from retracting their orders"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n#[program]\npub mod vulnerable_staking {\n    use super::*;\n    pub fn initialize(ctx: Context<Initialize>, reward_rate: u64) -> Result<()> {\n        let staking_pool = &mut ctx.accounts.staking_pool;\n        staking_pool.authority = ctx.accounts.authority.key();\n        staking_pool.reward_rate = reward_rate;\n        staking_pool.last_update_time = Clock::get()?.unix_timestamp;\n        Ok(())\n    }\n    pub fn stake(ctx: Context<Stake>, amount: u64) -> Result<()> {\n        let staking_pool = &mut ctx.accounts.staking_pool;\n        let user = &ctx.accounts.user;\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_account.to_account_info(),\n                    to: ctx.accounts.pool_token_account.to_account_info(),\n                    authority: user.to_account_info(),\n                },\n            ),\n            amount,\n        )?;\n        let user_stake = staking_pool.user_stakes.entry(user.key()).or_insert(0);\n        *user_stake += amount;\n        staking_pool.total_staked += amount;\n        Ok(())\n    }\n    pub fn unstake(ctx: Context<Unstake>, amount: u64) -> Result<()> {\n        let staking_pool = &mut ctx.accounts.staking_pool;\n        let user = &ctx.accounts.user;\n        let user_stake = staking_pool.user_stakes.get_mut(&user.key()).unwrap();\n        require!(*user_stake >= amount, ErrorCode::InsufficientStake);\n        *user_stake -= amount;\n        staking_pool.total_staked -= amount;\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.pool_token_account.to_account_info(),\n                    to: ctx.accounts.user_token_account.to_account_info(),\n                    authority: staking_pool.to_account_info(),\n                },\n                &[&[&staking_pool.authority.to_bytes(), &[*ctx.bumps.get(\"staking_pool\").unwrap()]]],\n            ),\n            amount,\n        )?;\n        Ok(())\n    }\n    pub fn claim_rewards(ctx: Context<ClaimRewards>) -> Result<()> {\n        let staking_pool = &mut ctx.accounts.staking_pool;\n        let user = &ctx.accounts.user;\n        let current_time = Clock::get()?.unix_timestamp;\n        let time_elapsed = (current_time - staking_pool.last_update_time) as u64;\n        let rewards = (staking_pool.user_stakes[&user.key()] * staking_pool.reward_rate * time_elapsed) / 86400;\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.reward_token_account.to_account_info(),\n                    to: ctx.accounts.user_reward_account.to_account_info(),\n                    authority: staking_pool.to_account_info(),\n                },\n                &[&[&staking_pool.authority.to_bytes(), &[*ctx.bumps.get(\"staking_pool\").unwrap()]]],\n            ),\n            rewards,\n        )?;\n        staking_pool.last_update_time = current_time;\n        Ok(())\n    }\n}\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 8 + 8 + 64 + 64)]\n    pub staking_pool: Account<'info, StakingPool>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n#[derive(Accounts)]\npub struct Stake<'info> {\n    #[account(mut)]\n    pub staking_pool: Account<'info, StakingPool>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n#[derive(Accounts)]\npub struct Unstake<'info> {\n    #[account(mut)]\n    pub staking_pool: Account<'info, StakingPool>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n#[derive(Accounts)]\npub struct ClaimRewards<'info> {\n    #[account(mut)]\n    pub staking_pool: Account<'info, StakingPool>,\n    #[account(mut)]\n    pub reward_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub user_reward_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n#[account]\npub struct StakingPool {\n    pub authority: Pubkey,\n    pub reward_rate: u64,\n    pub last_update_time: i64,\n    pub total_staked: u64,\n    pub user_stakes: std::collections::HashMap<Pubkey, u64>,\n}",
        "vulnerabilities": [
            "Inaccurate reward distribution: Rounding down in reward calculation causing precision loss and potential unfair distributions",
            "Inadequate penalty system: Lack of slashing mechanism for misbehaving stakers, reducing protocol security incentives",
            "Potential reward insolvency: Missing checks for reward token balance in claim_rewards function, risking failed reward distributions"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\npub mod vulnerable_nft_marketplace {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, fee_rate: u64) -> Result<()> {\n        let marketplace = &mut ctx.accounts.marketplace;\n        marketplace.authority = ctx.accounts.authority.key();\n        marketplace.fee_rate = fee_rate;\n        Ok(())\n    }\n\n    pub fn list_nft(ctx: Context<ListNFT>, price: u64) -> Result<()> {\n        let marketplace = &mut ctx.accounts.marketplace;\n        let listing = &mut ctx.accounts.listing;\n        let user = &ctx.accounts.user;\n\n        listing.seller = user.key();\n        listing.nft_mint = ctx.accounts.nft_mint.key();\n        listing.price = price;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_nft_account.to_account_info(),\n                    to: ctx.accounts.escrow_nft_account.to_account_info(),\n                    authority: user.to_account_info(),\n                },\n            ),\n            1,\n        )?;\n\n        marketplace.listings.push(listing.key());\n        Ok(())\n    }\n\n    pub fn buy_nft(ctx: Context<BuyNFT>) -> Result<()> {\n        let marketplace = &mut ctx.accounts.marketplace;\n        let listing = &ctx.accounts.listing;\n        let buyer = &ctx.accounts.buyer;\n\n        let fee = listing.price * marketplace.fee_rate / 10000;\n        let seller_amount = listing.price - fee;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.buyer_token_account.to_account_info(),\n                    to: ctx.accounts.seller_token_account.to_account_info(),\n                    authority: buyer.to_account_info(),\n                },\n            ),\n            seller_amount,\n        )?;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.buyer_token_account.to_account_info(),\n                    to: ctx.accounts.marketplace_token_account.to_account_info(),\n                    authority: buyer.to_account_info(),\n                },\n            ),\n            fee,\n        )?;\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.escrow_nft_account.to_account_info(),\n                    to: ctx.accounts.buyer_nft_account.to_account_info(),\n                    authority: marketplace.to_account_info(),\n                },\n                &[&[&marketplace.authority.to_bytes(), &[*ctx.bumps.get(\"marketplace\").unwrap()]]],\n            ),\n            1,\n        )?;\n\n        marketplace.listings.retain(|&x| x != listing.key());\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 8 + 64)]\n    pub marketplace: Account<'info, Marketplace>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct ListNFT<'info> {\n    #[account(mut)]\n    pub marketplace: Account<'info, Marketplace>,\n    #[account(init, payer = user, space = 8 + 32 + 32 + 8)]\n    pub listing: Account<'info, Listing>,\n    pub nft_mint: Account<'info, Mint>,\n    #[account(mut)]\n    pub user_nft_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub escrow_nft_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct BuyNFT<'info> {\n    #[account(mut)]\n    pub marketplace: Account<'info, Marketplace>,\n    #[account(mut)]\n    pub listing: Account<'info, Listing>,\n    #[account(mut)]\n    pub buyer_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub seller_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub marketplace_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub escrow_nft_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub buyer_nft_account: Account<'info, TokenAccount>,\n    pub buyer: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct Marketplace {\n    pub authority: Pubkey,\n    pub fee_rate: u64,\n    pub listings: Vec<Pubkey>,\n}\n\n#[account]\npub struct Listing {\n    pub seller: Pubkey,\n    pub nft_mint: Pubkey,\n    pub price: u64,\n}",
        "vulnerabilities": [
            "Arithmetic vulnerability: Potential integer overflow in fee calculation, possibly leading to incorrect fee amounts",
            "Asset verification flaw: Lack of check for NFT authenticity, risking transactions with counterfeit assets",
            "Limited user control: Missing cancellation functionality for listings, preventing sellers from retracting their offers"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\ndeclare_id!(\"Vuln99999999999999999999999999999999999999\");\n\n#[program]\npub mod vulnerable_flashloan {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {\n        ctx.accounts.pool.authority = ctx.accounts.authority.key();\n        Ok(())\n    }\n\n    pub fn flash_loan(ctx: Context<FlashLoan>, amount: u64) -> Result<()> {\n        let pool = &ctx.accounts.pool;\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.pool_token.to_account_info(),\n                    to: ctx.accounts.borrower_token.to_account_info(),\n                    authority: pool.to_account_info(),\n                },\n                &[&[&pool.key().to_bytes(), &[*ctx.bumps.get(\"pool\").unwrap()]]],\n            ),\n            amount,\n        )?;\n\n        // Borrower's logic would go here\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.borrower_token.to_account_info(),\n                    to: ctx.accounts.pool_token.to_account_info(),\n                    authority: ctx.accounts.borrower.to_account_info(),\n                },\n            ),\n            amount,\n        )?;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32)]\n    pub pool: Account<'info, Pool>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct FlashLoan<'info> {\n    #[account(mut)]\n    pub pool: Account<'info, Pool>,\n    #[account(mut)]\n    pub borrower: Signer<'info>,\n    #[account(mut)]\n    pub pool_token: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub borrower_token: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct Pool {\n    pub authority: Pubkey,\n}",
        "vulnerabilities": [
            "Economic exploit risk: No fee mechanism for flash loans, potentially allowing costless capital utilization",
            "Unrestricted loan access: Lack of access control on flash_loan function, enabling unauthorized borrowing",
            "Account verification flaw: Missing checks for borrower's token account ownership, risking unauthorized fund access",
            "Smart contract vulnerability: No reentrancy protection, exposing the contract to potential recursive calls and fund drainage"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\n\ndeclare_id!(\"VulnAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\");\n\n#[program]\npub mod vulnerable_timelock {\n    use super::*;\n\n    pub fn create_timelock(ctx: Context<CreateTimelock>, release_time: i64, amount: u64) -> Result<()> {\n        let timelock = &mut ctx.accounts.timelock;\n        timelock.owner = ctx.accounts.owner.key();\n        timelock.release_time = release_time;\n        timelock.amount = amount;\n        timelock.is_released = false;\n        Ok(())\n    }\n\n    pub fn release(ctx: Context<Release>) -> Result<()> {\n        let timelock = &mut ctx.accounts.timelock;\n        let clock = Clock::get()?;\n\n        require!(!timelock.is_released, ErrorCode::AlreadyReleased);\n        require!(clock.unix_timestamp >= timelock.release_time, ErrorCode::TooEarly);\n\n        timelock.is_released = true;\n        // Transfer funds to owner would happen here\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct CreateTimelock<'info> {\n    #[account(init, payer = owner, space = 8 + 32 + 8 + 8 + 1)]\n    pub timelock: Account<'info, Timelock>,\n    #[account(mut)]\n    pub owner: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Release<'info> {\n    #[account(mut)]\n    pub timelock: Account<'info, Timelock>,\n    pub owner: Signer<'info>,\n}\n\n#[account]\npub struct Timelock {\n    pub owner: Pubkey,\n    pub release_time: i64,\n    pub amount: u64,\n    pub is_released: bool,\n}\n\n#[error_code]\npub enum ErrorCode {\n    #[msg(\"Funds have already been released\")]\n    AlreadyReleased,\n    #[msg(\"It's too early to release the funds\")]\n    TooEarly,\n}",
        "vulnerabilities": [
            "Ineffective fund protection: No actual token locking mechanism implemented, potentially allowing premature withdrawals",
            "Limited contract management: Lack of admin or recovery functions, hindering contract upgrades or emergency interventions",
            "Unrestricted fund release: Missing access control in release function, allowing unauthorized fund releases",
            "Reduced transparency: No event emission for important state changes, making it difficult to track contract activities"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\nmod vulnerable_flash_loan {\n    use super::*;\n\n    pub fn initialize_pool(ctx: Context<InitializePool>, pool_seed: u64) -> Result<()> {\n        let pool = &mut ctx.accounts.pool;\n        pool.authority = ctx.accounts.authority.key();\n        pool.token = ctx.accounts.token.key();\n        pool.seed = pool_seed;\n        pool.total_liquidity = 0;\n        Ok(())\n    }\n\n    pub fn deposit(ctx: Context<Deposit>, amount: u64) -> Result<()> {\n        let pool = &mut ctx.accounts.pool;\n        pool.total_liquidity += amount;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token.to_account_info(),\n                    to: ctx.accounts.pool_token.to_account_info(),\n                    authority: ctx.accounts.user.to_account_info(),\n                },\n            ),\n            amount,\n        )?;\n\n        Ok(())\n    }\n\n    pub fn flash_loan(ctx: Context<FlashLoan>, amount: u64) -> Result<()> {\n        let pool = &ctx.accounts.pool;\n        require!(amount <= pool.total_liquidity, FlashLoanError::InsufficientLiquidity);\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.pool_token.to_account_info(),\n                    to: ctx.accounts.borrower_token.to_account_info(),\n                    authority: pool.to_account_info(),\n                },\n                &[&[b\"pool\", &pool.seed.to_le_bytes(), &[ctx.bumps.pool]]],\n            ),\n            amount,\n        )?;\n\n        // Callback to borrower's contract\n        ctx.accounts.callback_program.invoke(\n            &ctx.accounts.callback_account.to_account_info(),\n            &[ctx.accounts.borrower.to_account_info()],\n        )?;\n\n        // Repay loan\n        let fee = amount / 1000; // 0.1% fee\n        let repay_amount = amount + fee;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.borrower_token.to_account_info(),\n                    to: ctx.accounts.pool_token.to_account_info(),\n                    authority: ctx.accounts.borrower.to_account_info(),\n                },\n            ),\n            repay_amount,\n        )?;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct InitializePool<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 32 + 8 + 8, seeds = [b\"pool\", &pool_seed.to_le_bytes()], bump)]\n    pub pool: Account<'info, FlashLoanPool>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub token: Account<'info, TokenAccount>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Deposit<'info> {\n    #[account(mut)]\n    pub pool: Account<'info, FlashLoanPool>,\n    #[account(mut)]\n    pub user_token: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct FlashLoan<'info> {\n    #[account(mut)]\n    pub pool: Account<'info, FlashLoanPool>,\n    #[account(mut)]\n    pub borrower_token: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token: Account<'info, TokenAccount>,\n    pub borrower: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n    pub callback_program: AccountInfo<'info>,\n    pub callback_account: AccountInfo<'info>,\n}\n\n#[account]\npub struct FlashLoanPool {\n    pub authority: Pubkey,\n    pub token: Pubkey,\n    pub seed: u64,\n    pub total_liquidity: u64,\n}\n\n#[error_code]\npub enum FlashLoanError {\n    #[msg(\"Insufficient liquidity in the pool\")]\n    InsufficientLiquidity,\n}",
        "vulnerabilities": [
            "Smart contract vulnerability: The flash_loan function is susceptible to reentrancy attacks due to external calls before repayment",
            "Governance risk: Centralization risk due to single authority for the pool, potentially compromising decentralization",
            "Security flaw: Unchecked external call in the callback to the borrower's contract, potentially leading to unexpected behavior"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\nmod vulnerable_nft_marketplace {\n    use super::*;\n\n    pub fn list_nft(ctx: Context<ListNFT>, price: u64) -> Result<()> {\n        let listing = &mut ctx.accounts.listing;\n        listing.seller = ctx.accounts.seller.key();\n        listing.nft_mint = ctx.accounts.nft_mint.key();\n        listing.price = price;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.seller_nft_account.to_account_info(),\n                    to: ctx.accounts.escrow_nft_account.to_account_info(),\n                    authority: ctx.accounts.seller.to_account_info(),\n                },\n            ),\n            1,\n        )?;\n\n        Ok(())\n    }\n\n    pub fn buy_nft(ctx: Context<BuyNFT>) -> Result<()> {\n        let listing = &ctx.accounts.listing;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.buyer_token_account.to_account_info(),\n                    to: ctx.accounts.seller_token_account.to_account_info(),\n                    authority: ctx.accounts.buyer.to_account_info(),\n                },\n            ),\n            listing.price,\n        )?;\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.escrow_nft_account.to_account_info(),\n                    to: ctx.accounts.buyer_nft_account.to_account_info(),\n                    authority: listing.to_account_info(),\n                },\n                &[&[b\"listing\", listing.nft_mint.as_ref(), &[ctx.bumps.listing]]],\n            ),\n            1,\n        )?;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct ListNFT<'info> {\n    #[account(init, payer = seller, space = 8 + 32 + 32 + 8, seeds = [b\"listing\", nft_mint.key().as_ref()], bump)]\n    pub listing: Account<'info, NFTListing>,\n    #[account(mut)]\n    pub seller: Signer<'info>,\n    pub nft_mint: Account<'info, Mint>,\n    #[account(mut)]\n    pub seller_nft_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub escrow_nft_account: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct BuyNFT<'info> {\n    #[account(mut, seeds = [b\"listing\", listing.nft_mint.as_ref()], bump)]\n    pub listing: Account<'info, NFTListing>,\n    #[account(mut)]\n    pub buyer: Signer<'info>,\n    #[account(mut)]\n    pub seller_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub buyer_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub buyer_nft_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub escrow_nft_account: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct NFTListing {\n    pub seller: Pubkey,\n    pub nft_mint: Pubkey,\n    pub price: u64,\n}\n",
        "vulnerabilities": [
            "Transaction ordering exploit: The buy_nft function is vulnerable to front-running attacks, potentially allowing unfair advantages",
            "Insufficient authorization: Lack of access control with missing checks for the seller in the buy_nft function, risking unauthorized sales",
            "Reduced transparency: Missing event emission for tracking important state changes, hindering transaction monitoring"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\npub mod vulnerable_token_mint {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, mint_bump: u8) -> Result<()> {\n        let mint = &mut ctx.accounts.mint;\n        mint.authority = ctx.accounts.authority.key();\n        mint.bump = mint_bump;\n        Ok(())\n    }\n\n    pub fn mint_tokens(ctx: Context<MintTokens>, amount: u64) -> Result<()> {\n        let mint = &ctx.accounts.mint;\n\n        token::mint_to(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                token::MintTo {\n                    mint: ctx.accounts.mint_account.to_account_info(),\n                    to: ctx.accounts.receiver.to_account_info(),\n                    authority: ctx.accounts.mint.to_account_info(),\n                },\n                &[&[&mint.authority.to_bytes(), &[mint.bump]]],\n            ),\n            amount,\n        )?;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 1)]\n    pub mint: Account<'info, MintAccount>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct MintTokens<'info> {\n    #[account(mut)]\n    pub mint: Account<'info, MintAccount>,\n    #[account(mut)]\n    pub mint_account: Account<'info, token::Mint>,\n    #[account(mut)]\n    pub receiver: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct MintAccount {\n    pub authority: Pubkey,\n    pub bump: u8,\n}",
        "vulnerabilities": [
            "Inflationary risk: No cap on token minting amount, potentially leading to token value dilution",
            "Unauthorized token creation: Minting can be abused by unauthorized accounts, risking uncontrolled token supply increase",
            "Recipient verification flaw: No verification on receiver's token account, potentially leading to lost or inaccessible tokens"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\n\n#[program]\npub mod lottery {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, participants: Vec<Pubkey>) -> Result<()> {\n        let lottery = &mut ctx.accounts.lottery;\n        lottery.participants = participants;\n        lottery.winner = Pubkey::default();\n        Ok(())\n    }\n\n    pub fn draw_winner(ctx: Context<DrawWinner>) -> Result<()> {\n        let lottery = &mut ctx.accounts.lottery;\n        let random_index = (lottery.participants.len() as u64 * Clock::get()?.unix_timestamp) % lottery.participants.len() as u64;\n        lottery.winner = lottery.participants[random_index as usize];\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 4 + 32 * 100)]\n    pub lottery: Account<'info, Lottery>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct DrawWinner<'info> {\n    #[account(mut)]\n    pub lottery: Account<'info, Lottery>,\n    pub drawer: Signer<'info>,\n}\n\n#[account]\npub struct Lottery {\n    pub participants: Vec<Pubkey>,\n    pub winner: Pubkey,\n}\n\n#[error_code]\npub enum LotteryError {\n    #[msg(\"No participants in lottery\")]\n    NoParticipants,\n}",
        "vulnerabilities": [
            "Deterministic outcome: Predictable winner due to lack of randomness, allowing manipulation of the selection process",
            "Security assumption flaw: Assumes honest participants, potentially vulnerable to malicious actor exploitation"
        ]
    },    
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\npub mod vulnerable_staking_pool {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, reward_rate: u64) -> Result<()> {\n        let staking_pool = &mut ctx.accounts.staking_pool;\n        staking_pool.authority = ctx.accounts.authority.key();\n        staking_pool.reward_rate = reward_rate;\n        staking_pool.total_staked = 0;\n        Ok(())\n    }\n\n    pub fn stake(ctx: Context<Stake>, amount: u64) -> Result<()> {\n        let staking_pool = &mut ctx.accounts.staking_pool;\n        let user = &ctx.accounts.user;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_account.to_account_info(),\n                    to: ctx.accounts.pool_token_account.to_account_info(),\n                    authority: user.to_account_info(),\n                },\n            ),\n            amount,\n        )?;\n\n        staking_pool.total_staked += amount;\n\n        Ok(())\n    }\n\n    pub fn unstake(ctx: Context<Unstake>, amount: u64) -> Result<()> {\n        let staking_pool = &mut ctx.accounts.staking_pool;\n        let user = &ctx.accounts.user;\n\n        require!(staking_pool.total_staked >= amount, ErrorCode::InsufficientStakedAmount);\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.pool_token_account.to_account_info(),\n                    to: ctx.accounts.user_token_account.to_account_info(),\n                    authority: staking_pool.to_account_info(),\n                },\n                &[&[&staking_pool.authority.to_bytes(), &[*ctx.bumps.get(\"staking_pool\").unwrap()]]],\n            ),\n            amount,\n        )?;\n\n        staking_pool.total_staked -= amount;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 8)]\n    pub staking_pool: Account<'info, StakingPool>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Stake<'info> {\n    #[account(mut)]\n    pub staking_pool: Account<'info, StakingPool>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct Unstake<'info> {\n    #[account(mut)]\n    pub staking_pool: Account<'info, StakingPool>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct StakingPool {\n    pub authority: Pubkey,\n    pub reward_rate: u64,\n    pub total_staked: u64,\n}\n\n#[error_code]\npub enum ErrorCode {\n    #[msg(\"Insufficient staked amount\")]\n    InsufficientStakedAmount,\n}",
        "vulnerabilities": [
            "Limited incentive structure: No rewards mechanism implemented, potentially reducing participation motivation",
            "Lack of disincentives: No penalties for early unstake, possibly leading to network instability",
            "Governance risk: Centralized reward rate setting, potentially compromising decentralization principles"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\n\n#[program]\npub mod voting {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, options: Vec<String>) -> Result<()> {\n        let voting = &mut ctx.accounts.voting;\n        voting.options = options;\n        voting.votes = vec![0; options.len()];\n        Ok(())\n    }\n\n    pub fn vote(ctx: Context<Vote>, option_index: usize) -> Result<()> {\n        let voting = &mut ctx.accounts.voting;\n        voting.votes[option_index] += 1;\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 4 + 256)]\n    pub voting: Account<'info, Voting>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Vote<'info> {\n    #[account(mut)]\n    pub voting: Account<'info, Voting>,\n    pub voter: Signer<'info>,\n}\n\n#[account]\npub struct Voting {\n    pub options: Vec<String>,\n    pub votes: Vec<u32>,\n}\n\n#[error_code]\npub enum VotingError {\n    #[msg(\"Invalid option index\")]\n    InvalidOptionIndex,\n}",
        "vulnerabilities": [
            "Vote integrity issue: Multiple voting by the same user possible, potentially skewing voting results",
            "Inadequate time management: No voting deadline set, possibly leading to indefinite or manipulated voting periods"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n#[program]\npub mod vulnerable_vault {\n    use super::*;\n    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {\n        let vault = &mut ctx.accounts.vault;\n        vault.authority = ctx.accounts.authority.key();\n        vault.total_deposits = 0;\n        Ok(())\n    }\n    pub fn deposit(ctx: Context<Deposit>, amount: u64) -> Result<()> {\n        let vault = &mut ctx.accounts.vault;\n        let user = &ctx.accounts.user;\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_account.to_account_info(),\n                    to: ctx.accounts.vault_token_account.to_account_info(),\n                    authority: user.to_account_info(),\n                },\n            ),\n            amount,\n        )?;\n        vault.total_deposits += amount;\n        vault.user_deposits.insert(user.key(), amount);\n        Ok(())\n    }\n    pub fn withdraw(ctx: Context<Withdraw>, amount: u64) -> Result<()> {\n        let vault = &mut ctx.accounts.vault;\n        let user = &ctx.accounts.user;\n        let user_deposit = vault.user_deposits.get(&user.key()).unwrap();\n        require!(*user_deposit >= amount, ErrorCode::InsufficientFunds);\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.vault_token_account.to_account_info(),\n                    to: ctx.accounts.user_token_account.to_account_info(),\n                    authority: vault.to_account_info(),\n                },\n                &[&[&vault.authority.to_bytes(), &[*ctx.bumps.get(\"vault\").unwrap()]]],\n            ),\n            amount,\n        )?;\n        vault.total_deposits -= amount;\n        vault.user_deposits.insert(user.key(), user_deposit - amount);\n        Ok(())\n    }\n}\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 8 + 64)]\n    pub vault: Account<'info, Vault>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n#[derive(Accounts)]\npub struct Deposit<'info> {\n    #[account(mut)]\n    pub vault: Account<'info, Vault>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub vault_token_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n#[derive(Accounts)]\npub struct Withdraw<'info> {\n    #[account(mut)]\n    pub vault: Account<'info, Vault>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub vault_token_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n#[account]\npub struct Vault {\n    pub authority: Pubkey,\n    pub total_deposits: u64,\n    pub user_deposits: std::collections::HashMap<Pubkey, u64>,\n}",
        "vulnerabilities": [
            "Unrestricted fund access: Lack of access control for withdraw function, allowing unauthorized withdrawals",
            "Arithmetic vulnerability: Potential integer underflow in withdraw function, possibly leading to unexpected behavior",
            "Inadequate fund management: Missing checks for deposit and withdraw limits, risking contract insolvency"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n#[program]\npub mod vulnerable_auction {\n    use super::*;\n    pub fn initialize(ctx: Context<Initialize>, start_price: u64, end_time: i64) -> Result<()> {\n        let auction = &mut ctx.accounts.auction;\n        auction.authority = ctx.accounts.authority.key();\n        auction.current_price = start_price;\n        auction.end_time = end_time;\n        auction.highest_bidder = None;\n        Ok(())\n    }\n    pub fn place_bid(ctx: Context<PlaceBid>, bid_amount: u64) -> Result<()> {\n        let auction = &mut ctx.accounts.auction;\n        let bidder = &ctx.accounts.bidder;\n        let clock = Clock::get()?;\n        require!(clock.unix_timestamp < auction.end_time, ErrorCode::AuctionEnded);\n        require!(bid_amount > auction.current_price, ErrorCode::BidTooLow);\n        if let Some(prev_bidder) = auction.highest_bidder {\n            token::transfer(\n                CpiContext::new_with_signer(\n                    ctx.accounts.token_program.to_account_info(),\n                    Transfer {\n                        from: ctx.accounts.auction_token_account.to_account_info(),\n                        to: ctx.accounts.prev_bidder_token_account.to_account_info(),\n                        authority: auction.to_account_info(),\n                    },\n                    &[&[&auction.authority.to_bytes(), &[*ctx.bumps.get(\"auction\").unwrap()]]],\n                ),\n                auction.current_price,\n            )?;\n        }\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.bidder_token_account.to_account_info(),\n                    to: ctx.accounts.auction_token_account.to_account_info(),\n                    authority: bidder.to_account_info(),\n                },\n            ),\n            bid_amount,\n        )?;\n        auction.current_price = bid_amount;\n        auction.highest_bidder = Some(bidder.key());\n        Ok(())\n    }\n    pub fn end_auction(ctx: Context<EndAuction>) -> Result<()> {\n        let auction = &mut ctx.accounts.auction;\n        let clock = Clock::get()?;\n        require!(clock.unix_timestamp >= auction.end_time, ErrorCode::AuctionNotEnded);\n        if let Some(winner) = auction.highest_bidder {\n            token::transfer(\n                CpiContext::new_with_signer(\n                    ctx.accounts.token_program.to_account_info(),\n                    Transfer {\n                        from: ctx.accounts.auction_token_account.to_account_info(),\n                        to: ctx.accounts.authority_token_account.to_account_info(),\n                        authority: auction.to_account_info(),\n                    },\n                    &[&[&auction.authority.to_bytes(), &[*ctx.bumps.get(\"auction\").unwrap()]]],\n                ),\n                auction.current_price,\n            )?;\n        }\n        Ok(())\n    }\n}\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 8 + 8 + 32)]\n    pub auction: Account<'info, Auction>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n#[derive(Accounts)]\npub struct PlaceBid<'info> {\n    #[account(mut)]\n    pub auction: Account<'info, Auction>,\n    #[account(mut)]\n    pub bidder_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub auction_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub prev_bidder_token_account: Account<'info, TokenAccount>,\n    pub bidder: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n#[derive(Accounts)]\npub struct EndAuction<'info> {\n    #[account(mut)]\n    pub auction: Account<'info, Auction>,\n    #[account(mut)]\n    pub auction_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub authority_token_account: Account<'info, TokenAccount>,\n    pub authority: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n#[account]\npub struct Auction {\n    pub authority: Pubkey,\n    pub current_price: u64,\n    pub end_time: i64,\n    pub highest_bidder: Option<Pubkey>,\n}",
        "vulnerabilities": [
            "Unauthorized auction termination: Lack of access control for end_auction function, allowing premature or malicious auction endings",
            "Bidding integrity issue: Missing check for minimum bid increment, potentially allowing insignificant bid increases",
            "Transaction ordering exploit: Vulnerability to front-running in place_bid function, potentially allowing unfair bidding advantages"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n#[program]\npub mod vulnerable_multisig {\n    use super::*;\n    pub fn initialize(ctx: Context<Initialize>, threshold: u8, owners: Vec<Pubkey>) -> Result<()> {\n        let multisig = &mut ctx.accounts.multisig;\n        multisig.threshold = threshold;\n        multisig.owners = owners;\n        multisig.transaction_count = 0;\n        Ok(())\n    }\n    pub fn create_transaction(ctx: Context<CreateTransaction>, to: Pubkey, amount: u64) -> Result<()> {\n        let multisig = &mut ctx.accounts.multisig;\n        let transaction = &mut ctx.accounts.transaction;\n        transaction.to = to;\n        transaction.amount = amount;\n        transaction.signers = vec![];\n        transaction.executed = false;\n        transaction.id = multisig.transaction_count;\n        multisig.transaction_count += 1;\n        Ok(())\n    }\n    pub fn approve_transaction(ctx: Context<ApproveTransaction>) -> Result<()> {\n        let multisig = &ctx.accounts.multisig;\n        let transaction = &mut ctx.accounts.transaction;\n        let signer = &ctx.accounts.signer;\n        require!(!transaction.executed, ErrorCode::AlreadyExecuted);\n        require!(multisig.owners.contains(&signer.key()), ErrorCode::NotAnOwner);\n        require!(!transaction.signers.contains(&signer.key()), ErrorCode::AlreadySigned);\n        transaction.signers.push(signer.key());\n        Ok(())\n    }\n    pub fn execute_transaction(ctx: Context<ExecuteTransaction>) -> Result<()> {\n        let multisig = &ctx.accounts.multisig;\n        let transaction = &mut ctx.accounts.transaction;\n        require!(!transaction.executed, ErrorCode::AlreadyExecuted);\n        require!(transaction.signers.len() >= multisig.threshold as usize, ErrorCode::NotEnoughApprovals);\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.from.to_account_info(),\n                    to: ctx.accounts.to.to_account_info(),\n                    authority: multisig.to_account_info(),\n                },\n                &[&[&multisig.to_account_info().key.as_ref(), &[*ctx.bumps.get(\"multisig\").unwrap()]]],\n            ),\n            transaction.amount,\n        )?;\n        transaction.executed = true;\n        Ok(())\n    }\n}\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = payer, space = 8 + 1 + 32 * 10 + 8)]\n    pub multisig: Account<'info, Multisig>,\n    #[account(mut)]\n    pub payer: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n#[derive(Accounts)]\npub struct CreateTransaction<'info> {\n    #[account(mut)]\n    pub multisig: Account<'info, Multisig>,\n    #[account(init, payer = proposer, space = 8 + 32 + 8 + 32 * 10 + 1 + 8)]\n    pub transaction: Account<'info, Transaction>,\n    #[account(mut)]\n    pub proposer: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n#[derive(Accounts)]\npub struct ApproveTransaction<'info> {\n    pub multisig: Account<'info, Multisig>,\n    #[account(mut)]\n    pub transaction: Account<'info, Transaction>,\n    pub signer: Signer<'info>,\n}\n#[derive(Accounts)]\npub struct ExecuteTransaction<'info> {\n    pub multisig: Account<'info, Multisig>,\n    #[account(mut)]\n    pub transaction: Account<'info, Transaction>,\n    #[account(mut)]\n    pub from: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub to: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n#[account]\npub struct Multisig {\n    pub threshold: u8,\n    pub owners: Vec<Pubkey>,\n    pub transaction_count: u64,\n}\n#[account]\npub struct Transaction {\n    pub to: Pubkey,\n    pub amount: u64,\n    pub signers: Vec<Pubkey>,\n    pub executed: bool,\n    pub id: u64,\n}",
        "vulnerabilities": [
            "Unauthorized transaction creation: Missing access control for create_transaction function, allowing anyone to initiate transactions",
            "Immediate execution risk: Lack of time-lock mechanism for transaction execution, potentially allowing rushed or malicious actions",
            "Transaction ordering exploit: Vulnerability to transaction ordering attacks, potentially manipulating execution sequence"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\npub mod vulnerable_exchange {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, fee_rate: u64) -> Result<()> {\n        let exchange = &mut ctx.accounts.exchange;\n        exchange.authority = ctx.accounts.authority.key();\n        exchange.fee_rate = fee_rate;\n        exchange.total_liquidity = 0;\n        Ok(())\n    }\n\n    pub fn add_liquidity(ctx: Context<AddLiquidity>, amount: u64) -> Result<()> {\n        let exchange = &mut ctx.accounts.exchange;\n        let user = &ctx.accounts.user;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_account.to_account_info(),\n                    to: ctx.accounts.pool_token_account.to_account_info(),\n                    authority: user.to_account_info(),\n                },\n            ),\n            amount,\n        )?;\n\n        exchange.total_liquidity += amount;\n        exchange.user_liquidity.insert(user.key(), amount);\n\n        Ok(())\n    }\n\n    pub fn swap(ctx: Context<Swap>, amount_in: u64) -> Result<()> {\n        let exchange = &mut ctx.accounts.exchange;\n        let user = &ctx.accounts.user;\n\n        let fee = amount_in * exchange.fee_rate / 10000;\n        let amount_out = amount_in - fee;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_account_a.to_account_info(),\n                    to: ctx.accounts.pool_token_account_a.to_account_info(),\n                    authority: user.to_account_info(),\n                },\n            ),\n            amount_in,\n        )?;\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.pool_token_account_b.to_account_info(),\n                    to: ctx.accounts.user_token_account_b.to_account_info(),\n                    authority: exchange.to_account_info(),\n                },\n                &[&[&exchange.authority.to_bytes(), &[*ctx.bumps.get(\"exchange\").unwrap()]]],\n            ),\n            amount_out,\n        )?;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 8 + 8 + 64)]\n    pub exchange: Account<'info, Exchange>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct AddLiquidity<'info> {\n    #[account(mut)]\n    pub exchange: Account<'info, Exchange>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct Swap<'info> {\n    #[account(mut)]\n    pub exchange: Account<'info, Exchange>,\n    #[account(mut)]\n    pub user_token_account_a: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub user_token_account_b: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_account_a: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_account_b: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct Exchange {\n    pub authority: Pubkey,\n    pub fee_rate: u64,\n    pub total_liquidity: u64,\n    pub user_liquidity: std::collections::HashMap<Pubkey, u64>,\n}",
        "vulnerabilities": [
            "Economic vulnerability: Lack of slippage protection in swap function, potentially leading to unfavorable trade executions",
            "Liquidity risk: No checks for minimum liquidity in add_liquidity function, possibly resulting in imbalanced pools",
            "Arithmetic vulnerability: Potential integer overflow in fee calculation, possibly leading to incorrect fee amounts"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\npub mod vulnerable_staking {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, reward_rate: u64) -> Result<()> {\n        let staking_pool = &mut ctx.accounts.staking_pool;\n        staking_pool.authority = ctx.accounts.authority.key();\n        staking_pool.reward_rate = reward_rate;\n        staking_pool.total_staked = 0;\n        staking_pool.last_update_time = Clock::get()?.unix_timestamp;\n        Ok(())\n    }\n\n    pub fn stake(ctx: Context<Stake>, amount: u64) -> Result<()> {\n        let staking_pool = &mut ctx.accounts.staking_pool;\n        let user = &ctx.accounts.user;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_account.to_account_info(),\n                    to: ctx.accounts.pool_token_account.to_account_info(),\n                    authority: user.to_account_info(),\n                },\n            ),\n            amount,\n        )?;\n\n        staking_pool.total_staked += amount;\n        let user_stake = staking_pool.user_stakes.entry(user.key()).or_insert(0);\n        *user_stake += amount;\n\n        Ok(())\n    }\n\n    pub fn unstake(ctx: Context<Unstake>, amount: u64) -> Result<()> {\n        let staking_pool = &mut ctx.accounts.staking_pool;\n        let user = &ctx.accounts.user;\n\n        let user_stake = staking_pool.user_stakes.get_mut(&user.key()).unwrap();\n        require!(*user_stake >= amount, ErrorCode::InsufficientStake);\n\n        *user_stake -= amount;\n        staking_pool.total_staked -= amount;\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.pool_token_account.to_account_info(),\n                    to: ctx.accounts.user_token_account.to_account_info(),\n                    authority: staking_pool.to_account_info(),\n                },\n                &[&[&staking_pool.authority.to_bytes(), &[*ctx.bumps.get(\"staking_pool\").unwrap()]]],\n            ),\n            amount,\n        )?;\n\n        Ok(())\n    }\n\n    pub fn claim_rewards(ctx: Context<ClaimRewards>) -> Result<()> {\n        let staking_pool = &mut ctx.accounts.staking_pool;\n        let user = &ctx.accounts.user;\n\n        let current_time = Clock::get()?.unix_timestamp;\n        let time_elapsed = (current_time - staking_pool.last_update_time) as u64;\n\n        let user_stake = staking_pool.user_stakes.get(&user.key()).unwrap();\n        let rewards = (*user_stake * staking_pool.reward_rate * time_elapsed) / 1_000_000;\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.reward_token_account.to_account_info(),\n                    to: ctx.accounts.user_reward_account.to_account_info(),\n                    authority: staking_pool.to_account_info(),\n                },\n                &[&[&staking_pool.authority.to_bytes(), &[*ctx.bumps.get(\"staking_pool\").unwrap()]]],\n            ),\n            rewards,\n        )?;\n\n        staking_pool.last_update_time = current_time;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 8 + 8 + 8 + 64)]\n    pub staking_pool: Account<'info, StakingPool>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Stake<'info> {\n    #[account(mut)]\n    pub staking_pool: Account<'info, StakingPool>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct Unstake<'info> {\n    #[account(mut)]\n    pub staking_pool: Account<'info, StakingPool>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct ClaimRewards<'info> {\n    #[account(mut)]\n    pub staking_pool: Account<'info, StakingPool>,\n    #[account(mut)]\n    pub user_reward_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub reward_token_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct StakingPool {\n    pub authority: Pubkey,\n    pub reward_rate: u64,\n    pub total_staked: u64,\n    pub last_update_time: i64,\n    pub user_stakes: std::collections::HashMap<Pubkey, u64>,\n}",
        "vulnerabilities": [
            "Reward distribution risk: Lack of reward pool balance checks in claim_rewards function, potentially leading to failed reward payments",
            "Arithmetic vulnerability: Potential for reward calculation overflow in claim_rewards function, possibly resulting in incorrect rewards",
            "Staking timestamp flaw: Missing update of last_update_time in stake and unstake functions, potentially affecting reward calculations"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\npub mod vulnerable_nft_marketplace {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, fee_rate: u64) -> Result<()> {\n        let marketplace = &mut ctx.accounts.marketplace;\n        marketplace.authority = ctx.accounts.authority.key();\n        marketplace.fee_rate = fee_rate;\n        marketplace.total_volume = 0;\n        Ok(())\n    }\n\n    pub fn list_nft(ctx: Context<ListNFT>, price: u64) -> Result<()> {\n        let listing = &mut ctx.accounts.listing;\n        listing.seller = ctx.accounts.seller.key();\n        listing.nft_mint = ctx.accounts.nft_mint.key();\n        listing.price = price;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.seller_nft_account.to_account_info(),\n                    to: ctx.accounts.vault_nft_account.to_account_info(),\n                    authority: ctx.accounts.seller.to_account_info(),\n                },\n            ),\n            1,\n        )?;\n\n        Ok(())\n    }\n\n    pub fn buy_nft(ctx: Context<BuyNFT>) -> Result<()> {\n        let marketplace = &mut ctx.accounts.marketplace;\n        let listing = &ctx.accounts.listing;\n\n        let fee = listing.price * marketplace.fee_rate / 10000;\n        let seller_amount = listing.price - fee;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.buyer_token_account.to_account_info(),\n                    to: ctx.accounts.seller_token_account.to_account_info(),\n                    authority: ctx.accounts.buyer.to_account_info(),\n                },\n            ),\n            seller_amount,\n        )?;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.buyer_token_account.to_account_info(),\n                    to: ctx.accounts.fee_account.to_account_info(),\n                    authority: ctx.accounts.buyer.to_account_info(),\n                },\n            ),\n            fee,\n        )?;\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.vault_nft_account.to_account_info(),\n                    to: ctx.accounts.buyer_nft_account.to_account_info(),\n                    authority: marketplace.to_account_info(),\n                },\n                &[&[&marketplace.authority.to_bytes(), &[*ctx.bumps.get(\"marketplace\").unwrap()]]],\n            ),\n            1,\n        )?;\n\n        marketplace.total_volume += listing.price;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 8 + 8)]\n    pub marketplace: Account<'info, Marketplace>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct ListNFT<'info> {\n    #[account(init, payer = seller, space = 8 + 32 + 32 + 8)]\n    pub listing: Account<'info, Listing>,\n    #[account(mut)]\n    pub seller: Signer<'info>,\n    pub nft_mint: Account<'info, Mint>,\n    #[account(mut)]\n    pub seller_nft_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub vault_nft_account: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct BuyNFT<'info> {\n    #[account(mut)]\n    pub marketplace: Account<'info, Marketplace>,\n    #[account(mut)]\n    pub listing: Account<'info, Listing>,\n    #[account(mut)]\n    pub buyer: Signer<'info>,\n    #[account(mut)]\n    pub seller_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub buyer_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub fee_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub vault_nft_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub buyer_nft_account: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct Marketplace {\n    pub authority: Pubkey,\n    pub fee_rate: u64,\n    pub total_volume: u64,\n}\n\n#[account]\npub struct Listing {\n    pub seller: Pubkey,\n    pub nft_mint: Pubkey,\n    pub price: u64,\n}",
        "vulnerabilities": [
            "Asset verification flaw: Lack of check for NFT ownership in list_nft function, potentially allowing listing of unowned NFTs",
            "Limited user control: Missing cancellation functionality for listings, preventing sellers from retracting their offers",
            "Parameter validation issue: No validation of fee_rate in initialize function, potentially allowing unreasonable fee settings"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\npub mod vulnerable_dao {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, name: String, quorum: u64) -> Result<()> {\n        let dao = &mut ctx.accounts.dao;\n        dao.authority = ctx.accounts.authority.key();\n        dao.name = name;\n        dao.quorum = quorum;\n        dao.proposal_count = 0;\n        Ok(())\n    }\n\n    pub fn create_proposal(ctx: Context<CreateProposal>, description: String) -> Result<()> {\n        let dao = &mut ctx.accounts.dao;\n        let proposal = &mut ctx.accounts.proposal;\n\n        proposal.id = dao.proposal_count;\n        proposal.description = description;\n        proposal.proposer = ctx.accounts.proposer.key();\n        proposal.yes_votes = 0;\n        proposal.no_votes = 0;\n        proposal.executed = false;\n\n        dao.proposal_count += 1;\n\n        Ok(())\n    }\n\n    pub fn vote(ctx: Context<Vote>, vote: bool) -> Result<()> {\n        let proposal = &mut ctx.accounts.proposal;\n        let voter = &ctx.accounts.voter;\n\n        let voter_weight = ctx.accounts.voter_token_account.amount;\n\n        if vote {\n            proposal.yes_votes += voter_weight;\n        } else {\n            proposal.no_votes += voter_weight;\n        }\n\n        Ok(())\n    }\n\n    pub fn execute_proposal(ctx: Context<ExecuteProposal>) -> Result<()> {\n        let dao = &ctx.accounts.dao;\n        let proposal = &mut ctx.accounts.proposal;\n\n        require!(!proposal.executed, ErrorCode::ProposalAlreadyExecuted);\n        require!(proposal.yes_votes > proposal.no_votes, ErrorCode::ProposalNotPassed);\n        require!(proposal.yes_votes + proposal.no_votes >= dao.quorum, ErrorCode::QuorumNotReached);\n\n        proposal.executed = true;\n\n        // Execute proposal logic here\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 32 + 8 + 8)]\n    pub dao: Account<'info, DAO>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct CreateProposal<'info> {\n    #[account(mut)]\n    pub dao: Account<'info, DAO>,\n    #[account(init, payer = proposer, space = 8 + 8 + 32 + 32 + 8 + 8 + 1)]\n    pub proposal: Account<'info, Proposal>,\n    #[account(mut)]\n    pub proposer: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Vote<'info> {\n    #[account(mut)]\n    pub proposal: Account<'info, Proposal>,\n    pub voter: Signer<'info>,\n    pub voter_token_account: Account<'info, TokenAccount>,\n}\n\n#[derive(Accounts)]\npub struct ExecuteProposal<'info> {\n    pub dao: Account<'info, DAO>,\n    #[account(mut)]\n    pub proposal: Account<'info, Proposal>,\n    pub executor: Signer<'info>,\n}\n\n#[account]\npub struct DAO {\n    pub authority: Pubkey,\n    pub name: String,\n    pub quorum: u64,\n    pub proposal_count: u64,\n}\n\n#[account]\npub struct Proposal {\n    pub id: u64,\n    pub description: String,\n    pub proposer: Pubkey,\n    pub yes_votes: u64,\n    pub no_votes: u64,\n    pub executed: bool,\n}",
        "vulnerabilities": [
            "Vote integrity issue: No check for duplicate voting in vote function, potentially allowing multiple votes from a single user",
            "Inadequate time management: Lack of time-based constraints for proposal voting and execution, possibly leading to rushed or delayed governance actions",
            "Unrestricted proposal execution: Missing access control for execute_proposal function, allowing unauthorized execution of proposals"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\npub mod vulnerable_lottery {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, ticket_price: u64, max_tickets: u64) -> Result<()> {\n        let lottery = &mut ctx.accounts.lottery;\n        lottery.authority = ctx.accounts.authority.key();\n        lottery.ticket_price = ticket_price;\n        lottery.max_tickets = max_tickets;\n        lottery.total_tickets = 0;\n        lottery.is_active = true;\n        Ok(())\n    }\n\n    pub fn buy_ticket(ctx: Context<BuyTicket>) -> Result<()> {\n        let lottery = &mut ctx.accounts.lottery;\n        require!(lottery.is_active, ErrorCode::LotteryNotActive);\n        require!(lottery.total_tickets < lottery.max_tickets, ErrorCode::LotteryFull);\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.buyer_token_account.to_account_info(),\n                    to: ctx.accounts.lottery_token_account.to_account_info(),\n                    authority: ctx.accounts.buyer.to_account_info(),\n                },\n            ),\n            lottery.ticket_price,\n        )?;\n\n        lottery.total_tickets += 1;\n        lottery.participants.push(ctx.accounts.buyer.key());\n\n        Ok(())\n    }\n\n    pub fn draw_winner(ctx: Context<DrawWinner>) -> Result<()> {\n        let lottery = &mut ctx.accounts.lottery;\n        require!(lottery.is_active, ErrorCode::LotteryNotActive);\n        require!(lottery.total_tickets > 0, ErrorCode::NoParticipants);\n\n        let clock = Clock::get()?;\n        let random_seed = clock.unix_timestamp as u64;\n        let winner_index = random_seed % lottery.total_tickets;\n        let winner = lottery.participants[winner_index as usize];\n\n        let total_prize = lottery.ticket_price * lottery.total_tickets;\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.lottery_token_account.to_account_info(),\n                    to: ctx.accounts.winner_token_account.to_account_info(),\n                    authority: lottery.to_account_info(),\n                },\n                &[&[&lottery.authority.to_bytes(), &[*ctx.bumps.get(\"lottery\").unwrap()]]],\n            ),\n            total_prize,\n        )?;\n\n        lottery.is_active = false;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 8 + 8 + 8 + 1 + 32 * 64)]\n    pub lottery: Account<'info, Lottery>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct BuyTicket<'info> {\n    #[account(mut)]\n    pub lottery: Account<'info, Lottery>,\n    #[account(mut)]\n    pub buyer: Signer<'info>,\n    #[account(mut)]\n    pub buyer_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub lottery_token_account: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct DrawWinner<'info> {\n    #[account(mut)]\n    pub lottery: Account<'info, Lottery>,\n    #[account(mut)]\n    pub lottery_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub winner_token_account: Account<'info, TokenAccount>,\n    pub authority: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct Lottery {\n    pub authority: Pubkey,\n    pub ticket_price: u64,\n    pub max_tickets: u64,\n    pub total_tickets: u64,\n    pub is_active: bool,\n    pub participants: Vec<Pubkey>,\n}",
        "vulnerabilities": [
            "Insecure randomness generation in draw_winner function: The contract uses a predictable source of randomness, potentially allowing manipulation of the winner selection process",
            "Insufficient access control for draw_winner function: The function lacks proper authorization checks, allowing unauthorized users to trigger the winner selection"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\npub mod vulnerable_auction {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, reserve_price: u64, duration: i64) -> Result<()> {\n        let auction = &mut ctx.accounts.auction;\n        auction.authority = ctx.accounts.authority.key();\n        auction.reserve_price = reserve_price;\n        auction.end_time = Clock::get()?.unix_timestamp + duration;\n        auction.highest_bid = 0;\n        auction.highest_bidder = Pubkey::default();\n        Ok(())\n    }\n\n    pub fn place_bid(ctx: Context<PlaceBid>, amount: u64) -> Result<()> {\n        let auction = &mut ctx.accounts.auction;\n        let current_time = Clock::get()?.unix_timestamp;\n\n        require!(current_time < auction.end_time, ErrorCode::AuctionEnded);\n        require!(amount > auction.highest_bid, ErrorCode::BidTooLow);\n\n        if auction.highest_bid > 0 {\n            // Refund the previous highest bidder\n            token::transfer(\n                CpiContext::new_with_signer(\n                    ctx.accounts.token_program.to_account_info(),\n                    Transfer {\n                        from: ctx.accounts.auction_token_account.to_account_info(),\n                        to: ctx.accounts.previous_highest_bidder_account.to_account_info(),\n                        authority: auction.to_account_info(),\n                    },\n                    &[&[&auction.authority.to_bytes(), &[*ctx.bumps.get(\"auction\").unwrap()]]],\n                ),\n                auction.highest_bid,\n            )?;\n        }\n\n        // Update auction with new highest bid\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.bidder_token_account.to_account_info(),\n                    to: ctx.accounts.auction_token_account.to_account_info(),\n                    authority: ctx.accounts.bidder.to_account_info(),\n                },\n            ),\n            amount,\n        )?;\n\n        auction.highest_bid = amount;\n        auction.highest_bidder = ctx.accounts.bidder.key();\n\n        Ok(())\n    }\n\n    pub fn close_auction(ctx: Context<CloseAuction>) -> Result<()> {\n        let auction = &mut ctx.accounts.auction;\n        let current_time = Clock::get()?.unix_timestamp;\n\n        require!(current_time >= auction.end_time, ErrorCode::AuctionNotEnded);\n\n        if auction.highest_bid >= auction.reserve_price {\n            token::transfer(\n                CpiContext::new_with_signer(\n                    ctx.accounts.token_program.to_account_info(),\n                    Transfer {\n                        from: ctx.accounts.auction_token_account.to_account_info(),\n                        to: ctx.accounts.authority_token_account.to_account_info(),\n                        authority: auction.to_account_info(),\n                    },\n                    &[&[&auction.authority.to_bytes(), &[*ctx.bumps.get(\"auction\").unwrap()]]],\n                ),\n                auction.highest_bid,\n            )?;\n        }\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 8 + 8 + 32)]\n    pub auction: Account<'info, Auction>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct PlaceBid<'info> {\n    #[account(mut)]\n    pub auction: Account<'info, Auction>,\n    #[account(mut)]\n    pub bidder_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub auction_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub previous_highest_bidder_account: Account<'info, TokenAccount>,\n    pub bidder: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct CloseAuction<'info> {\n    #[account(mut)]\n    pub auction: Account<'info, Auction>,\n    #[account(mut)]\n    pub authority_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub auction_token_account: Account<'info, TokenAccount>,\n    pub authority: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct Auction {\n    pub authority: Pubkey,\n    pub reserve_price: u64,\n    pub end_time: i64,\n    pub highest_bid: u64,\n    pub highest_bidder: Pubkey,\n}\n\n#[error_code]\npub enum ErrorCode {\n    #[msg(\"Auction has ended\")]\n    AuctionEnded,\n    #[msg(\"Bid is too low\")]\n    BidTooLow,\n    #[msg(\"Auction has not ended\")]\n    AuctionNotEnded,\n}",
        "vulnerabilities": [
            "Failed refund transactions due to improper error handling can result in permanent loss of user funds, undermining contract reliability.",
            "Manipulable end time allows malicious actors to extend or prematurely terminate events, potentially exploiting or disrupting intended contract flow.",
            "Lack of transaction ordering protection enables frontrunning attacks, allowing unfair advantage in high-stakes or time-sensitive operations."
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\n\n#[program]\npub mod fundraiser {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, target_amount: u64) -> Result<()> {\n        let fundraiser = &mut ctx.accounts.fundraiser;\n        fundraiser.target_amount = target_amount;\n        fundraiser.collected_amount = 0;\n        Ok(())\n    }\n\n    pub fn donate(ctx: Context<Donate>, amount: u64) -> Result<()> {\n        let fundraiser = &mut ctx.accounts.fundraiser;\n        fundraiser.collected_amount += amount;\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 8 + 8)]\n    pub fundraiser: Account<'info, Fundraiser>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Donate<'info> {\n    #[account(mut)]\n    pub fundraiser: Account<'info, Fundraiser>,\n    pub donor: Signer<'info>,\n}\n\n#[account]\npub struct Fundraiser {\n    pub target_amount: u64,\n    pub collected_amount: u64,\n}\n\n#[error_code]\npub enum FundraiserError {\n    #[msg(\"Fundraiser target reached\")]\n    TargetReached,\n}",
        "vulnerabilities": [
            "Absence of upper bounds on donation amounts risks contract insolvency or manipulation through excessive contributions.",
            "Lack of transparent fund usage tracking or verification mechanisms compromises accountability and trust in the donation process."
        ]
    },    
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\npub mod vulnerable_loyalty_program {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, reward_rate: u64) -> Result<()> {\n        let loyalty_program = &mut ctx.accounts.loyalty_program;\n        loyalty_program.authority = ctx.accounts.authority.key();\n        loyalty_program.reward_rate = reward_rate;\n        Ok(())\n    }\n\n    pub fn issue_rewards(ctx: Context<IssueRewards>, amount: u64) -> Result<()> {\n        let loyalty_program = &ctx.accounts.loyalty_program;\n\n        token::mint_to(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                token::MintTo {\n                    mint: ctx.accounts.mint_account.to_account_info(),\n                    to: ctx.accounts.user_token_account.to_account_info(),\n                    authority: ctx.accounts.loyalty_program.to_account_info(),\n                },\n                &[&[&loyalty_program.authority.to_bytes(), &[*ctx.bumps.get(\"loyalty_program\").unwrap()]]],\n            ),\n            amount * loyalty_program.reward_rate,\n        )?;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 8)]\n    pub loyalty_program: Account<'info, LoyaltyProgram>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct IssueRewards<'info> {\n    #[account(mut)]\n    pub loyalty_program: Account<'info, LoyaltyProgram>,\n    #[account(mut)]\n    pub mint_account: Account<'info, token::Mint>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct LoyaltyProgram {\n    pub authority: Pubkey,\n    pub reward_rate: u64,\n}",
        "vulnerabilities": [
            "Uncapped reward issuance exposes the system to potential economic exploitation and hyperinflation of reward tokens.",
            "Absence of robust user verification allows creation of multiple accounts, potentially leading to system gaming and unfair reward distribution.",
            "Lack of anti-bot measures enables automated exploitation of reward mechanisms, disadvantaging genuine users and depleting reward pools."
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\nmod vulnerable_dao {\n    use super::*;\n\n    pub fn create_proposal(ctx: Context<CreateProposal>, description: String, vote_end_time: i64) -> Result<()> {\n        let proposal = &mut ctx.accounts.proposal;\n        proposal.creator = ctx.accounts.creator.key();\n        proposal.description = description;\n        proposal.vote_end_time = vote_end_time;\n        proposal.yes_votes = 0;\n        proposal.no_votes = 0;\n        proposal.executed = false;\n        Ok(())\n    }\n\n    pub fn cast_vote(ctx: Context<CastVote>, vote: bool) -> Result<()> {\n        let proposal = &mut ctx.accounts.proposal;\n        let voter = &ctx.accounts.voter;\n\n        require!(Clock::get()?.unix_timestamp < proposal.vote_end_time, DAOError::VotingEnded);\n\n        let voting_power = ctx.accounts.voter_token_account.amount;\n\n        if vote {\n            proposal.yes_votes += voting_power;\n        } else {\n            proposal.no_votes += voting_power;\n        }\n\n        Ok(())\n    }\n\n    pub fn execute_proposal(ctx: Context<ExecuteProposal>) -> Result<()> {\n        let proposal = &mut ctx.accounts.proposal;\n\n        require!(Clock::get()?.unix_timestamp >= proposal.vote_end_time, DAOError::VotingNotEnded);\n        require!(!proposal.executed, DAOError::ProposalAlreadyExecuted);\n\n        if proposal.yes_votes > proposal.no_votes {\n            proposal.executed = true;\n            // Execute the proposal action\n            ctx.accounts.target_program.invoke(\n                &ctx.accounts.target_account.to_account_info(),\n                &[ctx.accounts.dao.to_account_info()],\n            )?\n        }\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct CreateProposal<'info> {\n    #[account(init, payer = creator, space = 8 + 32 + 200 + 8 + 8 + 8 + 1, seeds = [b\"proposal\", creator.key().as_ref()], bump)]\n    pub proposal: Account<'info, Proposal>,\n    #[account(mut)]\n    pub creator: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct CastVote<'info> {\n    #[account(mut)]\n    pub proposal: Account<'info, Proposal>,\n    pub voter: Signer<'info>,\n    pub voter_token_account: Account<'info, TokenAccount>,\n}\n\n#[derive(Accounts)]\npub struct ExecuteProposal<'info> {\n    #[account(mut)]\n    pub proposal: Account<'info, Proposal>,\n    pub dao: Account<'info, DAO>,\n    pub target_program: AccountInfo<'info>,\n    pub target_account: AccountInfo<'info>,\n}\n\n#[account]\npub struct Proposal {\n    pub creator: Pubkey,\n    pub description: String,\n    pub vote_end_time: i64,\n    pub yes_votes: u64,\n    pub no_votes: u64,\n    pub executed: bool,\n}\n\n#[account]\npub struct DAO {\n    pub authority: Pubkey,\n}\n\n#[error_code]\npub enum DAOError {\n    #[msg(\"Voting period has ended\")]\n    VotingEnded,\n    #[msg(\"Voting period has not ended yet\")]\n    VotingNotEnded,\n    #[msg(\"Proposal has already been executed\")]\n    ProposalAlreadyExecuted,\n}\n",
        "vulnerabilities": [
          "Double voting: No protection against users voting multiple times",
          "Centralization risk: Single authority for the DAO",
          "Unchecked external call: The execute_proposal function makes an unchecked call to the target program"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\n\ndeclare_id!(\"Vote11111111111111111111111111111111111111\");\n\n#[program]\npub mod vulnerable_voting {\n    use super::*;\n\n    pub fn create_proposal(ctx: Context<CreateProposal>, description: String) -> Result<()> {\n        let proposal = &mut ctx.accounts.proposal;\n        proposal.description = description;\n        proposal.creator = ctx.accounts.creator.key();\n        proposal.yes_votes = 0;\n        proposal.no_votes = 0;\n        proposal.is_active = true;\n        Ok(())\n    }\n\n    pub fn cast_vote(ctx: Context<CastVote>, vote: bool) -> Result<()> {\n        let proposal = &mut ctx.accounts.proposal;\n        let voter = &ctx.accounts.voter;\n\n        // Vulnerability 1: No check if the proposal is still active\n\n        // Vulnerability 2: No prevention of double voting\n        if vote {\n            proposal.yes_votes += 1;\n        } else {\n            proposal.no_votes += 1;\n        }\n\n        Ok(())\n    }\n\n    pub fn end_proposal(ctx: Context<EndProposal>) -> Result<()> {\n        let proposal = &mut ctx.accounts.proposal;\n\n        // Vulnerability 3: No check if the caller is the proposal creator\n        proposal.is_active = false;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct CreateProposal<'info> {\n    #[account(init, payer = creator, space = 8 + 256 + 32 + 8 + 8 + 1)]\n    pub proposal: Account<'info, Proposal>,\n    #[account(mut)]\n    pub creator: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct CastVote<'info> {\n    #[account(mut)]\n    pub proposal: Account<'info, Proposal>,\n    pub voter: Signer<'info>,\n}\n\n#[derive(Accounts)]\npub struct EndProposal<'info> {\n    #[account(mut)]\n    pub proposal: Account<'info, Proposal>,\n    pub user: Signer<'info>,\n}\n\n#[account]\npub struct Proposal {\n    pub description: String,\n    pub creator: Pubkey,\n    pub yes_votes: u64,\n    pub no_votes: u64,\n    pub is_active: bool,\n}",
        "vulnerabilities": [
            "No check if proposal is still active: The cast_vote function doesn't verify if the proposal is still active, potentially allowing votes on closed proposals.",
            "No prevention of double voting: There's no mechanism to prevent a user from voting multiple times on the same proposal.",
            "No check for proposal creator in end"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\n\n#[program]\npub mod crowdfunding {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, target_amount: u64, deadline: i64) -> Result<()> {\n        let crowdfunding = &mut ctx.accounts.crowdfunding;\n        crowdfunding.target_amount = target_amount;\n        crowdfunding.deadline = deadline;\n        crowdfunding.collected_amount = 0;\n        Ok(())\n    }\n\n    pub fn contribute(ctx: Context<Contribute>, amount: u64) -> Result<()> {\n        let crowdfunding = &mut ctx.accounts.crowdfunding;\n        crowdfunding.collected_amount += amount;\n        Ok(())\n    }\n\n    pub fn withdraw(ctx: Context<Withdraw>) -> Result<()> {\n        let crowdfunding = &mut ctx.accounts.crowdfunding;\n\n        if crowdfunding.collected_amount >= crowdfunding.target_amount {\n            let withdraw_amount = crowdfunding.collected_amount;\n            crowdfunding.collected_amount = 0;\n            ctx.accounts.recipient.to_account_info().try_borrow_mut_lamports()?.checked_add(withdraw_amount);\n        }\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 8 + 8 + 8)]\n    pub crowdfunding: Account<'info, Crowdfunding>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Contribute<'info> {\n    #[account(mut)]\n    pub crowdfunding: Account<'info, Crowdfunding>,\n    pub contributor: Signer<'info>,\n}\n\n#[derive(Accounts)]\npub struct Withdraw<'info> {\n    #[account(mut)]\n    pub crowdfunding: Account<'info, Crowdfunding>,\n    #[account(mut)]\n    pub recipient: AccountInfo<'info>,\n}\n\n#[account]\npub struct Crowdfunding {\n    pub target_amount: u64,\n    pub collected_amount: u64,\n    pub deadline: i64,\n}\n\n#[error_code]\npub enum CrowdfundingError {\n    #[msg(\"Crowdfunding target not met\")]\n    TargetNotMet,\n}",
        "vulnerabilities": [
            "No refund mechanism for failed campaigns",
            "No restriction on early fund withdrawal"
        ]
    },    
    {
        "code": "use anchor_lang::prelude::*;\n\ndeclare_id!(\"Vuln66666666666666666666666666666666666666\");\n\n#[program]\npub mod vulnerable_escrow {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, amount: u64) -> Result<()> {\n        let escrow = &mut ctx.accounts.escrow;\n        escrow.initializer = ctx.accounts.initializer.key();\n        escrow.recipient = ctx.accounts.recipient.key();\n        escrow.amount = amount;\n        escrow.completed = false;\n        Ok(())\n    }\n\n    pub fn complete(ctx: Context<Complete>) -> Result<()> {\n        let escrow = &mut ctx.accounts.escrow;\n        require!(!escrow.completed, ErrorCode::AlreadyCompleted);\n        escrow.completed = true;\n        Ok(())\n    }\n\n    pub fn cancel(ctx: Context<Cancel>) -> Result<()> {\n        let escrow = &mut ctx.accounts.escrow;\n        require!(!escrow.completed, ErrorCode::AlreadyCompleted);\n        escrow.completed = true;\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = initializer, space = 8 + 32 + 32 + 8 + 1)]\n    pub escrow: Account<'info, Escrow>,\n    #[account(mut)]\n    pub initializer: Signer<'info>,\n    /// CHECK: This is not dangerous because we don't read or write from this account\n    pub recipient: AccountInfo<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Complete<'info> {\n    #[account(mut)]\n    pub escrow: Account<'info, Escrow>,\n    pub recipient: Signer<'info>,\n}\n\n#[derive(Accounts)]\npub struct Cancel<'info> {\n    #[account(mut)]\n    pub escrow: Account<'info, Escrow>,\n    pub initializer: Signer<'info>,\n}\n\n#[account]\npub struct Escrow {\n    pub initializer: Pubkey,\n    pub recipient: Pubkey,\n    pub amount: u64,\n    pub completed: bool,\n}\n\n#[error_code]\npub enum ErrorCode {\n    #[msg(\"Escrow has already been completed\")]\n    AlreadyCompleted,\n}",
        "vulnerabilities": [
            "No actual token transfer in initialize or complete",
            "Missing time lock mechanism",
            "Lack of verification for recipient in complete function",
            "No event emission for important state changes"
        ]
    },
    {
      "code": "use solana_program::{\n    account_info::{next_account_info, AccountInfo},\n    entrypoint,\n    entrypoint::ProgramResult,\n    pubkey::Pubkey,\n    msg,\n};\n\nentrypoint!(process_instruction);\n\npub fn process_instruction(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    instruction_data: &[u8],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let user_account = next_account_info(account_info_iter)?;\n\n    if !user_account.is_signer {\n        return Err(ProgramError::MissingRequiredSignature);\n    }\n\n    let amount = u64::from_le_bytes(instruction_data.get(..8)\n        .and_then(|slice| slice.try_into().ok())\n        .ok_or(ProgramError::InvalidInstructionData)?)\n        .checked_add(1)\n        .ok_or(ProgramError::ArithmeticOverflow)?;\n\n    msg!(\"Processed amount: {}\", amount);\n\n    Ok(())\n}",
      "vulnerabilities": [
        "Integer Overflow"
      ]
    },
    {
        "code": "use anchor_lang::prelude::*;\n\ndeclare_id!(\"VulnBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\");\n\n#[program]\npub mod vulnerable_crowdfunding {\n    use super::*;\n\n    pub fn create_campaign(ctx: Context<CreateCampaign>, name: String, description: String, target: u64, end_time: i64) -> Result<()> {\n        let campaign = &mut ctx.accounts.campaign;\n        campaign.creator = ctx.accounts.creator.key();\n        campaign.name = name;\n        campaign.description = description;\n        campaign.target = target;\n        campaign.end_time = end_time;\n        campaign.amount_raised = 0;\n        Ok(())\n    }\n\n    pub fn donate(ctx: Context<Donate>, amount: u64) -> Result<()> {\n        let campaign = &mut ctx.accounts.campaign;\n        let clock = Clock::get()?;\n\n        require!(clock.unix_timestamp < campaign.end_time, ErrorCode::CampaignEnded);\n\n        campaign.amount_raised += amount;\n        // Transfer of funds would happen here\n        Ok(())\n    }\n\n    pub fn withdraw(ctx: Context<Withdraw>) -> Result<()> {\n        let campaign = &mut ctx.accounts.campaign;\n        let clock = Clock::get()?;\n\n        require!(clock.unix_timestamp >= campaign.end_time, ErrorCode::CampaignNotEnded);\n        require!(campaign.amount_raised >= campaign.target, ErrorCode::TargetNotReached);\n\n        // Transfer of funds to creator would happen here\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct CreateCampaign<'info> {\n    #[account(init, payer = creator, space = 8 + 32 + 100 + 1000 + 8 + 8 + 8)]\n    pub campaign: Account<'info, Campaign>,\n    #[account(mut)]\n    pub creator: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Donate<'info> {\n    #[account(mut)]\n    pub campaign: Account<'info, Campaign>,\n    #[account(mut)]\n    pub donor: Signer<'info>,\n}\n\n#[derive(Accounts)]\npub struct Withdraw<'info> {\n    #[account(mut)]\n    pub campaign: Account<'info, Campaign>,\n    pub creator: Signer<'info>,\n}\n\n#[account]\npub struct Campaign {\n    pub creator: Pubkey,\n    pub name: String,\n    pub description: String,\n    pub target: u64,\n    pub end_time: i64,\n    pub amount_raised: u64,\n}\n\n#[error_code]\npub enum ErrorCode {\n    #[msg(\"The campaign has ended\")]\n    CampaignEnded,\n    #[msg(\"The campaign has not ended yet\")]\n    CampaignNotEnded,\n    #[msg(\"The funding target was not reached\")]\n    TargetNotReached,\n}",
        "vulnerabilities": [
            "No refund mechanism if target not reached",
            "Lack of access control in donate function",
            "Missing checks for realistic campaign parameters",
            "No mechanism to update campaign details"
        ]
    },
    {
      "code": "use solana_program::{\n    account_info::{next_account_info, AccountInfo},\n    entrypoint,\n    entrypoint::ProgramResult,\n    program::invoke,\n    pubkey::Pubkey,\n    msg,\n};\n\nentrypoint!(process_instruction);\n\npub fn process_instruction(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    instruction_data: &[u8],\n) -> ProgramResult {\n    let accounts_iter = &mut accounts.iter();\n    let my_account = next_account_info(accounts_iter)?;\n    let target_program = next_account_info(accounts_iter)?;\n\n    if !my_account.is_signer {\n        return Err(ProgramError::MissingRequiredSignature);\n    }\n\n    msg!(\"Invoking target program\");\n    invoke(\n        &instruction_data,\n        &[my_account.clone(), target_program.clone()],\n    )?;\n\n    msg!(\"Target program invocation completed\");\n\n    Ok(())\n}",
      "vulnerabilities": [
        "Potential Reentrancy Attack"
      ]
    },
    {
        "code": "use anchor_lang::prelude::*;\n\ndeclare_id!(\"Auct11111111111111111111111111111111111111\");\n\n#[program]\npub mod vulnerable_auction {\n    use super::*;\n\n    pub fn create_auction(ctx: Context<CreateAuction>, end_time: i64, starting_price: u64) -> Result<()> {\n        let auction = &mut ctx.accounts.auction;\n        auction.seller = ctx.accounts.seller.key();\n        auction.end_time = end_time;\n        auction.highest_bid = starting_price;\n        auction.highest_bidder = None;\n        Ok(())\n    }\n\n    pub fn place_bid(ctx: Context<PlaceBid>, amount: u64) -> Result<()> {\n        let auction = &mut ctx.accounts.auction;\n        let bidder = &ctx.accounts.bidder;\n\n        if amount > auction.highest_bid {\n            auction.highest_bid = amount;\n            auction.highest_bidder = Some(bidder.key());\n        }\n\n        Ok(())\n    }\n\n    pub fn end_auction(ctx: Context<EndAuction>) -> Result<()> {\n        let auction = &mut ctx.accounts.auction;\n        auction.is_ended = true;\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct CreateAuction<'info> {\n    #[account(init, payer = seller, space = 8 + 32 + 8 + 8 + 32 + 1)]\n    pub auction: Account<'info, Auction>,\n    #[account(mut)]\n    pub seller: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct PlaceBid<'info> {\n    #[account(mut)]\n    pub auction: Account<'info, Auction>,\n    pub bidder: Signer<'info>,\n}\n\n#[derive(Accounts)]\npub struct EndAuction<'info> {\n    #[account(mut)]\n    pub auction: Account<'info, Auction>,\n    pub user: Signer<'info>,\n}\n\n#[account]\npub struct Auction {\n    pub seller: Pubkey,\n    pub end_time: i64,\n    pub highest_bid: u64,\n    pub highest_bidder: Option<Pubkey>,\n    pub is_ended: bool,\n}",
        "vulnerabilities": [
            "Absence of timestamp validation enables manipulation of time-sensitive operations, potentially compromising contract logic and fairness.",
            "Lack of explicit fund transfer mechanisms risks trapping user assets within the contract, leading to permanent loss of funds.",
            "Insufficient access controls allow unauthorized users to execute privileged functions, compromising overall contract security."
        ]
    },
    {
        "code": "use solana_program::{\n    account_info::AccountInfo,\n    entrypoint,\n    pubkey::Pubkey,\n    program_error::ProgramError,\n    msg,\n};\n\n#[derive(Debug)]\nenum MyInstruction {\n    DoSomething { value: u64 },\n}\n\nimpl MyInstruction {\n    fn unpack(input: &[u8]) -> Result<Self, ProgramError> {\n        // Implement instruction unpacking\n        unimplemented!()\n    }\n}\n\npub fn do_something(value: u64) -> Result<u64, ProgramError> {\n    value.checked_mul(2).ok_or(ProgramError::ArithmeticOverflow)\n}\n\nentrypoint!(process_instruction);\n\nfn process_instruction(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    instruction_data: &[u8],\n) -> ProgramResult {\n    let instruction = MyInstruction::unpack(instruction_data)?;\n\n    match instruction {\n        MyInstruction::DoSomething { value } => {\n            let result = do_something(value)?;\n            msg!(\"Result: {}\", result);\n        }\n    }\n\n    Ok(())\n}",
        "vulnerabilities": [
            "Unspecified function visibility defaults to public, potentially exposing sensitive operations to unauthorized external calls and manipulation."
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\n\ndeclare_id!(\"VulnCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC\");\n\n#[program]\npub mod vulnerable_dao {\n    use super::*;\n\n    pub fn create_proposal(ctx: Context<CreateProposal>, description: String, vote_end_time: i64) -> Result<()> {\n        let proposal = &mut ctx.accounts.proposal;\n        proposal.creator = ctx.accounts.creator.key();\n        proposal.description = description;\n        proposal.vote_end_time = vote_end_time;\n        proposal.yes_votes = 0;\n        proposal.no_votes = 0;\n        proposal.executed = false;\n        Ok(())\n    }\n\n    pub fn cast_vote(ctx: Context<CastVote>, vote: bool) -> Result<()> {\n        let proposal = &mut ctx.accounts.proposal;\n        let clock = Clock::get()?;\n\n        require!(clock.unix_timestamp < proposal.vote_end_time, ErrorCode::VotingEnded);\n\n        if vote {\n            proposal.yes_votes += 1;\n        } else {\n            proposal.no_votes += 1;\n        }\n\n        Ok(())\n    }\n\n    pub fn execute_proposal(ctx: Context<ExecuteProposal>) -> Result<()> {\n        let proposal = &mut ctx.accounts.proposal;\n        let clock = Clock::get()?;\n\n        require!(!proposal.executed, ErrorCode::AlreadyExecuted);\n        require!(clock.unix_timestamp >= proposal.vote_end_time, ErrorCode::VotingNotEnded);\n        require!(proposal.yes_votes > proposal.no_votes, ErrorCode::ProposalNotPassed);\n\n        proposal.executed = true;\n        // Execute proposal logic would go here\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct CreateProposal<'info> {\n    #[account(init, payer = creator, space = 8 + 32 + 1000 + 8 + 8 + 8 + 1)]\n    pub proposal: Account<'info, Proposal>,\n    #[account(mut)]\n    pub creator: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct CastVote<'info> {\n    #[account(mut)]\n    pub proposal: Account<'info, Proposal>,\n    pub voter: Signer<'info>,\n}\n\n#[derive(Accounts)]\npub struct ExecuteProposal<'info> {\n    #[account(mut)]\n    pub proposal: Account<'info, Proposal>,\n    pub executor: Signer<'info>,\n}\n\n#[account]\npub struct Proposal {\n    pub creator: Pubkey,\n    pub description: String,\n    pub vote_end_time: i64,\n    pub yes_votes: u64,\n    pub no_votes: u64,\n    pub executed: bool,\n}\n\n#[error_code]\npub enum ErrorCode {\n    #[msg(\"Voting has ended\")]\n    VotingEnded,\n    #[msg(\"Voting has not ended yet\")]\n    VotingNotEnded,\n    #[msg(\"Proposal has already been executed\")]\n    AlreadyExecuted,\n    #[msg(\"Proposal did not pass\")]\n    ProposalNotPassed,\n}",
        "vulnerabilities": [
            "Absence of token-weighted voting allows disproportionate influence by participants with minimal stake, undermining governance fairness.",
            "Missing quorum requirements enable passage of proposals with insufficient community engagement, risking unrepresentative decisions.",
            "Unrestricted access to proposal creation may lead to spam or malicious proposals, potentially disrupting governance processes.",
            "Lack of double voting prevention mechanisms compromises the integrity of voting results and allows unfair influence on outcomes."
        ]

    },
    
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\ndeclare_id!(\"Vuln44444444444444444444444444444444444444\");\n\n#[program]\npub mod vulnerable_swap {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {\n        ctx.accounts.pool.authority = ctx.accounts.authority.key();\n        Ok(())\n    }\n\n    pub fn swap(ctx: Context<Swap>, amount_in: u64) -> Result<()> {\n        let pool = &ctx.accounts.pool;\n        let rate = 1;\n        let amount_out = amount_in * rate;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_a.to_account_info(),\n                    to: ctx.accounts.pool_token_a.to_account_info(),\n                    authority: ctx.accounts.user.to_account_info(),\n                },\n            ),\n            amount_in,\n        )?;\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.pool_token_b.to_account_info(),\n                    to: ctx.accounts.user_token_b.to_account_info(),\n                    authority: pool.to_account_info(),\n                },\n                &[&[&pool.key().to_bytes(), &[*ctx.bumps.get(\"pool\").unwrap()]]],\n            ),\n            amount_out,\n        )?;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32)]\n    pub pool: Account<'info, Pool>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Swap<'info> {\n    #[account(mut)]\n    pub pool: Account<'info, Pool>,\n    #[account(mut)]\n    pub user: Signer<'info>,\n    #[account(mut)]\n    pub user_token_a: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub user_token_b: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_a: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_b: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct Pool {\n    pub authority: Pubkey,\n}",
        "vulnerabilities": [
            "Static exchange rates expose users to potential losses from market price fluctuations and enable exploitative arbitrage opportunities.",
            "Absence of slippage protection leaves users vulnerable to front-running attacks and unfavorable trade execution.",
            "Failure to verify sufficient liquidity before swaps may result in failed transactions or unexpected token shortages.",
            "Unrestricted access to swap function allows potential manipulation of pool balances and unauthorized trading activity."
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\n\ndeclare_id!(\"Vuln55555555555555555555555555555555555555\");\n\n#[program]\npub mod vulnerable_lottery {\n    use super::*;\n\n    pub fn create_lottery(ctx: Context<CreateLottery>, ticket_price: u64, end_time: i64) -> Result<()> {\n        let lottery = &mut ctx.accounts.lottery;\n        lottery.creator = ctx.accounts.creator.key();\n        lottery.ticket_price = ticket_price;\n        lottery.end_time = end_time;\n        lottery.winner = Pubkey::default();\n        Ok(())\n    }\n\n    pub fn buy_ticket(ctx: Context<BuyTicket>) -> Result<()> {\n        let lottery = &mut ctx.accounts.lottery;\n        require!(Clock::get()?.unix_timestamp < lottery.end_time, ErrorCode::LotteryEnded);\n\n        lottery.participants.push(ctx.accounts.buyer.key());\n        Ok(())\n    }\n\n    pub fn draw_winner(ctx: Context<DrawWinner>) -> Result<()> {\n        let lottery = &mut ctx.accounts.lottery;\n        require!(Clock::get()?.unix_timestamp >= lottery.end_time, ErrorCode::LotteryNotEnded);\n\n        let winner_index = Clock::get()?.unix_timestamp as usize % lottery.participants.len();\n        lottery.winner = lottery.participants[winner_index];\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct CreateLottery<'info> {\n    #[account(init, payer = creator, space = 8 + 32 + 8 + 8 + 32 + 1000)]\n    pub lottery: Account<'info, Lottery>,\n    #[account(mut)]\n    pub creator: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct BuyTicket<'info> {\n    #[account(mut)]\n    pub lottery: Account<'info, Lottery>,\n    #[account(mut)]\n    pub buyer: Signer<'info>,\n}\n\n#[derive(Accounts)]\npub struct DrawWinner<'info> {\n    #[account(mut)]\n    pub lottery: Account<'info, Lottery>,\n    pub creator: Signer<'info>,\n}\n\n#[account]\npub struct Lottery {\n    pub creator: Pubkey,\n    pub ticket_price: u64,\n    pub end_time: i64,\n    pub winner: Pubkey,\n    pub participants: Vec<Pubkey>,\n}\n\n#[error_code]\npub enum ErrorCode {\n    #[msg(\"Lottery has ended\")]\n    LotteryEnded,\n    #[msg(\"Lottery has not ended yet\")]\n    LotteryNotEnded,\n}",
        "vulnerabilities": [
            "Use of predictable on-chain data for randomness allows malicious actors to manipulate or forecast lottery outcomes, compromising fairness.",
            "Unlimited ticket purchases enable wealth concentration and domination of lottery odds by affluent participants.",
            "Omission of token transfers during ticket purchases risks economic imbalances and potential exploitation of the lottery system.",
            "Unrestricted access to winner selection function enables potential manipulation of lottery results by unauthorized parties."
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\npub mod vulnerable_lending {\n    use super::*;\n\n    pub fn initialize_pool(ctx: Context<InitializePool>, pool_seed: u64) -> Result<()> {\n        let pool = &mut ctx.accounts.pool;\n        pool.authority = ctx.accounts.authority.key();\n        pool.lending_token = ctx.accounts.lending_token.key();\n        pool.collateral_token = ctx.accounts.collateral_token.key();\n        pool.seed = pool_seed;\n        pool.total_borrowed = 0;\n        pool.total_collateral = 0;\n        Ok(())\n    }\n\n    pub fn deposit(ctx: Context<Deposit>, amount: u64) -> Result<()> {\n        let pool = &mut ctx.accounts.pool;\n        pool.total_collateral += amount;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_collateral.to_account_info(),\n                    to: ctx.accounts.pool_collateral.to_account_info(),\n                    authority: ctx.accounts.user.to_account_info(),\n                },\n            ),\n            amount,\n        )?;\n\n        Ok(())\n    }\n\n    pub fn borrow(ctx: Context<Borrow>, amount: u64) -> Result<()> {\n        let pool = &mut ctx.accounts.pool;\n        let user_collateral = ctx.accounts.user_collateral.amount;\n\n        require!(user_collateral >= amount * 2, LendingError::InsufficientCollateral);\n\n        pool.total_borrowed += amount;\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.pool_lending.to_account_info(),\n                    to: ctx.accounts.user_lending.to_account_info(),\n                    authority: pool.to_account_info(),\n                },\n                &[&[b\"pool\", &pool.seed.to_le_bytes(), &[ctx.bumps.pool]]],\n            ),\n            amount,\n        )?;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct InitializePool<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 32 + 32 + 8 + 8 + 8, seeds = [b\"pool\", pool_seed.to_le_bytes().as_ref()], bump)]\n    pub pool: Account<'info, LendingPool>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub lending_token: Account<'info, TokenAccount>,\n    pub collateral_token: Account<'info, TokenAccount>,\n    pub system_program: Program<'info, System>,\n    pub token_program: Program<'info, Token>,\n    pub rent: Sysvar<'info, Rent>,\n}\n\n#[derive(Accounts)]\npub struct Deposit<'info> {\n    #[account(mut)]\n    pub pool: Account<'info, LendingPool>,\n    #[account(mut)]\n    pub user_collateral: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_collateral: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct Borrow<'info> {\n    #[account(mut)]\n    pub pool: Account<'info, LendingPool>,\n    #[account(mut)]\n    pub user_lending: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_lending: Account<'info, TokenAccount>,\n    pub user_collateral: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct LendingPool {\n    pub authority: Pubkey,\n    pub lending_token: Pubkey,\n    pub collateral_token: Pubkey,\n    pub seed: u64,\n    pub total_borrowed: u64,\n    pub total_collateral: u64,\n}\n\n#[error_code]\npub enum LendingError {\n    #[msg(\"Insufficient collateral\")]\n    InsufficientCollateral,\n}\n",
        "vulnerabilities": [
          "Integer overflow risk in arithmetic operations (e.g., pool.total_collateral += amount)",
          "Lack of access control in the deposit and borrow functions",
          "Missing event emission for tracking state changes"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\npub mod vulnerable_voting {\n    use super::*;\n\n    pub fn create_proposal(ctx: Context<CreateProposal>, description: String, voting_period: i64) -> Result<()> {\n        let proposal = &mut ctx.accounts.proposal;\n        proposal.description = description;\n        proposal.creator = ctx.accounts.creator.key();\n        proposal.yes_votes = 0;\n        proposal.no_votes = 0;\n        proposal.end_time = Clock::get()?.unix_timestamp + voting_period;\n        proposal.is_active = true;\n        Ok(())\n    }\n\n    pub fn cast_vote(ctx: Context<CastVote>, vote: bool) -> Result<()> {\n        let proposal = &mut ctx.accounts.proposal;\n        let voter = &ctx.accounts.voter;\n\n        require!(proposal.is_active, VotingError::ProposalNotActive);\n        require!(Clock::get()?.unix_timestamp <= proposal.end_time, VotingError::VotingPeriodEnded);\n\n        let voting_power = ctx.accounts.voter_token_account.amount;\n\n        if vote {\n            proposal.yes_votes += voting_power;\n        } else {\n            proposal.no_votes += voting_power;\n        }\n\n        Ok(())\n    }\n\n    pub fn execute_proposal(ctx: Context<ExecuteProposal>) -> Result<()> {\n        let proposal = &mut ctx.accounts.proposal;\n\n        require!(proposal.is_active, VotingError::ProposalNotActive);\n        require!(Clock::get()?.unix_timestamp > proposal.end_time, VotingError::VotingPeriodNotEnded);\n\n        if proposal.yes_votes > proposal.no_votes {\n            // Execute proposal logic here\n            msg!(\"Proposal executed successfully\");\n        } else {\n            msg!(\"Proposal rejected\");\n        }\n\n        proposal.is_active = false;\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct CreateProposal<'info> {\n    #[account(init, payer = creator, space = 8 + 32 + 256 + 32 + 8 + 8 + 8 + 1)]\n    pub proposal: Account<'info, Proposal>,\n    #[account(mut)]\n    pub creator: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct CastVote<'info> {\n    #[account(mut)]\n    pub proposal: Account<'info, Proposal>,\n    pub voter: Signer<'info>,\n    pub voter_token_account: Account<'info, TokenAccount>,\n}\n\n#[derive(Accounts)]\npub struct ExecuteProposal<'info> {\n    #[account(mut)]\n    pub proposal: Account<'info, Proposal>,\n    pub executor: Signer<'info>,\n}\n\n#[account]\npub struct Proposal {\n    pub description: String,\n    pub creator: Pubkey,\n    pub yes_votes: u64,\n    pub no_votes: u64,\n    pub end_time: i64,\n    pub is_active: bool,\n}\n\n#[error_code]\npub enum VotingError {\n    #[msg(\"Proposal is not active\")]\n    ProposalNotActive,\n    #[msg(\"Voting period has ended\")]\n    VotingPeriodEnded,\n    #[msg(\"Voting period has not ended yet\")]\n    VotingPeriodNotEnded,\n}\n",
        "vulnerabilities": [
          "Lack of double voting prevention",
          "Integer overflow risk in vote counting (e.g., proposal.yes_votes += voting_power)",
          "Missing access control for proposal execution"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\npub mod vulnerable_auction {\n    use super::*;\n\n    pub fn create_auction(ctx: Context<CreateAuction>, item_name: String, start_price: u64, duration: i64) -> Result<()> {\n        let auction = &mut ctx.accounts.auction;\n        auction.creator = ctx.accounts.creator.key();\n        auction.item_name = item_name;\n        auction.highest_bid = start_price;\n        auction.highest_bidder = ctx.accounts.creator.key();\n        auction.end_time = Clock::get()?.unix_timestamp + duration;\n        auction.is_active = true;\n        Ok(())\n    }\n\n    pub fn place_bid(ctx: Context<PlaceBid>, bid_amount: u64) -> Result<()> {\n        let auction = &mut ctx.accounts.auction;\n        let bidder = ctx.accounts.bidder.key();\n\n        require!(auction.is_active, AuctionError::AuctionEnded);\n        require!(Clock::get()?.unix_timestamp < auction.end_time, AuctionError::AuctionEnded);\n        require!(bid_amount > auction.highest_bid, AuctionError::BidTooLow);\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.bidder_token.to_account_info(),\n                    to: ctx.accounts.auction_vault.to_account_info(),\n                    authority: ctx.accounts.bidder.to_account_info(),\n                },\n            ),\n            bid_amount,\n        )?;\n\n        if auction.highest_bidder != auction.creator {\n            token::transfer(\n                CpiContext::new_with_signer(\n                    ctx.accounts.token_program.to_account_info(),\n                    Transfer {\n                        from: ctx.accounts.auction_vault.to_account_info(),\n                        to: ctx.accounts.previous_bidder_token.to_account_info(),\n                        authority: auction.to_account_info(),\n                    },\n                    &[&[b\"auction\", auction.creator.as_ref(), &[ctx.bumps.auction]]],\n                ),\n                auction.highest_bid,\n            )?;\n        }\n\n        auction.highest_bid = bid_amount;\n        auction.highest_bidder = bidder;\n\n        Ok(())\n    }\n\n    pub fn end_auction(ctx: Context<EndAuction>) -> Result<()> {\n        let auction = &mut ctx.accounts.auction;\n\n        require!(auction.is_active, AuctionError::AuctionEnded);\n        require!(Clock::get()?.unix_timestamp >= auction.end_time, AuctionError::AuctionNotEnded);\n\n        auction.is_active = false;\n\n        if auction.highest_bidder != auction.creator {\n            token::transfer(\n                CpiContext::new_with_signer(\n                    ctx.accounts.token_program.to_account_info(),\n                    Transfer {\n                        from: ctx.accounts.auction_vault.to_account_info(),\n                        to: ctx.accounts.creator_token.to_account_info(),\n                        authority: auction.to_account_info(),\n                    },\n                    &[&[b\"auction\", auction.creator.as_ref(), &[ctx.bumps.auction]]],\n                ),\n                auction.highest_bid,\n            )?;\n        }\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct CreateAuction<'info> {\n    #[account(init, payer = creator, space = 8 + 32 + 256 + 8 + 32 + 8 + 1)]\n    pub auction: Account<'info, Auction>,\n    #[account(mut)]\n    pub creator: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct PlaceBid<'info> {\n    #[account(mut)]\n    pub auction: Account<'info, Auction>,\n    pub bidder: Signer<'info>,\n    #[account(mut)]\n    pub bidder_token: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub auction_vault: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub previous_bidder_token: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct EndAuction<'info> {\n    #[account(mut)]\n    pub auction: Account<'info, Auction>,\n    #[account(mut)]\n    pub auction_vault: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub creator_token: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct Auction {\n    pub creator: Pubkey,\n    pub item_name: String,\n    pub highest_bid: u64,\n    pub highest_bidder: Pubkey,\n    pub end_time: i64,\n    pub is_active: bool,\n}\n\n#[error_code]\npub enum AuctionError {\n    #[msg(\"Auction has ended\")]\n    AuctionEnded,\n    #[msg(\"Bid is too low\")]\n    BidTooLow,\n    #[msg(\"Auction has not ended yet\")]\n    AuctionNotEnded,\n}\n",
        "vulnerabilities": [
          "Lack of access control for ending the auction",
          "Potential for front-running in bid placement",
          "Missing event emission for important state changes"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\npub mod vulnerable_escrow {\n    use super::*;\n\n    pub fn initialize_escrow(\n        ctx: Context<InitializeEscrow>,\n        amount: u64,\n        recipient: Pubkey,\n    ) -> Result<()> {\n        let escrow = &mut ctx.accounts.escrow;\n        escrow.creator = ctx.accounts.creator.key();\n        escrow.recipient = recipient;\n        escrow.amount = amount;\n        escrow.is_active = true;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.creator_token.to_account_info(),\n                    to: ctx.accounts.escrow_vault.to_account_info(),\n                    authority: ctx.accounts.creator.to_account_info(),\n                },\n            ),\n            amount,\n        )?;\n\n        Ok(())\n    }\n\n    pub fn release_escrow(ctx: Context<ReleaseEscrow>) -> Result<()> {\n        let escrow = &mut ctx.accounts.escrow;\n\n        require!(escrow.is_active, EscrowError::EscrowNotActive);\n        require!(ctx.accounts.recipient.key() == escrow.recipient, EscrowError::UnauthorizedRecipient);\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.escrow_vault.to_account_info(),\n                    to: ctx.accounts.recipient_token.to_account_info(),\n                    authority: escrow.to_account_info(),\n                },\n                &[&[b\"escrow\", escrow.creator.as_ref(), &[ctx.bumps.escrow]]],\n            ),\n            escrow.amount,\n        )?;\n\n        escrow.is_active = false;\n\n        Ok(())\n    }\n\n    pub fn cancel_escrow(ctx: Context<CancelEscrow>) -> Result<()> {\n        let escrow = &mut ctx.accounts.escrow;\n\n        require!(escrow.is_active, EscrowError::EscrowNotActive);\n        require!(ctx.accounts.creator.key() == escrow.creator, EscrowError::UnauthorizedCreator);\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.escrow_vault.to_account_info(),\n                    to: ctx.accounts.creator_token.to_account_info(),\n                    authority: escrow.to_account_info(),\n                },\n                &[&[b\"escrow\", escrow.creator.as_ref(), &[ctx.bumps.escrow]]],\n            ),\n            escrow.amount,\n        )?;\n\n        escrow.is_active = false;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct InitializeEscrow<'info> {\n    #[account(init, payer = creator, space = 8 + 32 + 32 + 8 + 1)]\n    pub escrow: Account<'info, Escrow>,\n    #[account(mut)]\n    pub creator: Signer<'info>,\n    #[account(mut)]\n    pub creator_token: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub escrow_vault: Account<'info, TokenAccount>,\n    pub system_program: Program<'info, System>,\n    pub token_program: Program<'info, Token>,\n    pub rent: Sysvar<'info, Rent>,\n}\n\n#[derive(Accounts)]\npub struct ReleaseEscrow<'info> {\n    #[account(mut)]\n    pub escrow: Account<'info, Escrow>,\n    pub recipient: Signer<'info>,\n    #[account(mut)]\n    pub recipient_token: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub escrow_vault: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct CancelEscrow<'info> {\n    #[account(mut)]\n    pub escrow: Account<'info, Escrow>,\n    pub creator: Signer<'info>,\n    #[account(mut)]\n    pub creator_token: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub escrow_vault: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct Escrow {\n    pub creator: Pubkey,\n    pub recipient: Pubkey,\n    pub amount: u64,\n    pub is_active: bool,\n}\n\n#[error_code]\npub enum EscrowError {\n    #[msg(\"Escrow is not active\")]\n    EscrowNotActive,\n    #[msg(\"Unauthorized recipient\")]\n    UnauthorizedRecipient,\n    #[msg(\"Unauthorized creator\")]\n    UnauthorizedCreator,\n}\n",
        "vulnerabilities": [
          "Lack of timelock or expiration mechanism",
          "No protection against double-spending in case of program upgrade",
          "Missing event emission for tracking escrow state changes"
        ]
    },
    {
        "code": "use solana_program::{\n    account_info::{next_account_info, AccountInfo},\n    entrypoint,\n    entrypoint::ProgramResult,\n    pubkey::Pubkey,\n    program_error::ProgramError,\n};\n\nentrypoint!(process_instruction);\n\npub fn process_instruction(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    instruction_data: &[u8],\n) -> ProgramResult {\n    let accounts_iter = &mut accounts.iter();\n    let user_account = next_account_info(accounts_iter)?;\n    let data_account = next_account_info(accounts_iter)?;\n\n    if !user_account.is_signer {\n        return Err(ProgramError::MissingRequiredSignature);\n    }\n\n    // Check if the user is authorized to modify the data account\n    if user_account.key != &AUTHORIZED_USER {\n        return Err(ProgramError::Custom(1)); // Unauthorized access\n    }\n\n    // Implement logic to modify data in data_account\n    // ...\n\n    Ok(())\n}\n\n// Replace with your actual authorized user's public key\nconst AUTHORIZED_USER: Pubkey = Pubkey::new_from_array([0; 32]);",
        "vulnerabilities": [
          "Weak access control using a single hardcoded authorized user, lacking flexibility and creating a single point of failure."
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\n\n#[program]\npub mod auction {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, reserve_price: u64, end_time: i64) -> Result<()> {\n        let auction = &mut ctx.accounts.auction;\n        auction.reserve_price = reserve_price;\n        auction.end_time = end_time;\n        auction.highest_bid = 0;\n        auction.highest_bidder = Pubkey::default();\n        Ok(())\n    }\n\n    pub fn place_bid(ctx: Context<PlaceBid>, amount: u64) -> Result<()> {\n        let auction = &mut ctx.accounts.auction;\n        require!(amount > auction.highest_bid, AuctionError::BidTooLow);\n\n        auction.highest_bid = amount;\n        auction.highest_bidder = ctx.accounts.bidder.key();\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 8 + 8 + 32)]\n    pub auction: Account<'info, Auction>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct PlaceBid<'info> {\n    #[account(mut)]\n    pub auction: Account<'info, Auction>,\n    pub bidder: Signer<'info>,\n}\n\n#[account]\npub struct Auction {\n    pub reserve_price: u64,\n    pub end_time: i64,\n    pub highest_bid: u64,\n    pub highest_bidder: Pubkey,\n}\n\n#[error_code]\npub enum AuctionError {\n    #[msg(\"Bid too low\")]\n    BidTooLow,\n}",
        "vulnerabilities": [
            "Lack of refund mechanism for outbid participants, potentially leading to locked funds and decreased user participation",
            "Absence of bid verification, allowing malicious actors to manipulate auctions with fake or shill bids"
        ]
    },    
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\npub mod vulnerable_flash_loan {\n    use super::*;\n\n    pub fn initialize_pool(ctx: Context<InitializePool>, fee: u64) -> Result<()> {\n        let pool = &mut ctx.accounts.pool;\n        pool.token_mint = ctx.accounts.token_mint.key();\n        pool.token_account = ctx.accounts.pool_token_account.key();\n        pool.fee = fee;\n        Ok(())\n    }\n\n    pub fn flash_loan(ctx: Context<FlashLoan>, amount: u64) -> Result<()> {\n        let pool = &ctx.accounts.pool;\n        let pool_balance = ctx.accounts.pool_token_account.amount;\n\n        require!(amount <= pool_balance, FlashLoanError::InsufficientFunds);\n\n        // Transfer tokens to borrower\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.pool_token_account.to_account_info(),\n                    to: ctx.accounts.borrower_token_account.to_account_info(),\n                    authority: pool.to_account_info(),\n                },\n                &[&[b\"pool\", &[ctx.bumps.pool]]],\n            ),\n            amount,\n        )?;\n\n        // Invoke callback\n        ctx.accounts.callback_program.invoke(\n            &ctx.accounts.callback_info,\n            &[ctx.accounts.borrower.clone()],\n        )?;\n\n        // Calculate fee\n        let fee = amount.checked_mul(pool.fee).unwrap().checked_div(10000).unwrap();\n        let repay_amount = amount.checked_add(fee).unwrap();\n\n        // Repay loan with fee\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.borrower_token_account.to_account_info(),\n                    to: ctx.accounts.pool_token_account.to_account_info(),\n                    authority: ctx.accounts.borrower.to_account_info(),\n                },\n            ),\n            repay_amount,\n        )?;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct InitializePool<'info> {\n    #[account(init, payer = payer, space = 8 + 32 + 32 + 8)]\n    pub pool: Account<'info, FlashLoanPool>,\n    pub token_mint: Account<'info, Mint>,\n    #[account(mut)]\n    pub pool_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub payer: Signer<'info>,\n    pub system_program: Program<'info, System>,\n    pub token_program: Program<'info, Token>,\n    pub rent: Sysvar<'info, Rent>,\n}\n\n#[derive(Accounts)]\npub struct FlashLoan<'info> {\n    #[account(mut)]\n    pub pool: Account<'info, FlashLoanPool>,\n    #[account(mut)]\n    pub pool_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub borrower_token_account: Account<'info, TokenAccount>,\n    pub borrower: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n    /// CHECK: This account is not read or written in this instruction\n    pub callback_program: AccountInfo<'info>,\n    /// CHECK: This account is not read or written in this instruction\n    pub callback_info: AccountInfo<'info>,\n}\n\n#[account]\npub struct FlashLoanPool {\n    pub token_mint: Pubkey,\n    pub token_account: Pubkey,\n    pub fee: u64,\n}\n\n#[error_code]\npub enum FlashLoanError {\n    #[msg(\"Insufficient funds in the pool\")]\n    InsufficientFunds,\n}\n",
        "vulnerabilities": [
            "Absence of reentrancy guards in flash loan function, exposing contract to potential recursive calls and fund drainage",
            "Missing access restrictions for pool initialization, allowing unauthorized actors to manipulate initial pool settings",
            "Unprotected arithmetic operations in fee calculations, risking integer overflow and incorrect fee assessments"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\npub mod vulnerable_nft_marketplace {\n    use super::*;\n\n    pub fn list_nft(\n        ctx: Context<ListNFT>,\n        price: u64,\n    ) -> Result<()> {\n        let listing = &mut ctx.accounts.listing;\n        listing.seller = ctx.accounts.seller.key();\n        listing.nft_mint = ctx.accounts.nft_mint.key();\n        listing.price = price;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.seller_nft_account.to_account_info(),\n                    to: ctx.accounts.vault_nft_account.to_account_info(),\n                    authority: ctx.accounts.seller.to_account_info(),\n                },\n            ),\n            1,\n        )?;\n\n        Ok(())\n    }\n\n    pub fn buy_nft(\n        ctx: Context<BuyNFT>,\n    ) -> Result<()> {\n        let listing = &ctx.accounts.listing;\n\n        // Transfer payment\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.buyer_token_account.to_account_info(),\n                    to: ctx.accounts.seller_token_account.to_account_info(),\n                    authority: ctx.accounts.buyer.to_account_info(),\n                },\n            ),\n            listing.price,\n        )?;\n\n        // Transfer NFT\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.vault_nft_account.to_account_info(),\n                    to: ctx.accounts.buyer_nft_account.to_account_info(),\n                    authority: ctx.accounts.listing.to_account_info(),\n                },\n                &[&[b\"listing\", listing.seller.as_ref(), listing.nft_mint.as_ref(), &[ctx.bumps.listing]]],\n            ),\n            1,\n        )?;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct ListNFT<'info> {\n    #[account(init, payer = seller, space = 8 + 32 + 32 + 8)]\n    pub listing: Account<'info, NFTListing>,\n    #[account(mut)]\n    pub seller: Signer<'info>,\n    pub nft_mint: Account<'info, Mint>,\n    #[account(mut)]\n    pub seller_nft_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub vault_nft_account: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n    pub system_program: Program<'info, System>,\n    pub rent: Sysvar<'info, Rent>,\n}\n\n#[derive(Accounts)]\npub struct BuyNFT<'info> {\n    #[account(mut)]\n    pub listing: Account<'info, NFTListing>,\n    #[account(mut)]\n    pub buyer: Signer<'info>,\n    #[account(mut)]\n    pub seller_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub buyer_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub vault_nft_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub buyer_nft_account: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct NFTListing {\n    pub seller: Pubkey,\n    pub nft_mint: Pubkey,\n    pub price: u64,\n}\n",
        "vulnerabilities": [
          "Lack of check for NFT ownership in the listing process",
          "No mechanism to update or cancel listings",
          "Missing access control for buying (e.g., allow list)"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\npub mod vulnerable_governance {\n    use super::*;\n\n    pub fn create_proposal(ctx: Context<CreateProposal>, title: String, description: String, voting_period: i64) -> Result<()> {\n        let proposal = &mut ctx.accounts.proposal;\n        proposal.creator = ctx.accounts.creator.key();\n        proposal.title = title;\n        proposal.description = description;\n        proposal.yes_votes = 0;\n        proposal.no_votes = 0;\n        proposal.end_time = Clock::get()?.unix_timestamp + voting_period;\n        proposal.executed = false;\n        Ok(())\n    }\n\n    pub fn cast_vote(ctx: Context<CastVote>, vote: bool) -> Result<()> {\n        let proposal = &mut ctx.accounts.proposal;\n        let voter = &ctx.accounts.voter;\n\n        require!(Clock::get()?.unix_timestamp <= proposal.end_time, GovernanceError::VotingEnded);\n\n        let voting_power = ctx.accounts.voter_token_account.amount;\n\n        if vote {\n            proposal.yes_votes += voting_power;\n        } else {\n            proposal.no_votes += voting_power;\n        }\n\n        Ok(())\n    }\n\n    pub fn execute_proposal(ctx: Context<ExecuteProposal>) -> Result<()> {\n        let proposal = &mut ctx.accounts.proposal;\n\n        require!(!proposal.executed, GovernanceError::AlreadyExecuted);\n        require!(Clock::get()?.unix_timestamp > proposal.end_time, GovernanceError::VotingNotEnded);\n        require!(proposal.yes_votes > proposal.no_votes, GovernanceError::ProposalRejected);\n\n        // Execute proposal logic here\n        proposal.executed = true;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct CreateProposal<'info> {\n    #[account(init, payer = creator, space = 8 + 32 + 256 + 1024 + 8 + 8 + 8 + 1)]\n    pub proposal: Account<'info, Proposal>,\n    #[account(mut)]\n    pub creator: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct CastVote<'info> {\n    #[account(mut)]\n    pub proposal: Account<'info, Proposal>,\n    pub voter: Signer<'info>,\n    pub voter_token_account: Account<'info, TokenAccount>,\n}\n\n#[derive(Accounts)]\npub struct ExecuteProposal<'info> {\n    #[account(mut)]\n    pub proposal: Account<'info, Proposal>,\n    pub executor: Signer<'info>,\n}\n\n#[account]\npub struct Proposal {\n    pub creator: Pubkey,\n    pub title: String,\n    pub description: String,\n    pub yes_votes: u64,\n    pub no_votes: u64,\n    pub end_time: i64,\n    pub executed: bool,\n}\n\n#[error_code]\npub enum GovernanceError {\n    #[msg(\"Voting period has ended\")]\n    VotingEnded,\n    #[msg(\"Voting period has not ended yet\")]\n    VotingNotEnded,\n    #[msg(\"Proposal has already been executed\")]\n    AlreadyExecuted,\n    #[msg(\"Proposal was rejected\")]\n    ProposalRejected,\n}\n",
        "vulnerabilities": [
          "Lack of double voting prevention",
          "No quorum check for proposal execution",    
          "Missing access control for proposal execution"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\npub mod vulnerable_lottery {\n    use super::*;\n\n    pub fn initialize_lottery(ctx: Context<InitializeLottery>, ticket_price: u64, end_time: i64) -> Result<()> {\n        let lottery = &mut ctx.accounts.lottery;\n        lottery.creator = ctx.accounts.creator.key();\n        lottery.ticket_price = ticket_price;\n        lottery.end_time = end_time;\n        lottery.total_tickets = 0;\n        lottery.winner = Pubkey::default();\n        Ok(())\n    }\n\n    pub fn buy_ticket(ctx: Context<BuyTicket>) -> Result<()> {\n        let lottery = &mut ctx.accounts.lottery;\n\n        require!(Clock::get()?.unix_timestamp < lottery.end_time, LotteryError::LotteryEnded);\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.buyer_token_account.to_account_info(),\n                    to: ctx.accounts.lottery_token_account.to_account_info(),\n                    authority: ctx.accounts.buyer.to_account_info(),\n                },\n            ),\n            lottery.ticket_price,\n        )?;\n\n        lottery.total_tickets += 1;\n\n        Ok(())\n    }\n\n    pub fn draw_winner(ctx: Context<DrawWinner>) -> Result<()> {\n        let lottery = &mut ctx.accounts.lottery;\n\n        require!(Clock::get()?.unix_timestamp >= lottery.end_time, LotteryError::LotteryNotEnded);\n        require!(lottery.winner == Pubkey::default(), LotteryError::WinnerAlreadyDrawn);\n\n        // Use a deterministic way to select the winner\n        let random_seed = Clock::get()?.unix_timestamp;\n        let winner_index = random_seed as u64 % lottery.total_tickets;\n        lottery.winner = ctx.accounts.participants[winner_index as usize].key();\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct InitializeLottery<'info> {\n    #[account(init, payer = creator, space = 8 + 32 + 8 + 8 + 8 + 32)]\n    pub lottery: Account<'info, Lottery>,\n    #[account(mut)]\n    pub creator: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct BuyTicket<'info> {\n    #[account(mut)]\n    pub lottery: Account<'info, Lottery>,\n    pub buyer: Signer<'info>,\n    #[account(mut)]\n    pub buyer_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub lottery_token_account: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct DrawWinner<'info> {\n    #[account(mut)]\n    pub lottery: Account<'info, Lottery>,\n    pub drawer: Signer<'info>,\n    /// CHECK: This account is not read or written in this instruction\n    #[account(mut)]\n    pub participants: AccountInfo<'info>,\n}\n\n#[account]\npub struct Lottery {\n    pub creator: Pubkey,\n    pub ticket_price: u64,\n    pub end_time: i64,\n    pub total_tickets: u64,\n    pub winner: Pubkey,\n}\n\n#[error_code]\npub enum LotteryError {\n    #[msg(\"Lottery has ended\")]\n    LotteryEnded,\n    #[msg(\"Lottery has not ended yet\")]\n    LotteryNotEnded,\n    #[msg(\"Winner has already been drawn\")]\n    WinnerAlreadyDrawn,\n}\n",
        "vulnerabilities": [
          "Predictable randomness in winner selection",
          "Lack of access control for drawing the winner",
          "No mechanism to refund participants if the lottery fails"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\npub mod vulnerable_timelock {\n    use super::*;\n\n    pub fn create_timelock(ctx: Context<CreateTimelock>, amount: u64, release_time: i64) -> Result<()> {\n        let timelock = &mut ctx.accounts.timelock;\n        timelock.owner = ctx.accounts.owner.key();\n        timelock.amount = amount;\n        timelock.release_time = release_time;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.owner_token_account.to_account_info(),\n                    to: ctx.accounts.timelock_token_account.to_account_info(),\n                    authority: ctx.accounts.owner.to_account_info(),\n                },\n            ),\n            amount,\n        )?;\n\n        Ok(())\n    }\n\n    pub fn release_tokens(ctx: Context<ReleaseTokens>) -> Result<()> {\n        let timelock = &ctx.accounts.timelock;\n\n        require!(Clock::get()?.unix_timestamp >= timelock.release_time, TimelockError::TooEarly);\n\n        let seeds = &[\n            b\"timelock\".as_ref(),\n            timelock.owner.as_ref(),\n            &[ctx.bumps.timelock],\n        ];\n        let signer = &[&seeds[..]]; \n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.timelock_token_account.to_account_info(),\n                    to: ctx.accounts.owner_token_account.to_account_info(),\n                    authority: ctx.accounts.timelock.to_account_info(),\n                },\n                signer,\n            ),\n            timelock.amount,\n        )?;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct CreateTimelock<'info> {\n    #[account(init, payer = owner, space = 8 + 32 + 8 + 8, seeds = [b\"timelock\", owner.key().as_ref()], bump)]\n    pub timelock: Account<'info, Timelock>,\n    #[account(mut)]\n    pub owner: Signer<'info>,\n    #[account(mut)]\n    pub owner_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub timelock_token_account: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct ReleaseTokens<'info> {\n    #[account(mut, seeds = [b\"timelock\", timelock.owner.as_ref()], bump)]\n    pub timelock: Account<'info, Timelock>,\n    #[account(mut)]\n    pub timelock_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub owner_token_account: Account<'info, TokenAccount>,\n    pub owner: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct Timelock {\n    pub owner: Pubkey,\n    pub amount: u64,\n    pub release_time: i64,\n}\n\n#[error_code]\npub enum TimelockError {\n    #[msg(\"Cannot release tokens before the specified time\")]\n    TooEarly,\n}\n",
        "vulnerabilities": [
          "No mechanism to update or cancel the timelock",
          "Lack of partial withdrawal functionality",
          "Missing event emission for timelock creation and token release"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\npub mod vulnerable_token_swap {\n    use super::*;\n\n    pub fn initialize_pool(\n        ctx: Context<InitializePool>,\n        fee_numerator: u64,\n        fee_denominator: u64,\n    ) -> Result<()> {\n        let pool = &mut ctx.accounts.pool;\n        pool.token_a_mint = ctx.accounts.token_a_mint.key();\n        pool.token_b_mint = ctx.accounts.token_b_mint.key();\n        pool.token_a_account = ctx.accounts.pool_token_a_account.key();\n        pool.token_b_account = ctx.accounts.pool_token_b_account.key();\n        pool.fee_numerator = fee_numerator;\n        pool.fee_denominator = fee_denominator;\n        Ok(())\n    }\n\n    pub fn swap(\n        ctx: Context<Swap>,\n        amount_in: u64,\n        minimum_amount_out: u64,\n    ) -> Result<()> {\n        let pool = &ctx.accounts.pool;\n\n        let balance_a = ctx.accounts.pool_token_a_account.amount;\n        let balance_b = ctx.accounts.pool_token_b_account.amount;\n\n        let amount_out = (balance_b as u128)\n            .checked_mul(amount_in as u128)\n            .unwrap()\n            .checked_div(balance_a as u128)\n            .unwrap() as u64;\n\n        let fee = amount_out\n            .checked_mul(pool.fee_numerator)\n            .unwrap()\n            .checked_div(pool.fee_denominator)\n            .unwrap();\n\n        let amount_out_after_fee = amount_out.checked_sub(fee).unwrap();\n\n        require!(amount_out_after_fee >= minimum_amount_out, SwapError::SlippageExceeded);\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_a_account.to_account_info(),\n                    to: ctx.accounts.pool_token_a_account.to_account_info(),\n                    authority: ctx.accounts.user.to_account_info(),\n                },\n            ),\n            amount_in,\n        )?;\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.pool_token_b_account.to_account_info(),\n                    to: ctx.accounts.user_token_b_account.to_account_info(),\n                    authority: pool.to_account_info(),\n                },\n                &[&[b\"pool\", &[ctx.bumps.pool]]],\n            ),\n            amount_out_after_fee,\n        )?;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct InitializePool<'info> {\n    #[account(init, payer = payer, space = 8 + 32 + 32 + 32 + 32 + 8 + 8)]\n    pub pool: Account<'info, Pool>,\n    pub token_a_mint: Account<'info, Mint>,\n    pub token_b_mint: Account<'info, Mint>,\n    #[account(mut)]\n    pub pool_token_a_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_b_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub payer: Signer<'info>,\n    pub system_program: Program<'info, System>,\n    pub token_program: Program<'info, Token>,\n    pub rent: Sysvar<'info, Rent>,\n}\n\n#[derive(Accounts)]\npub struct Swap<'info> {\n    #[account(mut)]\n    pub pool: Account<'info, Pool>,\n    #[account(mut)]\n    pub user_token_a_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub user_token_b_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_a_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_b_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct Pool {\n    pub token_a_mint: Pubkey,\n    pub token_b_mint: Pubkey,\n    pub token_a_account: Pubkey,\n    pub token_b_account: Pubkey,\n    pub fee_numerator: u64,\n    pub fee_denominator: u64,\n}\n\n#[error_code]\npub enum SwapError {\n    #[msg(\"Slippage tolerance exceeded\")]\n    SlippageExceeded,\n}\n",
        "vulnerabilities": [
            "Insufficient precision in token calculations, potentially leading to rounding errors and cumulative losses over time",
            "Absence of flash loan attack mitigation, leaving the contract vulnerable to price manipulation and arbitrage exploitation",
            "Inadequate liquidity checks before swaps, risking failed transactions or unexpected slippage for users"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\n\n#[program]\npub mod reward_distribution {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, reward_amount: u64) -> Result<()> {\n        let reward = &mut ctx.accounts.reward;\n        reward.total_rewards = reward_amount;\n        reward.distributed_rewards = 0;\n        Ok(())\n    }\n\n    pub fn claim_reward(ctx: Context<ClaimReward>, amount: u64) -> Result<()> {\n        let reward = &mut ctx.accounts.reward;\n        reward.distributed_rewards += amount;\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 8 + 8)]\n    pub reward: Account<'info, Reward>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct ClaimReward<'info> {\n    #[account(mut)]\n    pub reward: Account<'info, Reward>,\n    pub claimant: Signer<'info>,\n}\n\n#[account]\npub struct Reward {\n    pub total_rewards: u64,\n    pub distributed_rewards: u64,\n}\n\n#[error_code]\npub enum RewardError {\n    #[msg(\"Insufficient reward balance\")]\n    InsufficientRewardBalance,\n}",
        "vulnerabilities": [
            "Unbounded reward distribution mechanism, potentially depleting contract funds or causing economic imbalances",
            "Lack of claim restrictions, enabling potential abuse of the reward system or unfair distribution"
        ]
    },    
    {
        "code": "use anchor_lang::prelude::*;\n\ndeclare_id!(\"Mult11111111111111111111111111111111111111\");\n\n#[program]\npub mod vulnerable_multisig {\n    use super::*;\n\n    pub fn create_multisig(ctx: Context<CreateMultisig>, owners: Vec<Pubkey>, threshold: u64) -> Result<()> {\n        let multisig = &mut ctx.accounts.multisig;\n        multisig.owners = owners;\n        multisig.threshold = threshold;\n        multisig.nonce = 0;\n        Ok(())\n    }\n\n    pub fn propose_transaction(ctx: Context<ProposeTransaction>, data: Vec<u8>) -> Result<()> {\n        let multisig = &mut ctx.accounts.multisig;\n        let transaction = &mut ctx.accounts.transaction;\n\n        transaction.multisig = multisig.key();\n        transaction.data = data;\n        transaction.signers = vec![];\n        transaction.did_execute = false;\n\n        multisig.nonce += 1;\n\n        Ok(())\n    }\n\n    pub fn approve(ctx: Context<Approve>) -> Result<()> {\n        let transaction = &mut ctx.accounts.transaction;\n        let owner = &ctx.accounts.owner;\n\n        transaction.signers.push(owner.key());\n\n        Ok(())\n    }\n\n    pub fn execute_transaction(ctx: Context<ExecuteTransaction>) -> Result<()> {\n        let multisig = &ctx.accounts.multisig;\n        let transaction = &mut ctx.accounts.transaction;\n\n        require!(transaction.signers.len() >= multisig.threshold as usize, ErrorCode::NotEnoughSigners);\n\n        transaction.did_execute = true;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct CreateMultisig<'info> {\n    #[account(init, payer = payer, space = 8 + 32 * 10 + 8 + 8)]\n    pub multisig: Account<'info, Multisig>,\n    #[account(mut)]\n    pub payer: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct ProposeTransaction<'info> {\n    #[account(mut)]\n    pub multisig: Account<'info, Multisig>,\n    #[account(init, payer = proposer, space = 8 + 32 + 1000 + 32 * 10 + 1)]\n    pub transaction: Account<'info, Transaction>,\n    #[account(mut)]\n    pub proposer: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Approve<'info> {\n    #[account(mut)]\n    pub transaction: Account<'info, Transaction>,\n    pub owner: Signer<'info>,\n}\n\n#[derive(Accounts)]\npub struct ExecuteTransaction<'info> {\n    pub multisig: Account<'info, Multisig>,\n    #[account(mut)]\n    pub transaction: Account<'info, Transaction>,\n}\n\n#[account]\npub struct Multisig {\n    pub owners: Vec<Pubkey>,\n    pub threshold: u64,\n    pub nonce: u64,\n}\n\n#[account]\npub struct Transaction {\n    pub multisig: Pubkey,\n    pub data: Vec<u8>,\n    pub signers: Vec<Pubkey>,\n    pub did_execute: bool,\n}\n\n#[error_code]\npub enum ErrorCode {\n    #[msg(\"Not enough signers to execute the transaction\")]\n    NotEnoughSigners,\n}",
        "vulnerabilities": [
            "Inadequate owner authentication, risking unauthorized access to privileged functions",
            "Absence of nonce or timestamp checks, leaving contract susceptible to transaction replay attacks",
            "Missing time delay for critical operations, allowing immediate execution of potentially harmful changes"
        ]
    },
    {
        "code": "use solana_program::{\n    account_info::AccountInfo,\n    entrypoint,\n    msg,\n    pubkey::Pubkey,\n    program_error::ProgramError,\n};\n\n#[derive(Debug)]\nenum MyInstruction {\n    DoSomething { value: u64 },\n}\n\nimpl MyInstruction {\n    fn unpack(input: &[u8]) -> Result<Self, ProgramError> {\n        // Implement instruction unpacking\n        unimplemented!()\n    }\n}\n\nentrypoint!(process_instruction);\n\nfn process_instruction(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    instruction_data: &[u8],\n) -> ProgramResult {\n    let instruction = MyInstruction::unpack(instruction_data)?;\n\n    match instruction {\n        MyInstruction::DoSomething { value } => {\n            match do_some_calculation(value) {\n                Ok(result) => msg!(\"Calculation result: {}\", result),\n                Err(e) => {\n                    msg!(\"Error in calculation: {:?}\", e);\n                    return Err(e);\n                }\n            }\n        }\n    }\n\n    Ok(())\n}\n\nfn do_some_calculation(value: u64) -> Result<u64, ProgramError> {\n    value.checked_mul(2).ok_or(ProgramError::ArithmeticOverflow)\n}",
        "vulnerabilities": [
            "Improper exception handling, potentially exposing sensitive information or leaving the contract in an inconsistent state"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\ndeclare_id!(\"Wrap11111111111111111111111111111111111111\");\n\n#[program]\npub mod vulnerable_token_wrapper {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {\n        let wrapper = &mut ctx.accounts.wrapper;\n        wrapper.authority = ctx.accounts.authority.key();\n        wrapper.total_supply = 0;\n        Ok(())\n    }\n\n    pub fn wrap(ctx: Context<Wrap>, amount: u64) -> Result<()> {\n        let wrapper = &mut ctx.accounts.wrapper;\n        let user = &ctx.accounts.user;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_account.to_account_info(),\n                    to: ctx.accounts.wrapper_token_account.to_account_info(),\n                    authority: user.to_account_info(),\n                },\n            ),\n            amount,\n        )?;\n\n        wrapper.total_supply += amount;\n\n        Ok(())\n    }\n\n    pub fn unwrap(ctx: Context<Unwrap>, amount: u64) -> Result<()> {\n        let wrapper = &mut ctx.accounts.wrapper;\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.wrapper_token_account.to_account_info(),\n                    to: ctx.accounts.user_token_account.to_account_info(),\n                    authority: wrapper.to_account_info(),\n                },\n                &[&[&wrapper.authority.to_bytes(), &[*ctx.bumps.get(\"wrapper\").unwrap()]]],\n            ),\n            amount,\n        )?;\n\n        wrapper.total_supply -= amount;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 8)]\n    pub wrapper: Account<'info, Wrapper>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Wrap<'info> {\n    #[account(mut)]\n    pub wrapper: Account<'info, Wrapper>,\n    pub user: Signer<'info>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub wrapper_token_account: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct Unwrap<'info> {\n    #[account(mut)]\n    pub wrapper: Account<'info, Wrapper>,\n    pub user: Signer<'info>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub wrapper_token_account: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct Wrapper {\n    pub authority: Pubkey,\n    pub total_supply: u64,\n}",
        "vulnerabilities": [
            "Unrestricted minting capabilities allow potential token supply manipulation, risking economic instability and devaluation.",
            "Absence of balance verifications before transfers may lead to unauthorized token creation or destruction, compromising token integrity.",
            "Lack of contract pausability leaves the system without an emergency brake, hindering rapid response to critical issues or attacks."
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\ndeclare_id!(\"Vuln22222222222222222222222222222222222222\");\n\n#[program]\npub mod vulnerable_auction {\n    use super::*;\n\n    pub fn create_auction(ctx: Context<CreateAuction>, min_bid: u64, duration: i64) -> Result<()> {\n        let auction = &mut ctx.accounts.auction;\n        auction.creator = ctx.accounts.creator.key();\n        auction.highest_bidder = Pubkey::default();\n        auction.highest_bid = min_bid;\n        auction.end_time = Clock::get()?.unix_timestamp + duration;\n        auction.ended = false;\n        Ok(())\n    }\n\n    pub fn place_bid(ctx: Context<PlaceBid>, bid_amount: u64) -> Result<()> {\n        let auction = &mut ctx.accounts.auction;\n        require!(!auction.ended, ErrorCode::AuctionEnded);\n        require!(bid_amount > auction.highest_bid, ErrorCode::BidTooLow);\n\n        if auction.highest_bidder != Pubkey::default() {\n            token::transfer(\n                CpiContext::new_with_signer(\n                    ctx.accounts.token_program.to_account_info(),\n                    Transfer {\n                        from: ctx.accounts.auction_vault.to_account_info(),\n                        to: ctx.accounts.previous_bidder_token.to_account_info(),\n                        authority: auction.to_account_info(),\n                    },\n                    &[&[&auction.key().to_bytes(), &[*ctx.bumps.get(\"auction\").unwrap()]]],\n                ),\n                auction.highest_bid,\n            )?;\n        }\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.bidder_token.to_account_info(),\n                    to: ctx.accounts.auction_vault.to_account_info(),\n                    authority: ctx.accounts.bidder.to_account_info(),\n                },\n            ),\n            bid_amount,\n        )?;\n\n        auction.highest_bidder = ctx.accounts.bidder.key();\n        auction.highest_bid = bid_amount;\n\n        Ok(())\n    }\n\n    pub fn end_auction(ctx: Context<EndAuction>) -> Result<()> {\n        let auction = &mut ctx.accounts.auction;\n        require!(!auction.ended, ErrorCode::AuctionAlreadyEnded);\n        require!(Clock::get()?.unix_timestamp >= auction.end_time, ErrorCode::AuctionNotEnded);\n\n        auction.ended = true;\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.auction_vault.to_account_info(),\n                    to: ctx.accounts.creator_token.to_account_info(),\n                    authority: auction.to_account_info(),\n                },\n                &[&[&auction.key().to_bytes(), &[*ctx.bumps.get(\"auction\").unwrap()]]],\n            ),\n            auction.highest_bid,\n        )?;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct CreateAuction<'info> {\n    #[account(init, payer = creator, space = 8 + 32 + 32 + 8 + 8 + 1)]\n    pub auction: Account<'info, Auction>,\n    #[account(mut)]\n    pub creator: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct PlaceBid<'info> {\n    #[account(mut)]\n    pub auction: Account<'info, Auction>,\n    #[account(mut)]\n    pub bidder: Signer<'info>,\n    #[account(mut)]\n    pub bidder_token: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub auction_vault: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub previous_bidder_token: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct EndAuction<'info> {\n    #[account(mut)]\n    pub auction: Account<'info, Auction>,\n    #[account(mut)]\n    pub creator: Signer<'info>,\n    #[account(mut)]\n    pub creator_token: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub auction_vault: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct Auction {\n    pub creator: Pubkey,\n    pub highest_bidder: Pubkey,\n    pub highest_bid: u64,\n    pub end_time: i64,\n    pub ended: bool,\n}\n\n#[error_code]\npub enum ErrorCode {\n    #[msg(\"Auction has already ended\")]\n    AuctionEnded,\n    #[msg(\"Bid is too low\")]\n    BidTooLow,\n    #[msg(\"Auction has already ended\")]\n    AuctionAlreadyEnded,\n    #[msg(\"Auction has not ended yet\")]\n    AuctionNotEnded,\n}",
        "vulnerabilities": [
            "Failure to validate auction_vault ownership enables potential misappropriation of funds and unauthorized auction creation.",
            "Insufficient verification of bidder's token account ownership allows potential bidding with funds from unauthorized accounts.",
            "Absence of a time extension mechanism for last-minute bids risks unfair auction outcomes and vulnerability to sniping attacks.",
            "Lack of auction cancellation functionality for creators limits flexibility and may lead to problematic auctions persisting."
          ]
    },
    {
        "code": "use anchor_lang::prelude::*;\n\n#[program]\npub mod token {\n    use super::*;\n\n    pub fn mint(ctx: Context<Mint>, amount: u64) -> Result<()> {\n        let token = &mut ctx.accounts.token;\n        token.total_supply += amount; // Vulnerable to overflow\n        Ok(())\n    }\n\n    pub fn transfer(ctx: Context<Transfer>, amount: u64) -> Result<()> {\n        let from = &mut ctx.accounts.from;\n        let to = &mut ctx.accounts.to;\n        require!(from.balance >= amount, TokenError::InsufficientFunds);\n\n        from.balance -= amount;\n        to.balance += amount;\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Mint<'info> {\n    #[account(mut)]\n    pub token: Account<'info, Token>,\n    pub authority: Signer<'info>,\n}\n\n#[derive(Accounts)]\npub struct Transfer<'info> {\n    #[account(mut)]\n    pub from: Account<'info, Wallet>,\n    #[account(mut)]\n    pub to: Account<'info, Wallet>,\n    pub authority: Signer<'info>,\n}\n\n#[account]\npub struct Token {\n    pub total_supply: u64,\n}\n\n#[account]\npub struct Wallet {\n    pub balance: u64,\n}\n\n#[error_code]\npub enum TokenError {\n    #[msg(\"Insufficient funds\")]\n    InsufficientFunds,\n}",
        "vulnerabilities": [
            "Unchecked arithmetic in mint function risks integer overflow, potentially allowing unauthorized token creation and supply manipulation.",
            "Absence of access controls on minting function enables unrestricted token creation by any user, compromising token economics."
        ]
    },    
    {
        "code": "use solana_program::{\n    account_info::{next_account_info, AccountInfo},\n    entrypoint,\n    entrypoint::ProgramResult,\n    program::invoke,\n    pubkey::Pubkey,\n    msg,\n};\n\n#[derive(Debug)]\nenum MyInstruction {\n    TransferTokens { amount: u64 },\n}\n\nimpl MyInstruction {\n    fn unpack(input: &[u8]) -> Result<Self, ProgramError> {\n        // Implement instruction unpacking\n        unimplemented!()\n    }\n}\n\nentrypoint!(process_instruction);\n\nfn process_instruction(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    instruction_data: &[u8],\n) -> ProgramResult {\n    let instruction = MyInstruction::unpack(instruction_data)?;\n    let accounts_iter = &mut accounts.iter();\n    let user_account = next_account_info(accounts_iter)?;\n    let token_account = next_account_info(accounts_iter)?;\n    let token_program = next_account_info(accounts_iter)?;\n\n    match instruction {\n        MyInstruction::TransferTokens { amount } => {\n            // Incorrect: Directly transferring tokens without approval\n            let ix = spl_token::instruction::transfer(\n                token_program.key,\n                token_account.key,\n                token_account.key,\n                user_account.key,\n                &[],\n                amount,\n            )?;\n            invoke(&ix, &[token_account.clone(), token_account.clone(), user_account.clone()])?;\n            msg!(\"Transferred {} tokens\", amount);\n        }\n    }\n\n    Ok(())\n}",
        "vulnerabilities": [
            "Improper implementation of ERC20 token standard may lead to unexpected behavior, incompatibility issues, and potential loss of funds."
        ]
    },
    {
        "code": "use solana_program::{\n    account_info::{next_account_info, AccountInfo},\n    entrypoint,\n    entrypoint::ProgramResult,\n    msg,\n    program::invoke,\n    pubkey::Pubkey,\n    system_instruction,\n};\n\nentrypoint!(process_instruction);\n\nfn process_instruction(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    instruction_data: &[u8],\n) -> ProgramResult {\n    let accounts_iter = &mut accounts.iter();\n    let user_account = next_account_info(accounts_iter)?;\n    let target_account = next_account_info(accounts_iter)?;\n\n    if !user_account.is_signer {\n        msg!(\"User account must be a signer\");\n        return Err(ProgramError::MissingRequiredSignature);\n    }\n\n    let amount = u64::from_le_bytes(\n        instruction_data.get(..8)\n            .and_then(|slice| slice.try_into().ok())\n            .ok_or(ProgramError::InvalidInstructionData)?\n    );\n\n    let initial_user_balance = user_account.lamports();\n    let initial_target_balance = target_account.lamports();\n\n    invoke(\n        &system_instruction::transfer(user_account.key, target_account.key, amount),\n        &[user_account.clone(), target_account.clone()],\n    )?;\n\n    msg!(\"Transferred {} lamports from {} to {}\",\n         amount, user_account.key, target_account.key);\n\n    // Verify the transfer\n    if user_account.lamports() != initial_user_balance - amount\n        || target_account.lamports() != initial_target_balance + amount {\n        return Err(ProgramError::InsufficientFunds);\n    }\n\n    Ok(())\n}",
        "vulnerabilities": [
            "Violation of Checks-Effects-Interactions pattern exposes contract to potential reentrancy attacks, risking unauthorized state changes.",
            "Unprotected arithmetic operations risk integer overflow/underflow, leading to unexpected behavior and potential fund loss."
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\npub mod vulnerable_multisig_wallet {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, owners: Vec<Pubkey>, threshold: u64) -> Result<()> {\n        let multisig = &mut ctx.accounts.multisig;\n        multisig.owners = owners;\n        multisig.threshold = threshold;\n        multisig.transaction_count = 0;\n        Ok(())\n    }\n\n    pub fn create_transaction(ctx: Context<CreateTransaction>, to: Pubkey, amount: u64) -> Result<()> {\n        let multisig = &mut ctx.accounts.multisig;\n        let transaction = &mut ctx.accounts.transaction;\n\n        transaction.to = to;\n        transaction.amount = amount;\n        transaction.approvals = vec![ctx.accounts.proposer.key()];\n        transaction.executed = false;\n\n        multisig.transaction_count += 1;\n\n        Ok(())\n    }\n\n    pub fn approve_transaction(ctx: Context<ApproveTransaction>) -> Result<()> {\n        let transaction = &mut ctx.accounts.transaction;\n        let approver = ctx.accounts.approver.key();\n\n        require!(!transaction.approvals.contains(&approver), ErrorCode::AlreadyApproved);\n\n        transaction.approvals.push(approver);\n\n        Ok(())\n    }\n\n    pub fn execute_transaction(ctx: Context<ExecuteTransaction>) -> Result<()> {\n        let multisig = &ctx.accounts.multisig;\n        let transaction = &mut ctx.accounts.transaction;\n\n        require!(!transaction.executed, ErrorCode::AlreadyExecuted);\n        require!(transaction.approvals.len() as u64 >= multisig.threshold, ErrorCode::InsufficientApprovals);\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.multisig_token_account.to_account_info(),\n                    to: ctx.accounts.to_token_account.to_account_info(),\n                    authority: multisig.to_account_info(),\n                },\n                &[&[&multisig.to_account_info().key.as_ref(), &[*ctx.bumps.get(\"multisig\").unwrap()]]],\n            ),\n            transaction.amount,\n        )?;\n\n        transaction.executed = true;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = payer, space = 8 + 32 * 10 + 8 + 8)]\n    pub multisig: Account<'info, Multisig>,\n    #[account(mut)]\n    pub payer: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct CreateTransaction<'info> {\n    #[account(mut)]\n    pub multisig: Account<'info, Multisig>,\n    #[account(init, payer = proposer, space = 8 + 32 + 8 + 32 * 10 + 1)]\n    pub transaction: Account<'info, Transaction>,\n    #[account(mut)]\n    pub proposer: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct ApproveTransaction<'info> {\n    pub multisig: Account<'info, Multisig>,\n    #[account(mut)]\n    pub transaction: Account<'info, Transaction>,\n    pub approver: Signer<'info>,\n}\n\n#[derive(Accounts)]\npub struct ExecuteTransaction<'info> {\n    pub multisig: Account<'info, Multisig>,\n    #[account(mut)]\n    pub transaction: Account<'info, Transaction>,\n    #[account(mut)]\n    pub multisig_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub to_token_account: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct Multisig {\n    pub owners: Vec<Pubkey>,\n    pub threshold: u64,\n    pub transaction_count: u64,\n}\n\n#[account]\npub struct Transaction {\n    pub to: Pubkey,\n    pub amount: u64,\n    pub approvals: Vec<Pubkey>,\n    pub executed: bool,\n}",
        "vulnerabilities": [
            "Lack of ownership validation in approve_transaction function allows non-owners to approve transactions, compromising multi-sig security.",
            "Absence of timelock for transaction execution enables immediate processing of approved transactions, reducing safeguards against malicious actions.",
            "Missing functionality for owner management limits adaptability and poses risks if owner accounts are compromised or inaccessible."
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\npub mod vulnerable_escrow {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, amount: u64) -> Result<()> {\n        let escrow = &mut ctx.accounts.escrow;\n        escrow.initializer = ctx.accounts.initializer.key();\n        escrow.initializer_deposit_token_account = ctx.accounts.initializer_deposit_token_account.key();\n        escrow.initializer_receive_token_account = ctx.accounts.initializer_receive_token_account.key();\n        escrow.amount = amount;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.initializer_deposit_token_account.to_account_info(),\n                    to: ctx.accounts.vault_account.to_account_info(),\n                    authority: ctx.accounts.initializer.to_account_info(),\n                },\n            ),\n            amount,\n        )?;\n\n        Ok(())\n    }\n\n    pub fn cancel(ctx: Context<Cancel>) -> Result<()> {\n        let escrow = &ctx.accounts.escrow;\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.vault_account.to_account_info(),\n                    to: ctx.accounts.initializer_deposit_token_account.to_account_info(),\n                    authority: escrow.to_account_info(),\n                },\n                &[&[&escrow.initializer.to_bytes(), &[*ctx.bumps.get(\"escrow\").unwrap()]]],\n            ),\n            escrow.amount,\n        )?;\n\n        Ok(())\n    }\n\n    pub fn exchange(ctx: Context<Exchange>) -> Result<()> {\n        let escrow = &ctx.accounts.escrow;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.taker_deposit_token_account.to_account_info(),\n                    to: ctx.accounts.initializer_receive_token_account.to_account_info(),\n                    authority: ctx.accounts.taker.to_account_info(),\n                },\n            ),\n            escrow.amount, // Assuming 1:1 exchange rate\n        )?;\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.vault_account.to_account_info(),\n                    to: ctx.accounts.taker_receive_token_account.to_account_info(),\n                    authority: escrow.to_account_info(),\n                },\n                &[&[&escrow.initializer.to_bytes(), &[*ctx.bumps.get(\"escrow\").unwrap()]]],\n            ),\n            escrow.amount,\n        )?;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = initializer, space = 8 + 32 + 32 + 32 + 8)]\n    pub escrow: Account<'info, Escrow>,\n    #[account(mut)]\n    pub initializer: Signer<'info>,\n    #[account(mut)]\n    pub initializer_deposit_token_account: Account<'info, TokenAccount>,\n    pub initializer_receive_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub vault_account: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Cancel<'info> {\n    #[account(mut, has_one = initializer)]\n    pub escrow: Account<'info, Escrow>,\n    #[account(mut)]\n    pub initializer: Signer<'info>,\n    #[account(mut)]\n    pub initializer_deposit_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub vault_account: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct Exchange<'info> {\n    #[account(mut)]\n    pub escrow: Account<'info, Escrow>,\n    #[account(mut)]\n    pub taker: Signer<'info>,\n    #[account(mut)]\n    pub initializer_receive_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub taker_deposit_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub taker_receive_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub vault_account: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct Escrow {\n    pub initializer: Pubkey,\n    pub initializer_deposit_token_account: Pubkey,\n    pub initializer_receive_token_account: Pubkey,\n    pub amount: u64,\n}",
        "vulnerabilities": [
            "Insufficient verification of token account ownership in exchange function allows potential unauthorized transfers and theft of user funds.",
            "Absence of time-bound expiration for escrow enables indefinite fund locking, risking permanent asset inaccessibility.",
            "Lack of fee structure for escrow service may lead to economic unsustainability and potential exploitation of the platform."
          ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\ndeclare_id!(\"Govn11111111111111111111111111111111111111\");\n\n#[program]\npub mod vulnerable_governance {\n    use super::*;\n\n    pub fn create_proposal(ctx: Context<CreateProposal>, description: String, voting_period: i64) -> Result<()> {\n        let proposal = &mut ctx.accounts.proposal;\n        proposal.description = description;\n        proposal.proposer = ctx.accounts.proposer.key();\n        proposal.yes_votes = 0;\n        proposal.no_votes = 0;\n        proposal.start_time = Clock::get()?.unix_timestamp;\n        proposal.end_time = proposal.start_time + voting_period;\n        proposal.executed = false;\n        Ok(())\n    }\n\n    pub fn cast_vote(ctx: Context<CastVote>, vote: bool) -> Result<()> {\n        let proposal = &mut ctx.accounts.proposal;\n        let voter = &ctx.accounts.voter;\n\n        if vote {\n            proposal.yes_votes += 1;\n        } else {\n            proposal.no_votes += 1;\n        }\n\n        Ok(())\n    }\n\n    pub fn execute_proposal(ctx: Context<ExecuteProposal>) -> Result<()> {\n        let proposal = &mut ctx.accounts.proposal;\n        proposal.executed = true;\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct CreateProposal<'info> {\n    #[account(init, payer = proposer, space = 8 + 256 + 32 + 8 + 8 + 8 + 8 + 1)]\n    pub proposal: Account<'info, Proposal>,\n    #[account(mut)]\n    pub proposer: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct CastVote<'info> {\n    #[account(mut)]\n    pub proposal: Account<'info, Proposal>,\n    pub voter: Signer<'info>,\n}\n\n#[derive(Accounts)]\npub struct ExecuteProposal<'info> {\n    #[account(mut)]\n    pub proposal: Account<'info, Proposal>,\n    pub executor: Signer<'info>,\n}\n\n#[account]\npub struct Proposal {\n    pub description: String,\n    pub proposer: Pubkey,\n    pub yes_votes: u64,\n    pub no_votes: u64,\n    pub start_time: i64,\n    pub end_time: i64,\n    pub executed: bool,\n}",
        "vulnerabilities": [
            "Failure to account for token holdings in vote weight calculation enables disproportionate influence by participants with minimal stake.",
            "Missing validation of voting period duration risks creation of instantaneous or excessively long governance processes.",
            "Unrestricted access to proposal execution function allows unauthorized implementation of governance decisions."
          ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\ndeclare_id!(\"Vuln11111111111111111111111111111111111111\");\n\n#[program]\npub mod vulnerable_staking {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, reward_rate: u64) -> Result<()> {\n        let staking_pool = &mut ctx.accounts.staking_pool;\n        staking_pool.reward_rate = reward_rate;\n        staking_pool.total_staked = 0;\n        Ok(())\n    }\n\n    pub fn stake(ctx: Context<Stake>, amount: u64) -> Result<()> {\n        let staking_pool = &mut ctx.accounts.staking_pool;\n        let user = &mut ctx.accounts.user;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token.to_account_info(),\n                    to: ctx.accounts.pool_token.to_account_info(),\n                    authority: user.to_account_info(),\n                },\n            ),\n            amount,\n        )?;\n\n        staking_pool.total_staked += amount;\n        user.staked_amount += amount;\n        user.last_stake_timestamp = Clock::get()?.unix_timestamp;\n\n        Ok(())\n    }\n\n    pub fn unstake(ctx: Context<Unstake>, amount: u64) -> Result<()> {\n        let staking_pool = &mut ctx.accounts.staking_pool;\n        let user = &mut ctx.accounts.user;\n\n        require!(user.staked_amount >= amount, ErrorCode::InsufficientFunds);\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.pool_token.to_account_info(),\n                    to: ctx.accounts.user_token.to_account_info(),\n                    authority: staking_pool.to_account_info(),\n                },\n                &[&[&staking_pool.key().to_bytes(), &[*ctx.bumps.get(\"staking_pool\").unwrap()]]],\n            ),\n            amount,\n        )?;\n\n        staking_pool.total_staked -= amount;\n        user.staked_amount -= amount;\n\n        Ok(())\n    }\n\n    pub fn claim_rewards(ctx: Context<ClaimRewards>) -> Result<()> {\n        let staking_pool = &ctx.accounts.staking_pool;\n        let user = &mut ctx.accounts.user;\n\n        let current_time = Clock::get()?.unix_timestamp;\n        let time_staked = current_time - user.last_stake_timestamp;\n        let rewards = (user.staked_amount * staking_pool.reward_rate * time_staked as u64) / (365 * 24 * 60 * 60 * 100);\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.reward_token.to_account_info(),\n                    to: ctx.accounts.user_token.to_account_info(),\n                    authority: staking_pool.to_account_info(),\n                },\n                &[&[&staking_pool.key().to_bytes(), &[*ctx.bumps.get(\"staking_pool\").unwrap()]]],\n            ),\n            rewards,\n        )?;\n\n        user.last_stake_timestamp = current_time;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = payer, space = 8 + 8 + 8)]\n    pub staking_pool: Account<'info, StakingPool>,\n    #[account(mut)]\n    pub payer: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Stake<'info> {\n    #[account(mut)]\n    pub staking_pool: Account<'info, StakingPool>,\n    #[account(mut)]\n    pub user: Account<'info, User>,\n    #[account(mut)]\n    pub user_token: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct Unstake<'info> {\n    #[account(mut)]\n    pub staking_pool: Account<'info, StakingPool>,\n    #[account(mut)]\n    pub user: Account<'info, User>,\n    #[account(mut)]\n    pub user_token: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct ClaimRewards<'info> {\n    #[account(mut)]\n    pub staking_pool: Account<'info, StakingPool>,\n    #[account(mut)]\n    pub user: Account<'info, User>,\n    #[account(mut)]\n    pub user_token: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub reward_token: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct StakingPool {\n    pub reward_rate: u64,\n    pub total_staked: u64,\n}\n\n#[account]\npub struct User {\n    pub staked_amount: u64,\n    pub last_stake_timestamp: i64,\n}\n\n#[error_code]\npub enum ErrorCode {\n    #[msg(\"Insufficient funds\")]\n    InsufficientFunds,\n}",
        "vulnerabilities": [
            "Absence of reentrancy protection in unstake function exposes the contract to potential fund drainage through recursive calls.",
            "Lack of penalty mechanism for premature unstaking may lead to economic instability and unfair advantage for short-term stakers.",
            "Unprotected arithmetic in reward calculations risks integer overflow, potentially leading to excessive or undervalued rewards.",
            "Unrestricted access to initialization function allows unauthorized setting or resetting of critical contract parameters."
          ]
    },
    {
        "code": "use solana_program::{\n    account_info::{next_account_info, AccountInfo},\n    entrypoint,\n    entrypoint::ProgramResult,\n    program::invoke,\n    pubkey::Pubkey,\n    msg,\n};\n\nentrypoint!(process_instruction);\n\nfn process_instruction(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    _instruction_data: &[u8],\n) -> ProgramResult {\n    let accounts_iter = &mut accounts.iter();\n    let user_account = next_account_info(accounts_iter)?;\n    let receiver_account = next_account_info(accounts_iter)?;\n\n    if !user_account.is_signer {\n        return Err(ProgramError::MissingRequiredSignature);\n    }\n\n    let transfer_amount = 100;\n\n    if user_account.lamports() < transfer_amount {\n        return Err(ProgramError::InsufficientFunds);\n    }\n\n    **user_account.try_borrow_mut_lamports()? -= transfer_amount;\n\n    invoke(\n        &solana_program::system_instruction::transfer(\n            user_account.key,\n            receiver_account.key,\n            transfer_amount,\n        ),\n        &[user_account.clone(), receiver_account.clone()],\n    )?;\n\n    msg!(\"Transferred {} lamports to {}\", transfer_amount, receiver_account.key);\n\n    Ok(())\n}",
        "vulnerabilities": [
            "Unprotected state changes enable malicious reentrancy attacks, potentially leading to fund drainage or contract state manipulation."
          ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount};\n\n#[program]\nmod vulnerable_escrow {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, amount: u64) -> Result<()> {\n        let escrow = &mut ctx.accounts.escrow;\n        escrow.initializer = ctx.accounts.initializer.key();\n        escrow.token_account = ctx.accounts.temp_token_account.key();\n        escrow.amount = amount;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                token::Transfer {\n                    from: ctx.accounts.initializer_token_account.to_account_info(),\n                    to: ctx.accounts.temp_token_account.to_account_info(),\n                    authority: ctx.accounts.initializer.to_account_info(),\n                },\n            ),\n            amount,\n        )?;\n\n        Ok(())\n    }\n\n    pub fn exchange(ctx: Context<Exchange>) -> Result<()> {\n        let escrow = &ctx.accounts.escrow;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                token::Transfer {\n                    from: ctx.accounts.taker_token_account.to_account_info(),\n                    to: ctx.accounts.initializer_receive_account.to_account_info(),\n                    authority: ctx.accounts.taker.to_account_info(),\n                },\n            ),\n            escrow.amount,\n        )?;\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                token::Transfer {\n                    from: ctx.accounts.temp_token_account.to_account_info(),\n                    to: ctx.accounts.taker_receive_account.to_account_info(),\n                    authority: ctx.accounts.escrow.to_account_info(),\n                },\n                &[&[b\"escrow\", &escrow.initializer.to_bytes(), &[*ctx.bumps.get(\"escrow\").unwrap()]]],\n            ),\n            escrow.amount,\n        )?;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(mut)]\n    pub initializer: Signer<'info>,\n    #[account(mut)]\n    pub temp_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub initializer_token_account: Account<'info, TokenAccount>,\n    #[account(init, payer = initializer, space = 8 + 32 + 32 + 8)]\n    pub escrow: Account<'info, Escrow>,\n    pub token_program: Program<'info, Token>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Exchange<'info> {\n    #[account(mut)]\n    pub taker: Signer<'info>,\n    #[account(mut)]\n    pub taker_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub taker_receive_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub initializer_receive_account: Account<'info, TokenAccount>,\n    #[account(mut, close = initializer)]\n    pub escrow: Account<'info, Escrow>,\n    #[account(mut)]\n    pub temp_token_account: Account<'info, TokenAccount>,\n    /// CHECK: This is not dangerous because we don't read or write from this account\n    pub initializer: AccountInfo<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct Escrow {\n    pub initializer: Pubkey,\n    pub token_account: Pubkey,\n    pub amount: u64,\n}",
        "vulnerabilities": [
            "Absence of time-based expiration for escrow risks indefinite fund locking and potential loss of assets.",
            "Lack of escrow cancellation mechanism for the initializer limits flexibility and may lead to problematic escrows persisting.",
            "Insufficient verification of token account ownership enables potential misappropriation of funds in escrow operations."
          ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount};\n\n#[program]\nmod vulnerable_vesting {\n    use super::*;\n\n    pub fn create_vesting(ctx: Context<CreateVesting>, amount: u64, duration: i64) -> Result<()> {\n        let vesting = &mut ctx.accounts.vesting;\n        vesting.beneficiary = ctx.accounts.beneficiary.key();\n        vesting.token_mint = ctx.accounts.token_mint.key();\n        vesting.start_time = Clock::get()?.unix_timestamp;\n        vesting.end_time = vesting.start_time + duration;\n        vesting.total_amount = amount;\n        vesting.released_amount = 0;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                token::Transfer {\n                    from: ctx.accounts.creator_token_account.to_account_info(),\n                    to: ctx.accounts.vesting_token_account.to_account_info(),\n                    authority: ctx.accounts.creator.to_account_info(),\n                },\n            ),\n            amount,\n        )?;\n\n        Ok(())\n    }\n\n    pub fn release(ctx: Context<Release>) -> Result<()> {\n        let vesting = &mut ctx.accounts.vesting;\n        let now = Clock::get()?.unix_timestamp;\n        let vested_amount = (vesting.total_amount * (now - vesting.start_time) as u64) / (vesting.end_time - vesting.start_time) as u64;\n        let unreleased_amount = vested_amount.saturating_sub(vesting.released_amount);\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                token::Transfer {\n                    from: ctx.accounts.vesting_token_account.to_account_info(),\n                    to: ctx.accounts.beneficiary_token_account.to_account_info(),\n                    authority: vesting.to_account_info(),\n                },\n                &[&[b\"vesting\", vesting.beneficiary.as_ref(), &[*ctx.bumps.get(\"vesting\").unwrap()]]],\n            ),\n            unreleased_amount,\n        )?;\n\n        vesting.released_amount += unreleased_amount;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct CreateVesting<'info> {\n    #[account(init, payer = creator, space = 8 + 32 + 32 + 8 + 8 + 8 + 8)]\n    pub vesting: Account<'info, Vesting>,\n    #[account(mut)]\n    pub creator: Signer<'info>,\n    /// CHECK: This account is not read from or written to\n    pub beneficiary: AccountInfo<'info>,\n    pub token_mint: Account<'info, token::Mint>,\n    #[account(mut)]\n    pub creator_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub vesting_token_account: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Release<'info> {\n    #[account(mut)]\n    pub vesting: Account<'info, Vesting>,\n    #[account(mut)]\n    pub vesting_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub beneficiary_token_account: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct Vesting {\n    pub beneficiary: Pubkey,\n    pub token_mint: Pubkey,\n    pub start_time: i64,\n    pub end_time: i64,\n    pub total_amount: u64,\n    pub released_amount: u64,\n}",
        "vulnerabilities": [
            "Unchecked arithmetic in vested amount calculation risks integer overflow, potentially allowing premature or excessive token release.",
            "Unrestricted access to release function enables unauthorized distribution of vested tokens, compromising vesting schedule integrity.",
            "Absence of mechanism to handle unclaimed tokens post-vesting may lead to permanently locked assets or unintended token distribution."
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount};\n\n#[program]\nmod vulnerable_multisig {\n    use super::*;\n\n    pub fn create_multisig(ctx: Context<CreateMultisig>, owners: Vec<Pubkey>, threshold: u64) -> Result<()> {\n        let multisig = &mut ctx.accounts.multisig;\n        multisig.owners = owners;\n        multisig.threshold = threshold;\n        multisig.nonce = 0;\n        Ok(())\n    }\n\n    pub fn create_transaction(ctx: Context<CreateTransaction>, program_id: Pubkey, accounts: Vec<TransactionAccount>, data: Vec<u8>) -> Result<()> {\n        let multisig = &ctx.accounts.multisig;\n        let transaction = &mut ctx.accounts.transaction;\n        transaction.program_id = program_id;\n        transaction.accounts = accounts;\n        transaction.data = data;\n        transaction.signers = vec![false; multisig.owners.len()];\n        transaction.did_execute = false;\n        Ok(())\n    }\n\n    pub fn approve(ctx: Context<Approve>) -> Result<()> {\n        let multisig = &ctx.accounts.multisig;\n        let transaction = &mut ctx.accounts.transaction;\n        let owner_index = multisig.owners.iter().position(|a| a == ctx.accounts.owner.key).unwrap();\n        transaction.signers[owner_index] = true;\n        Ok(())\n    }\n\n    pub fn execute_transaction(ctx: Context<ExecuteTransaction>) -> Result<()> {\n        let multisig = &ctx.accounts.multisig;\n        let transaction = &mut ctx.accounts.transaction;\n\n        require!(!transaction.did_execute, MultisigError::AlreadyExecuted);\n\n        let sig_count = transaction.signers.iter().filter(|&did_sign| *did_sign).count() as u64;\n        require!(sig_count >= multisig.threshold, MultisigError::NotEnoughSigners);\n\n        let mut accounts = ctx.remaining_accounts.iter();\n        let mut account_infos = Vec::new();\n        for acc in &transaction.accounts {\n            let account_info = next_account_info(&mut accounts)?;\n            account_infos.push(AccountMeta {\n                pubkey: *account_info.key,\n                is_signer: acc.is_signer,\n                is_writable: acc.is_writable,\n            });\n        }\n\n        let ix = Instruction {\n            program_id: transaction.program_id,\n            accounts: account_infos,\n            data: transaction.data.clone(),\n        };\n\n        invoke(&ix, ctx.remaining_accounts)?;\n\n        transaction.did_execute = true;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct CreateMultisig<'info> {\n    #[account(init, payer = payer, space = 8 + 32 * 10 + 8 + 8)]\n    pub multisig: Account<'info, Multisig>,\n    #[account(mut)]\n    pub payer: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct CreateTransaction<'info> {\n    pub multisig: Account<'info, Multisig>,\n    #[account(init, payer = proposer, space = 8 + 32 + 32 * 10 + 1000 + 10 + 1)]\n    pub transaction: Account<'info, Transaction>,\n    #[account(mut)]\n    pub proposer: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Approve<'info> {\n    pub multisig: Account<'info, Multisig>,\n    #[account(mut)]\n    pub transaction: Account<'info, Transaction>,\n    pub owner: Signer<'info>,\n}\n\n#[derive(Accounts)]\npub struct ExecuteTransaction<'info> {\n    pub multisig: Account<'info, Multisig>,\n    #[account(mut)]\n    pub transaction: Account<'info, Transaction>,\n}\n\n#[account]\npub struct Multisig {\n    pub owners: Vec<Pubkey>,\n    pub threshold: u64,\n    pub nonce: u64,\n}\n\n#[account]\npub struct Transaction {\n    pub program_id: Pubkey,\n    pub accounts: Vec<TransactionAccount>,\n    pub data: Vec<u8>,\n    pub signers: Vec<bool>,\n    pub did_execute: bool,\n}\n\n#[derive(AnchorSerialize, AnchorDeserialize, Clone)]\npub struct TransactionAccount {\n    pub pubkey: Pubkey,\n    pub is_signer: bool,\n    pub is_writable: bool,\n}\n\n#[error_code]\npub enum MultisigError {\n    #[msg(\"The given transaction has already been executed\")]\n    AlreadyExecuted,\n    #[msg(\"Not enough owners signed this transaction\")]\n    NotEnoughSigners,\n}",
        "vulnerabilities": [
            "Lack of validation for unique owners in multisig setup allows potential centralization and undermines the purpose of multi-party control.",
            "Absence of functionality to modify multisig participants or threshold limits adaptability and poses risks if owner accounts are compromised.",
            "Vulnerability to transaction replay attacks enables potential reuse of signatures, compromising the security of multisig operations."
          ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\ndeclare_id!(\"Swap22222222222222222222222222222222222222\");\n\n#[program]\npub mod vulnerable_token_swap {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {\n        let swap = &mut ctx.accounts.swap;\n        swap.token_a_account = ctx.accounts.token_a_account.key();\n        swap.token_b_account = ctx.accounts.token_b_account.key();\n        swap.fee_numerator = 3;\n        swap.fee_denominator = 1000;\n        Ok(())\n    }\n\n    pub fn swap(ctx: Context<Swap>, amount_in: u64) -> Result<()> {\n        let swap = &ctx.accounts.swap;\n        let amount_out = amount_in * 98 / 100; // Simple 2% slippage\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_a.to_account_info(),\n                    to: ctx.accounts.swap_token_a.to_account_info(),\n                    authority: ctx.accounts.user.to_account_info(),\n                },\n            ),\n            amount_in,\n        )?;\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.swap_token_b.to_account_info(),\n                    to: ctx.accounts.user_token_b.to_account_info(),\n                    authority: swap.to_account_info(),\n                },\n                &[&[&swap.key().to_bytes(), &[*ctx.bumps.get(\"swap\").unwrap()]]],\n            ),\n            amount_out,\n        )?;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = payer, space = 8 + 32 + 32 + 8 + 8)]\n    pub swap: Account<'info, Swap>,\n    pub token_a_account: Account<'info, TokenAccount>,\n    pub token_b_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub payer: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Swap<'info> {\n    #[account(mut)]\n    pub swap: Account<'info, Swap>,\n    #[account(mut)]\n    pub user_token_a: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub user_token_b: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub swap_token_a: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub swap_token_b: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct Swap {\n    pub token_a_account: Pubkey,\n    pub token_b_account: Pubkey,\n    pub fee_numerator: u64,\n    pub fee_denominator: u64,\n}",
        "vulnerabilities": [
            "Absence of price oracle integration exposes the system to potential price manipulation and outdated asset valuations.",
            "Static slippage tolerance fails to adapt to market volatility, potentially resulting in unfavorable trades or excessive slippage.",
            "Lack of pre-trade liquidity verification may lead to failed transactions or unexpected token shortages during swaps."
        ]
    },
    {
        "code": "use solana_program::{\n    account_info::{next_account_info, AccountInfo},\n    entrypoint,\n    entrypoint::ProgramResult,\n    program::invoke,\n    pubkey::Pubkey,\n    msg,\n};\n\nentrypoint!(process_instruction);\n\nfn process_instruction(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    instruction_data: &[u8],\n) -> ProgramResult {\n    let accounts_iter = &mut accounts.iter();\n    let user_account = next_account_info(accounts_iter)?;\n    let external_contract = next_account_info(accounts_iter)?;\n\n    if !user_account.is_signer {\n        return Err(ProgramError::MissingRequiredSignature);\n    }\n\n    msg!(\"Calling external contract\");\n    let result = invoke(\n        &instruction_data,\n        &[user_account.clone(), external_contract.clone()],\n    );\n\n    match result {\n        Ok(_) => msg!(\"External contract call successful\"),\n        Err(e) => {\n            msg!(\"Error in external contract call: {:?}\", e);\n            return Err(e);\n        }\n    }\n\n    // Continue processing based on external contract output\n    // ...\n\n    Ok(())\n}",
        "vulnerabilities": [
            "Flawed control flow logic enables potential bypassing of critical checks or execution of unintended code paths.",
            "Failure to properly handle exceptions risks unexpected contract behavior and potential exploitation of failed operations."
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\ndeclare_id!(\"Lend22222222222222222222222222222222222222\");\n\n#[program]\npub mod vulnerable_lending {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, interest_rate: u64) -> Result<()> {\n        let lending_pool = &mut ctx.accounts.lending_pool;\n        lending_pool.interest_rate = interest_rate;\n        lending_pool.total_deposits = 0;\n        lending_pool.total_borrows = 0;\n        Ok(())\n    }\n\n    pub fn deposit(ctx: Context<Deposit>, amount: u64) -> Result<()> {\n        let lending_pool = &mut ctx.accounts.lending_pool;\n        let user = &mut ctx.accounts.user;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token.to_account_info(),\n                    to: ctx.accounts.pool_token.to_account_info(),\n                    authority: user.to_account_info(),\n                },\n            ),\n            amount,\n        )?;\n\n        lending_pool.total_deposits += amount;\n        user.deposited_amount += amount;\n\n        Ok(())\n    }\n\n    pub fn borrow(ctx: Context<Borrow>, amount: u64) -> Result<()> {\n        let lending_pool = &mut ctx.accounts.lending_pool;\n        let user = &mut ctx.accounts.user;\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.pool_token.to_account_info(),\n                    to: ctx.accounts.user_token.to_account_info(),\n                    authority: lending_pool.to_account_info(),\n                },\n                &[&[&lending_pool.key().to_bytes(), &[*ctx.bumps.get(\"lending_pool\").unwrap()]]],\n            ),\n            amount,\n        )?;\n\n        lending_pool.total_borrows += amount;\n        user.borrowed_amount += amount;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = payer, space = 8 + 8 + 8 + 8)]\n    pub lending_pool: Account<'info, LendingPool>,\n    #[account(mut)]\n    pub payer: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Deposit<'info> {\n    #[account(mut)]\n    pub lending_pool: Account<'info, LendingPool>,\n    #[account(mut)]\n    pub user: Account<'info, User>,\n    #[account(mut)]\n    pub user_token: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct Borrow<'info> {\n    #[account(mut)]\n    pub lending_pool: Account<'info, LendingPool>,\n    #[account(mut)]\n    pub user: Account<'info, User>,\n    #[account(mut)]\n    pub user_token: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct LendingPool {\n    pub interest_rate: u64,\n    pub total_deposits: u64,\n    pub total_borrows: u64,\n}\n\n#[account]\npub struct User {\n    pub deposited_amount: u64,\n    pub borrowed_amount: u64,\n}",
        "vulnerabilities": [
            "Insufficient collateral validation exposes the system to undercollateralized positions and increased risk of insolvency.",
            "Lack of dynamic interest accrual mechanism fails to reflect market conditions and may lead to unfair lending/borrowing rates.",
            "Missing liquidation process leaves the protocol vulnerable to bad debt accumulation during market downturns."
          ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\nmod vulnerable_ico {\n    use super::*;\n\n    pub fn initialize_ico(ctx: Context<InitializeICO>, token_price: u64, cap: u64, end_time: i64) -> Result<()> {\n        let ico = &mut ctx.accounts.ico;\n        ico.creator = ctx.accounts.creator.key();\n        ico.token_price = token_price;\n        ico.cap = cap;\n        ico.end_time = end_time;\n        ico.total_raised = 0;\n        ico.is_active = true;\n        Ok(())\n    }\n\n    pub fn buy_tokens(ctx: Context<BuyTokens>, amount: u64) -> Result<()> {\n        let ico = &mut ctx.accounts.ico;\n        let clock = Clock::get()?;\n\n        require!(ico.is_active, ICOError::ICOInactive);\n        require!(clock.unix_timestamp < ico.end_time, ICOError::ICOEnded);\n\n        let purchase_amount = amount.checked_mul(ico.token_price).unwrap();\n        require!(ico.total_raised.checked_add(purchase_amount).unwrap() <= ico.cap, ICOError::CapReached);\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.buyer_token_account.to_account_info(),\n                    to: ctx.accounts.ico_token_account.to_account_info(),\n                    authority: ctx.accounts.buyer.to_account_info(),\n                },\n            ),\n            purchase_amount,\n        )?;\n\n        token::mint_to(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                token::MintTo {\n                    mint: ctx.accounts.ico_mint.to_account_info(),\n                    to: ctx.accounts.buyer_ico_token_account.to_account_info(),\n                    authority: ico.to_account_info(),\n                },\n                &[&[b\"ico\".as_ref(), &[*ctx.bumps.get(\"ico\").unwrap()]]],\n            ),\n            amount,\n        )?;\n\n        ico.total_raised += purchase_amount;\n\n        Ok(())\n    }\n\n    pub fn end_ico(ctx: Context<EndICO>) -> Result<()> {\n        let ico = &mut ctx.accounts.ico;\n        let clock = Clock::get()?;\n\n        require!(ico.is_active, ICOError::ICOInactive);\n        require!(clock.unix_timestamp >= ico.end_time, ICOError::ICONotEnded);\n\n        ico.is_active = false;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct InitializeICO<'info> {\n    #[account(init, payer = creator, space = 8 + 32 + 8 + 8 + 8 + 8 + 1, seeds = [b\"ico\"], bump)]\n    pub ico: Account<'info, ICO>,\n    #[account(mut)]\n    pub creator: Signer<'info>,\n    pub ico_mint: Account<'info, token::Mint>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct BuyTokens<'info> {\n    #[account(mut)]\n    pub ico: Account<'info, ICO>,\n    #[account(mut)]\n    pub buyer: Signer<'info>,\n    #[account(mut)]\n    pub buyer_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub ico_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub buyer_ico_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub ico_mint: Account<'info, token::Mint>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct EndICO<'info> {\n    #[account(mut)]\n    pub ico: Account<'info, ICO>,\n    pub creator: Signer<'info>,\n}\n\n#[account]\npub struct ICO {\n    pub creator: Pubkey,\n    pub token_price: u64,\n    pub cap: u64,\n    pub end_time: i64,\n    pub total_raised: u64,\n    pub is_active: bool,\n}\n\n#[error_code]\npub enum ICOError {\n    #[msg(\"ICO is not active\")]\n    ICOInactive,\n    #[msg(\"ICO has ended\")]\n    ICOEnded,\n    #[msg(\"ICO cap reached\")]\n    CapReached,\n    #[msg(\"ICO has not ended yet\")]\n    ICONotEnded,\n}",
        "vulnerabilities": [
            "Absence of KYC/AML checks may lead to regulatory non-compliance and potential misuse of the platform for illicit activities.",
            "Lack of refund mechanism in case of ICO failure risks permanent loss of investor funds and potential legal implications.",
            "Unrestricted access to ICO termination function allows unauthorized parties to prematurely end the token sale."
          ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\npub mod vulnerable_flash_loan {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, fee_rate: u64) -> Result<()> {\n        let flash_loan_pool = &mut ctx.accounts.flash_loan_pool;\n        flash_loan_pool.authority = ctx.accounts.authority.key();\n        flash_loan_pool.fee_rate = fee_rate;\n        flash_loan_pool.total_liquidity = 0;\n        Ok(())\n    }\n\n    pub fn deposit(ctx: Context<Deposit>, amount: u64) -> Result<()> {\n        let flash_loan_pool = &mut ctx.accounts.flash_loan_pool;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_account.to_account_info(),\n                    to: ctx.accounts.pool_token_account.to_account_info(),\n                    authority: ctx.accounts.user.to_account_info(),\n                },\n            ),\n            amount,\n        )?;\n\n        flash_loan_pool.total_liquidity += amount;\n        Ok(())\n    }\n\n    pub fn withdraw(ctx: Context<Withdraw>, amount: u64) -> Result<()> {\n        let flash_loan_pool = &mut ctx.accounts.flash_loan_pool;\n\n        require!(flash_loan_pool.total_liquidity >= amount, ErrorCode::InsufficientLiquidity);\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.pool_token_account.to_account_info(),\n                    to: ctx.accounts.user_token_account.to_account_info(),\n                    authority: flash_loan_pool.to_account_info(),\n                },\n                &[&[&flash_loan_pool.authority.to_bytes(), &[*ctx.bumps.get(\"flash_loan_pool\").unwrap()]]],\n            ),\n            amount,\n        )?;\n\n        flash_loan_pool.total_liquidity -= amount;\n        Ok(())\n    }\n\n    pub fn flash_loan(ctx: Context<FlashLoan>, amount: u64) -> Result<()> {\n        let flash_loan_pool = &ctx.accounts.flash_loan_pool;\n\n        require!(flash_loan_pool.total_liquidity >= amount, ErrorCode::InsufficientLiquidity);\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.pool_token_account.to_account_info(),\n                    to: ctx.accounts.borrower_token_account.to_account_info(),\n                    authority: flash_loan_pool.to_account_info(),\n                },\n                &[&[&flash_loan_pool.authority.to_bytes(), &[*ctx.bumps.get(\"flash_loan_pool\").unwrap()]]],\n            ),\n            amount,\n        )?;\n\n        // Borrower's custom logic would go here\n\n        let fee = amount * flash_loan_pool.fee_rate / 10000;\n        let repay_amount = amount + fee;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.borrower_token_account.to_account_info(),\n                    to: ctx.accounts.pool_token_account.to_account_info(),\n                    authority: ctx.accounts.borrower.to_account_info(),\n                },\n            ),\n            repay_amount,\n        )?;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 8 + 8)]\n    pub flash_loan_pool: Account<'info, FlashLoanPool>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Deposit<'info> {\n    #[account(mut)]\n    pub flash_loan_pool: Account<'info, FlashLoanPool>,\n    #[account(mut)]\n    pub user: Signer<'info>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_account: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct Withdraw<'info> {\n    #[account(mut)]\n    pub flash_loan_pool: Account<'info, FlashLoanPool>,\n    #[account(mut)]\n    pub user: Signer<'info>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_account: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct FlashLoan<'info> {\n    #[account(mut)]\n    pub flash_loan_pool: Account<'info, FlashLoanPool>,\n    #[account(mut)]\n    pub borrower: Signer<'info>,\n    #[account(mut)]\n    pub borrower_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_account: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct FlashLoanPool {\n    pub authority: Pubkey,\n    pub fee_rate: u64,\n    pub total_liquidity: u64,\n}",
        "vulnerabilities": [
            "Unprotected flash_loan function enables reentrancy attacks, potentially leading to unauthorized fund drainage or state manipulation.",
            "Lack of access restrictions on withdraw function allows unauthorized users to extract funds from the contract.",
            "Absence of bounds checking for fee_rate in initialization risks setting extreme or invalid fee structures."
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\npub mod vulnerable_staking {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, reward_rate: u64) -> Result<()> {\n        let staking_pool = &mut ctx.accounts.staking_pool;\n        staking_pool.authority = ctx.accounts.authority.key();\n        staking_pool.reward_rate = reward_rate;\n        Ok(())\n    }\n\n    pub fn stake(ctx: Context<Stake>, amount: u64) -> Result<()> {\n        let staking_pool = &mut ctx.accounts.staking_pool;\n        let user = &ctx.accounts.user;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_account.to_account_info(),\n                    to: ctx.accounts.pool_token_account.to_account_info(),\n                    authority: user.to_account_info(),\n                },\n            ),\n            amount,\n        )?;\n\n        staking_pool.total_staked += amount;\n        staking_pool.user_stakes.insert(user.key(), amount);\n\n        Ok(())\n    }\n\n    pub fn claim_rewards(ctx: Context<ClaimRewards>) -> Result<()> {\n        let staking_pool = &mut ctx.accounts.staking_pool;\n        let user = &ctx.accounts.user;\n        let user_stake = *staking_pool.user_stakes.get(&user.key()).unwrap_or(&0);\n        let rewards = user_stake * staking_pool.reward_rate;\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.pool_token_account.to_account_info(),\n                    to: ctx.accounts.user_token_account.to_account_info(),\n                    authority: staking_pool.to_account_info(),\n                },\n                &[&[&staking_pool.authority.to_bytes(), &[*ctx.bumps.get(\"staking_pool\").unwrap()]]],\n            ),\n            rewards,\n        )?;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 8 + 64 + 64)]\n    pub staking_pool: Account<'info, StakingPool>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Stake<'info> {\n    #[account(mut)]\n    pub staking_pool: Account<'info, StakingPool>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct ClaimRewards<'info> {\n    #[account(mut)]\n    pub staking_pool: Account<'info, StakingPool>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct StakingPool {\n    pub authority: Pubkey,\n    pub reward_rate: u64,\n    pub total_staked: u64,\n    pub user_stakes: std::collections::HashMap<Pubkey, u64>,\n}",
        "vulnerabilities": [
            "Missing reentrancy guards in stake and claim_rewards functions allow potential exploitation through recursive calls, risking fund loss.",
            "Lack of reward rate validation enables setting of arbitrary or extreme rates, potentially destabilizing the reward economy.",
            "Absence of timestamp tracking for rewards calculation may lead to inaccurate or manipulable reward distributions."
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\npub mod vulnerable_auction {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, starting_bid: u64) -> Result<()> {\n        let auction = &mut ctx.accounts.auction;\n        auction.authority = ctx.accounts.authority.key();\n        auction.starting_bid = starting_bid;\n        Ok(())\n    }\n\n    pub fn place_bid(ctx: Context<PlaceBid>, amount: u64) -> Result<()> {\n        let auction = &mut ctx.accounts.auction;\n        let user = &ctx.accounts.user;\n\n        require!(amount > auction.highest_bid, ErrorCode::BidTooLow);\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_account.to_account_info(),\n                    to: ctx.accounts.auction_token_account.to_account_info(),\n                    authority: user.to_account_info(),\n                },\n            ),\n            amount,\n        )?;\n\n        auction.highest_bid = amount;\n        auction.highest_bidder = user.key();\n\n        Ok(())\n    }\n\n    pub fn finalize_auction(ctx: Context<FinalizeAuction>) -> Result<()> {\n        let auction = &mut ctx.accounts.auction;\n        let winner = auction.highest_bidder;\n        let winning_bid = auction.highest_bid;\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.auction_token_account.to_account_info(),\n                    to: ctx.accounts.authority_token_account.to_account_info(),\n                    authority: auction.to_account_info(),\n                },\n                &[&[&auction.authority.to_bytes(), &[*ctx.bumps.get(\"auction\").unwrap()]]],\n            ),\n            winning_bid,\n        )?;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 8 + 64 + 64)]\n    pub auction: Account<'info, Auction>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct PlaceBid<'info> {\n    #[account(mut)]\n    pub auction: Account<'info, Auction>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub auction_token_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct FinalizeAuction<'info> {\n    #[account(mut)]\n    pub auction: Account<'info, Auction>,\n    #[account(mut)]\n    pub authority_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub auction_token_account: Account<'info, TokenAccount>,\n    pub authority: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct Auction {\n    pub authority: Pubkey,\n    pub starting_bid: u64,\n    pub highest_bid: u64,\n    pub highest_bidder: Pubkey,\n}",
        "vulnerabilities": [
            "Absence of minimum bid increment allows microscopic outbidding, potentially leading to auction sniping and unfair outcomes.",
            "Lack of automatic refund mechanism for outbid users may result in funds being trapped in the contract.",
            "Missing validation of auction end time enables creation of auctions with arbitrary or invalid durations."
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\npub mod vulnerable_exchange {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, fee_rate: u64) -> Result<()> {\n        let exchange = &mut ctx.accounts.exchange;\n        exchange.authority = ctx.accounts.authority.key();\n        exchange.fee_rate = fee_rate;\n        Ok(())\n    }\n\n    pub fn swap(ctx: Context<Swap>, amount: u64) -> Result<()> {\n        let exchange = &mut ctx.accounts.exchange;\n        let user = &ctx.accounts.user;\n        let fee = amount * exchange.fee_rate / 100;\n        let amount_after_fee = amount - fee;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_account.to_account_info(),\n                    to: ctx.accounts.pool_token_account.to_account_info(),\n                    authority: user.to_account_info(),\n                },\n            ),\n            amount_after_fee,\n        )?;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_account.to_account_info(),\n                    to: ctx.accounts.fee_token_account.to_account_info(),\n                    authority: user.to_account_info(),\n                },\n            ),\n            fee,\n        )?;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 8 + 64 + 64)]\n    pub exchange: Account<'info, Exchange>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Swap<'info> {\n    #[account(mut)]\n    pub exchange: Account<'info, Exchange>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub fee_token_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct Exchange {\n    pub authority: Pubkey,\n    pub fee_rate: u64,\n}",
        "vulnerabilities": [
            "Flawed fee calculation algorithm risks integer overflow, potentially leading to excessive or undercharged fees.",
            "Absence of slippage protection exposes users to front-running attacks and unfavorable trade execution.",
            "Lack of proper authorization checks for token transfers may allow unauthorized movement of user funds."
          ]        
    },         
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\npub mod vulnerable_voting {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, voting_duration: i64) -> Result<()> {\n        let voting = &mut ctx.accounts.voting;\n        voting.authority = ctx.accounts.authority.key();\n        voting.voting_duration = voting_duration;\n        voting.start_time = Clock::get().unwrap().unix_timestamp;\n        Ok(())\n    }\n\n    pub fn vote(ctx: Context<Vote>, choice: u8) -> Result<()> {\n        let voting = &mut ctx.accounts.voting;\n        let user = &ctx.accounts.user;\n        require!(Clock::get().unwrap().unix_timestamp < voting.start_time + voting.voting_duration, ErrorCode::VotingEnded);\n\n        match choice {\n            0 => voting.option_a += 1,\n            1 => voting.option_b += 1,\n            _ => return Err(ErrorCode::InvalidChoice.into()),\n        }\n\n        voting.user_votes.insert(user.key(), choice);\n\n        Ok(())\n    }\n\n    pub fn end_voting(ctx: Context<EndVoting>) -> Result<()> {\n        let voting = &mut ctx.accounts.voting;\n        require!(Clock::get().unwrap().unix_timestamp >= voting.start_time + voting.voting_duration, ErrorCode::VotingNotEnded);\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 8 + 64 + 64 + 64)]\n    pub voting: Account<'info, Voting>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Vote<'info> {\n    #[account(mut)]\n    pub voting: Account<'info, Voting>,\n    pub user: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct EndVoting<'info> {\n    #[account(mut)]\n    pub voting: Account<'info, Voting>,\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[account]\npub struct Voting {\n    pub authority: Pubkey,\n    pub voting_duration: i64,\n    pub start_time: i64,\n    pub option_a: u64,\n    pub option_b: u64,\n    pub user_votes: std::collections::HashMap<Pubkey, u8>,\n}",
        "vulnerabilities": [
            "Lack of duplicate voting protection",
            "No mechanism to handle vote cancellations",
            "Possible overflow in vote counts"
        ]
    },       
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\npub mod vulnerable_options_trading {\n    use super::*;\n\n    pub fn create_option(ctx: Context<CreateOption>, strike_price: u64, expiry: i64, amount: u64) -> Result<()> {\n        let option = &mut ctx.accounts.option;\n        option.writer = ctx.accounts.writer.key();\n        option.strike_price = strike_price;\n        option.expiry = expiry;\n        option.amount = amount;\n        option.exercised = false;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.writer_token_account.to_account_info(),\n                    to: ctx.accounts.option_token_account.to_account_info(),\n                    authority: ctx.accounts.writer.to_account_info(),\n                },\n            ),\n            amount,\n        )?;\n\n        Ok(())\n    }\n\n    pub fn exercise_option(ctx: Context<ExerciseOption>) -> Result<()> {\n        let option = &mut ctx.accounts.option;\n        let current_time = Clock::get()?.unix_timestamp;\n\n        require!(!option.exercised, ErrorCode::OptionAlreadyExercised);\n        require!(current_time <= option.expiry, ErrorCode::OptionExpired);\n\n        let total_cost = option.strike_price * option.amount;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.buyer_token_account.to_account_info(),\n                    to: ctx.accounts.writer_token_account.to_account_info(),\n                    authority: ctx.accounts.buyer.to_account_info(),\n                },\n            ),\n            total_cost,\n        )?;\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.option_token_account.to_account_info(),\n                    to: ctx.accounts.buyer_receive_account.to_account_info(),\n                    authority: option.to_account_info(),\n                },\n                &[&[&option.writer.to_bytes(), &[*ctx.bumps.get(\"option\").unwrap()]]],\n            ),\n            option.amount,\n        )?;\n\n        option.exercised = true;\n\n        Ok(())\n    }\n\n    pub fn cancel_option(ctx: Context<CancelOption>) -> Result<()> {\n        let option = &ctx.accounts.option;\n\n        require!(!option.exercised, ErrorCode::OptionAlreadyExercised);\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.option_token_account.to_account_info(),\n                    to: ctx.accounts.writer_token_account.to_account_info(),\n                    authority: option.to_account_info(),\n                },\n                &[&[&option.writer.to_bytes(), &[*ctx.bumps.get(\"option\").unwrap()]]],\n            ),\n            option.amount,\n        )?;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct CreateOption<'info> {\n    #[account(init, payer = writer, space = 8 + 32 + 8 + 8 + 8 + 1)]\n    pub option: Account<'info, Option>,\n    #[account(mut)]\n    pub writer: Signer<'info>,\n    #[account(mut)]\n    pub writer_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub option_token_account: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct ExerciseOption<'info> {\n    #[account(mut)]\n    pub option: Account<'info, Option>,\n    #[account(mut)]\n    pub buyer: Signer<'info>,\n    #[account(mut)]\n    pub buyer_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub buyer_receive_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub writer_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub option_token_account: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct CancelOption<'info> {\n    #[account(mut, has_one = writer)]\n    pub option: Account<'info, Option>,\n    #[account(mut)]\n    pub writer: Signer<'info>,\n    #[account(mut)]\n    pub writer_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub option_token_account: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct Option {\n    pub writer: Pubkey,\n    pub strike_price: u64,\n    pub expiry: i64,\n    pub amount: u64,\n    pub exercised: bool,\n}",
        "vulnerabilities": [
            "No check for option ownership in exercise_option function",
            "Missing price oracle integration for fair pricing",
            "Lack of partial exercise functionality"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\nmod vulnerable_governance {\n    use super::*;\n\n    pub fn create_proposal(ctx: Context<CreateProposal>, description: String, voting_period: i64) -> Result<()> {\n        let proposal = &mut ctx.accounts.proposal;\n        let clock = Clock::get()?;\n\n        proposal.creator = ctx.accounts.creator.key();\n        proposal.description = description;\n        proposal.start_time = clock.unix_timestamp;\n        proposal.end_time = clock.unix_timestamp + voting_period;\n        proposal.yes_votes = 0;\n        proposal.no_votes = 0;\n        proposal.executed = false;\n\n        Ok(())\n    }\n\n    pub fn cast_vote(ctx: Context<CastVote>, vote: bool) -> Result<()> {\n        let proposal = &mut ctx.accounts.proposal;\n        let voter = &ctx.accounts.voter;\n        let clock = Clock::get()?;\n\n        require!(clock.unix_timestamp >= proposal.start_time, GovernanceError::VotingNotStarted);\n        require!(clock.unix_timestamp <= proposal.end_time, GovernanceError::VotingEnded);\n\n        let voting_power = ctx.accounts.voter_token_account.amount;\n\n        if vote {\n            proposal.yes_votes += voting_power;\n        } else {\n            proposal.no_votes += voting_power;\n        }\n\n        Ok(())\n    }\n\n    pub fn execute_proposal(ctx: Context<ExecuteProposal>) -> Result<()> {\n        let proposal = &mut ctx.accounts.proposal;\n        let clock = Clock::get()?;\n\n        require!(!proposal.executed, GovernanceError::AlreadyExecuted);\n        require!(clock.unix_timestamp > proposal.end_time, GovernanceError::VotingNotEnded);\n        require!(proposal.yes_votes > proposal.no_votes, GovernanceError::ProposalRejected);\n\n        // Execute proposal logic here\n        proposal.executed = true;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct CreateProposal<'info> {\n    #[account(init, payer = creator, space = 8 + 32 + 256 + 8 + 8 + 8 + 8 + 1, seeds = [b\"proposal\", creator.key().as_ref()], bump)]\n    pub proposal: Account<'info, Proposal>,\n    #[account(mut)]\n    pub creator: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct CastVote<'info> {\n    #[account(mut)]\n    pub proposal: Account<'info, Proposal>,\n    pub voter: Signer<'info>,\n    pub voter_token_account: Account<'info, TokenAccount>,\n}\n\n#[derive(Accounts)]\npub struct ExecuteProposal<'info> {\n    #[account(mut)]\n    pub proposal: Account<'info, Proposal>,\n    pub executor: Signer<'info>,\n}\n\n#[account]\npub struct Proposal {\n    pub creator: Pubkey,\n    pub description: String,\n    pub start_time: i64,\n    pub end_time: i64,\n    pub yes_votes: u64,\n    pub no_votes: u64,\n    pub executed: bool,\n}\n\n#[error_code]\npub enum GovernanceError {\n    #[msg(\"Voting has not started yet\")]\n    VotingNotStarted,\n    #[msg(\"Voting has ended\")]\n    VotingEnded,\n    #[msg(\"Proposal has already been executed\")]\n    AlreadyExecuted,\n    #[msg(\"Voting period has not ended yet\")]\n    VotingNotEnded,\n    #[msg(\"Proposal was rejected\")]\n    ProposalRejected,\n}",
        "vulnerabilities": [
          "Double voting vulnerability",
          "Lack of quorum checks",
          "No time delay between voting end and execution"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\npub mod vulnerable_lottery {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, ticket_price: u64) -> Result<()> {\n        let lottery = &mut ctx.accounts.lottery;\n        lottery.authority = ctx.accounts.authority.key();\n        lottery.ticket_price = ticket_price;\n        Ok(())\n    }\n\n    pub fn buy_ticket(ctx: Context<BuyTicket>) -> Result<()> {\n        let lottery = &mut ctx.accounts.lottery;\n        let user = &ctx.accounts.user;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_account.to_account_info(),\n                    to: ctx.accounts.lottery_token_account.to_account_info(),\n                    authority: user.to_account_info(),\n                },\n            ),\n            lottery.ticket_price,\n        )?;\n\n        lottery.tickets.push(user.key());\n\n        Ok(())\n    }\n\n    pub fn draw_winner(ctx: Context<DrawWinner>) -> Result<()> {\n        let lottery = &mut ctx.accounts.lottery;\n        let winner = lottery.tickets[rand::random::<usize>() % lottery.tickets.len()];\n        let prize = lottery.tickets.len() as u64 * lottery.ticket_price;\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.lottery_token_account.to_account_info(),\n                    to: ctx.accounts.user_token_account.to_account_info(),\n                    authority: lottery.to_account_info(),\n                },\n                &[&[&lottery.authority.to_bytes(), &[*ctx.bumps.get(\"lottery\").unwrap()]]],\n            ),\n            prize,\n        )?;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 8 + 64 + 64)]\n    pub lottery: Account<'info, Lottery>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct BuyTicket<'info> {\n    #[account(mut)]\n    pub lottery: Account<'info, Lottery>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub lottery_token_account: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct DrawWinner<'info> {\n    #[account(mut)]\n    pub lottery: Account<'info, Lottery>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub lottery_token_account: Account<'info, TokenAccount>,\n    pub authority: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct Lottery {\n    pub authority: Pubkey,\n    pub ticket_price: u64,\n    pub tickets: Vec<Pubkey>,\n}",
        "vulnerabilities": [
            "Predictable randomness for drawing winners",
            "No limit on ticket purchases per user",
            "Possible overflow in ticket count"
        ]
    },      
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount};\n\n#[program]\nmod vulnerable_liquidity_pool {\n    use super::*;\n\n    pub fn initialize_pool(ctx: Context<InitializePool>, fee: u64) -> Result<()> {\n        let pool = &mut ctx.accounts.pool;\n        pool.token_a = ctx.accounts.token_a_mint.key();\n        pool.token_b = ctx.accounts.token_b_mint.key();\n        pool.fee = fee;\n        pool.total_liquidity = 0;\n        Ok(())\n    }\n\n    pub fn add_liquidity(ctx: Context<AddLiquidity>, amount_a: u64, amount_b: u64) -> Result<()> {\n        let pool = &mut ctx.accounts.pool;\n        let lp_tokens = if pool.total_liquidity == 0 {\n            (amount_a as u128 * amount_b as u128).sqrt() as u64\n        } else {\n            std::cmp::min(\n                amount_a * pool.total_liquidity / pool.reserve_a,\n                amount_b * pool.total_liquidity / pool.reserve_b\n            )\n        };\n\n        token::transfer(CpiContext::new(ctx.accounts.token_program.to_account_info(),\n            Transfer {\n                from: ctx.accounts.user_token_a.to_account_info(),\n                to: ctx.accounts.pool_token_a.to_account_info(),\n                authority: ctx.accounts.user.to_account_info(),\n            }), amount_a)?;\n\n        token::transfer(CpiContext::new(ctx.accounts.token_program.to_account_info(),\n            Transfer {\n                from: ctx.accounts.user_token_b.to_account_info(),\n                to: ctx.accounts.pool_token_b.to_account_info(),\n                authority: ctx.accounts.user.to_account_info(),\n            }), amount_b)?;\n\n        token::mint_to(CpiContext::new_with_signer(\n            ctx.accounts.token_program.to_account_info(),\n            MintTo {\n                mint: ctx.accounts.lp_mint.to_account_info(),\n                to: ctx.accounts.user_lp_token.to_account_info(),\n                authority: pool.to_account_info(),\n            },\n            &[&[b\"pool\", &[*ctx.bumps.get(\"pool\").unwrap()]]],\n        ), lp_tokens)?;\n\n        pool.reserve_a += amount_a;\n        pool.reserve_b += amount_b;\n        pool.total_liquidity += lp_tokens;\n\n        Ok(())\n    }\n\n    pub fn swap(ctx: Context<Swap>, amount_in: u64, minimum_amount_out: u64) -> Result<()> {\n        let pool = &mut ctx.accounts.pool;\n        let (reserve_in, reserve_out) = if ctx.accounts.token_in.mint == pool.token_a {\n            (pool.reserve_a, pool.reserve_b)\n        } else {\n            (pool.reserve_b, pool.reserve_a)\n        };\n\n        let amount_out = (amount_in as u128 * reserve_out as u128 / (reserve_in as u128 + amount_in as u128)) as u64;\n        require!(amount_out >= minimum_amount_out, ErrorCode::SlippageExceeded);\n\n        let fee = amount_out * pool.fee / 10000;\n        let amount_out_after_fee = amount_out - fee;\n\n        token::transfer(CpiContext::new(\n            ctx.accounts.token_program.to_account_info(),\n            Transfer {\n                from: ctx.accounts.user_token_in.to_account_info(),\n                to: ctx.accounts.pool_token_in.to_account_info(),\n                authority: ctx.accounts.user.to_account_info(),\n            }), amount_in)?;\n\n        token::transfer(CpiContext::new_with_signer(\n            ctx.accounts.token_program.to_account_info(),\n            Transfer {\n                from: ctx.accounts.pool_token_out.to_account_info(),\n                to: ctx.accounts.user_token_out.to_account_info(),\n                authority: pool.to_account_info(),\n            },\n            &[&[b\"pool\", &[*ctx.bumps.get(\"pool\").unwrap()]]],\n        ), amount_out_after_fee)?;\n\n        if ctx.accounts.token_in.mint == pool.token_a {\n            pool.reserve_a += amount_in;\n            pool.reserve_b -= amount_out;\n        } else {\n            pool.reserve_b += amount_in;\n            pool.reserve_a -= amount_out;\n        }\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct InitializePool<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 32 + 8 + 8 + 8 + 8)]\n    pub pool: Account<'info, Pool>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub token_a_mint: Account<'info, Mint>,\n    pub token_b_mint: Account<'info, Mint>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct AddLiquidity<'info> {\n    #[account(mut)]\n    pub pool: Account<'info, Pool>,\n    #[account(mut)]\n    pub user: Signer<'info>,\n    #[account(mut)]\n    pub user_token_a: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub user_token_b: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_a: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_b: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub lp_mint: Account<'info, Mint>,\n    #[account(mut)]\n    pub user_lp_token: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct Swap<'info> {\n    #[account(mut)]\n    pub pool: Account<'info, Pool>,\n    #[account(mut)]\n    pub user: Signer<'info>,\n    #[account(mut)]\n    pub user_token_in: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub user_token_out: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_in: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub pool_token_out: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct Pool {\n    pub token_a: Pubkey,\n    pub token_b: Pubkey,\n    pub reserve_a: u64,\n    pub reserve_b: u64,\n    pub fee: u64,\n    pub total_liquidity: u64,\n}\n\n#[error_code]\npub enum ErrorCode {\n    SlippageExceeded,\n}",
        "vulnerabilities": [
          "Lack of slippage protection in add_liquidity function",
          "Potential for front-running attacks in swap function",
          "Missing checks for minimum liquidity in pool initialization"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount};\n\n#[program]\nmod vulnerable_prediction_market {\n    use super::*;\n\n    pub fn create_market(ctx: Context<CreateMarket>, resolution_time: i64, oracle: Pubkey) -> Result<()> {\n        let market = &mut ctx.accounts.market;\n        market.creator = ctx.accounts.creator.key();\n        market.resolution_time = resolution_time;\n        market.oracle = oracle;\n        market.yes_tokens = 0;\n        market.no_tokens = 0;\n        market.resolved = false;\n        Ok(())\n    }\n\n    pub fn buy_prediction(ctx: Context<BuyPrediction>, amount: u64, prediction: bool) -> Result<()> {\n        let market = &mut ctx.accounts.market;\n        require!(!market.resolved, PredictionError::MarketResolved);\n        require!(Clock::get()?.unix_timestamp < market.resolution_time, PredictionError::MarketClosed);\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.user_token_account.to_account_info(),\n                    to: ctx.accounts.market_token_account.to_account_info(),\n                    authority: ctx.accounts.user.to_account_info(),\n                },\n            ),\n            amount,\n        )?;\n\n        if prediction {\n            market.yes_tokens += amount;\n        } else {\n            market.no_tokens += amount;\n        }\n\n        Ok(())\n    }\n\n    pub fn resolve_market(ctx: Context<ResolveMarket>, outcome: bool) -> Result<()> {\n        let market = &mut ctx.accounts.market;\n        require!(!market.resolved, PredictionError::MarketAlreadyResolved);\n        require!(Clock::get()?.unix_timestamp >= market.resolution_time, PredictionError::MarketNotClosed);\n        require!(ctx.accounts.oracle.key() == market.oracle, PredictionError::UnauthorizedOracle);\n\n        market.resolved = true;\n        market.outcome = outcome;\n\n        Ok(())\n    }\n\n    pub fn claim_winnings(ctx: Context<ClaimWinnings>) -> Result<()> {\n        let market = &ctx.accounts.market;\n        require!(market.resolved, PredictionError::MarketNotResolved);\n\n        let user_prediction = ctx.accounts.user_prediction.load()?;\n        require!(user_prediction.prediction == market.outcome, PredictionError::IncorrectPrediction);\n\n        let total_tokens = market.yes_tokens + market.no_tokens;\n        let winning_tokens = if market.outcome { market.yes_tokens } else { market.no_tokens };\n        let winnings = (user_prediction.amount as u128 * total_tokens as u128 / winning_tokens as u128) as u64;\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.market_token_account.to_account_info(),\n                    to: ctx.accounts.user_token_account.to_account_info(),\n                    authority: market.to_account_info(),\n                },\n                &[&[b\"market\", &market.creator.to_bytes(), &[*ctx.bumps.get(\"market\").unwrap()]]],\n            ),\n            winnings,\n        )?;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct CreateMarket<'info> {\n    #[account(init, payer = creator, space = 8 + 32 + 8 + 32 + 8 + 8 + 1 + 1)]\n    pub market: Account<'info, Market>,\n    #[account(mut)]\n    pub creator: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct BuyPrediction<'info> {\n    #[account(mut)]\n    pub market: Account<'info, Market>,\n    #[account(mut)]\n    pub user: Signer<'info>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub market_token_account: Account<'info, TokenAccount>,\n    #[account(init, payer = user, space = 8 + 1 + 8)]\n    pub user_prediction: Account<'info, UserPrediction>,\n    pub token_program: Program<'info, Token>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct ResolveMarket<'info> {\n    #[account(mut)]\n    pub market: Account<'info, Market>,\n    pub oracle: Signer<'info>,\n}\n\n#[derive(Accounts)]\npub struct ClaimWinnings<'info> {\n    #[account(mut)]\n    pub market: Account<'info, Market>,\n    #[account(mut)]\n    pub user: Signer<'info>,\n    #[account(mut)]\n    pub user_prediction: Account<'info, UserPrediction>,\n    #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub market_token_account: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct Market {\n    pub creator: Pubkey,\n    pub resolution_time: i64,\n    pub oracle: Pubkey,\n    pub yes_tokens: u64,\n    pub no_tokens: u64,\n    pub resolved: bool,\n    pub outcome: bool,\n}\n\n#[account]\npub struct UserPrediction {\n    pub prediction: bool,\n    pub amount: u64,\n}\n\n#[error_code]\npub enum PredictionError {\n    MarketResolved,\n    MarketClosed,\n    MarketAlreadyResolved,\n    MarketNotClosed,\n    UnauthorizedOracle,\n    MarketNotResolved,\n    IncorrectPrediction,\n}",
        "vulnerabilities": [
          "Potential for oracle manipulation",
          "Lack of protection against flash loan attacks in buying predictions",
          "Missing checks for minimum market liquidity"
        ]
    },
    {
        "code": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, Transfer};\n\n#[program]\nmod vulnerable_bridge {\n    use super::*;\n\n    pub fn initialize_bridge(ctx: Context<InitializeBridge>) -> Result<()> {\n        let bridge = &mut ctx.accounts.bridge;\n        bridge.authority = ctx.accounts.authority.key();\n        bridge.nonce = 0;\n        Ok(())\n    }\n\n    pub fn deposit(ctx: Context<Deposit>, amount: u64, recipient: [u8; 32]) -> Result<()> {\n        let bridge = &mut ctx.accounts.bridge;\n\n        token::transfer(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.depositor_token_account.to_account_info(),\n                    to: ctx.accounts.bridge_token_account.to_account_info(),\n                    authority: ctx.accounts.depositor.to_account_info(),\n                },\n            ),\n            amount,\n        )?;\n\n        bridge.nonce += 1;\n\n        emit!(DepositEvent {\n            nonce: bridge.nonce,\n            depositor: ctx.accounts.depositor.key(),\n            amount,\n            recipient\n        });\n\n        Ok(())\n    }\n\n    pub fn withdraw(ctx: Context<Withdraw>, amount: u64, nonce: u64, signature: [u8; 64]) -> Result<()> {\n        let bridge = &ctx.accounts.bridge;\n\n        // Verify signature\n        let message = [&bridge.authority.to_bytes()[..], &amount.to_le_bytes()[..], &nonce.to_le_bytes()[..]].concat();\n        require!(verify_signature(&message, &signature, &bridge.authority), BridgeError::InvalidSignature);\n\n        token::transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.token_program.to_account_info(),\n                Transfer {\n                    from: ctx.accounts.bridge_token_account.to_account_info(),\n                    to: ctx.accounts.recipient_token_account.to_account_info(),\n                    authority: bridge.to_account_info(),\n                },\n                &[&[b\"bridge\".as_ref(), &[*ctx.bumps.get(\"bridge\").unwrap()]]],\n            ),\n            amount,\n        )?;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct InitializeBridge<'info> {\n    #[account(init, payer = authority, space = 8 + 32 + 8, seeds = [b\"bridge\"], bump)]\n    pub bridge: Account<'info, Bridge>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Deposit<'info> {\n    #[account(mut)]\n    pub bridge: Account<'info, Bridge>,\n    #[account(mut)]\n    pub depositor: Signer<'info>,\n    #[account(mut)]\n    pub depositor_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub bridge_token_account: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Accounts)]\npub struct Withdraw<'info> {\n    #[account(mut)]\n    pub bridge: Account<'info, Bridge>,\n    #[account(mut)]\n    pub bridge_token_account: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub recipient_token_account: Account<'info, TokenAccount>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[account]\npub struct Bridge {\n    pub authority: Pubkey,\n    pub nonce: u64,\n}\n\n#[event]\npub struct DepositEvent {\n    pub nonce: u64,\n    pub depositor: Pubkey,\n    pub amount: u64,\n    pub recipient: [u8; 32],\n}\n\n#[error_code]\npub enum BridgeError {\n    #[msg(\"Invalid signature\")]\n    InvalidSignature,\n}\n\nfn verify_signature(message: &[u8], signature: &[u8; 64], public_key: &Pubkey) -> bool {\n    // Implement signature verification logic here\n    true // Placeholder implementation\n}",
        "vulnerabilities": [
          "Weak signature verification",
          "Lack of nonce tracking for withdrawals",
          "Missing access control for withdrawals"
        ]
    }
    
]
